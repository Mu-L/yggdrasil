alucard-dracula: 为这个文件生成文档

GitHub Copilot: arithmetic_ref.hpp 文档

---

# arithmetic_ref.hpp

## 简介

该头文件定义了 `yggr::math::arith_reference_wrapper` 模板类及相关工具函数，扩展了 Boost 的 `reference_wrapper`，用于带标记（mark）和结果类型（result_type）的引用包装器，便于泛型算法和数学运算中对引用的类型安全管理。

## 主要内容

### 1. arith_reference_wrapper 模板类

```cpp
template<typename M, typename R, typename T>
struct arith_reference_wrapper : public boost::reference_wrapper<T>
{
    typedef M mark_type; // 标记类型
    typedef boost::reference_wrapper<T> base_type;
    typedef typename base_type::type type;
    typedef typename boost::remove_const<type>::type value_type;
    typedef R result_type; // 结果类型

    arith_reference_wrapper(T& t);
    ~arith_reference_wrapper();
};
```

- **M**：标记类型（如用于区分不同用途的引用）。
- **R**：结果类型（如数学运算的返回类型）。
- **T**：被引用的对象类型。

### 2. 工具函数

- `arith_ref<T>()` 和 `arith_cref<T>()`：分别用于生成可变和只读的 `arith_reference_wrapper` 实例，支持不同的模板参数组合。

### 3. Boost 兼容性扩展

- 针对 `arith_reference_wrapper`，为 Boost 的 `is_reference_wrapper` 和 `unwrap_reference` 提供了特化，使其能与 Boost 的相关泛型算法兼容。
- 支持 const、volatile 及其组合的特化。

### 4. 其它

- 头文件包含了 MIT 许可证声明。
- 通过 `using` 声明将主要类型和函数导出到 yggr 命名空间。

## 典型用途

适用于需要对引用进行类型标记和结果类型区分的数学泛型算法场景，尤其在需要与 Boost 泛型算法协作时，能提供更强的类型安全和灵活性。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: arrangement.hpp 文档

---

# arrangement.hpp

## 简介

该头文件定义了排列数（arrangement）的相关计算函数和模板，支持运行时和编译时的排列数计算。排列数常用于组合数学中，表示从 $n$ 个不同元素中取出 $m$ 个元素进行排列的方式数。

## 主要内容

### 1. arrangement 函数模板

```cpp
template<typename T>
typename boost::enable_if<boost::is_class<T>, T>::type
    arrangement(const T& n, const T& m);

template<typename T>
typename boost::disable_if<boost::is_class<T>, T>::type
    arrangement(T n, T m);
```

- **功能**：计算排列数 $A(n, m)$，即从 $n$ 个元素中取出 $m$ 个元素进行排列的总数。
- **实现**：通过 `factorial(m) * combination(n, m)` 计算。
- **重载**：分别支持类类型和非类类型参数。

### 2. arrangement_t 编译时排列数模板

```cpp
template<std::size_t N, std::size_t M>
struct arrangement_t
    : public boost::mpl::size_t<
        pascals_triangle_t<N, M>::value * factorial_t<M>::value
      >
{};
```

- **功能**：在编译期计算排列数 $A(N, M)$，适用于模板元编程场景。
- **依赖**：`pascals_triangle_t` 和 `factorial_t`，分别用于组合数和阶乘的编译期计算。

### 3. 依赖关系

- 依赖于 combination.hpp 和 factorial.hpp，分别用于组合数和阶乘的计算。
- 使用了 Boost 的类型萃取和 MPL（元编程库）。

## 典型用途

- 适用于需要排列数计算的数学、算法、统计等领域。
- 支持运行时和编译时两种方式，便于泛型编程和模板元编程。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: array_indexes_permutation_parity.hpp 文档

---

# array_indexes_permutation_parity.hpp

## 简介

该头文件实现了数组索引排列的奇偶性（permutation parity）和符号（sign）计算的模板元编程工具。主要用于在编译期确定给定索引排列的奇偶性（即排列是偶排列还是奇排列），常用于行列式、置换群等数学和算法场景。

## 主要内容

### 1. sign_array_indexes 模板

```cpp
template<s_size_type I_IDX, s_size_type IDX_SIZE, bool ASC_OR_DESC = true>
struct sign_array_indexes
{
    static const s_size_type value = (0 == array_indexes_permutation_parity<I_IDX, IDX_SIZE, ASC_OR_DESC>::value % 2) ? 1 : -1;
};
```
- **功能**：根据排列的奇偶性，返回 $+1$（偶排列）或 $-1$（奇排列）。
- **参数**：
  - `I_IDX`：当前索引
  - `IDX_SIZE`：索引总数
  - `ASC_OR_DESC`：排列方向，`true` 为升序，`false` 为降序

### 2. array_indexes_permutation_parity 模板

```cpp
template<s_size_type I_IDX, s_size_type IDX_SIZE, bool ASC_OR_DESC = true>
struct array_indexes_permutation_parity
{
    static const s_size_type value = ...;
};
```
- **功能**：计算给定索引排列的逆序数（即排列的奇偶性）。
- **特化**：对 `IDX_SIZE` 为 0、1、2 的情况做了特化处理，提升编译期效率。

### 3. detail::indexes_loop 递归模板

- **功能**：递归计算逆序数，支持不同排列方向和边界条件。
- **实现**：通过模板递归和静态常量实现编译期计算。

### 4. 依赖关系

- 依赖 yggrdef.h 和 static_constant.hpp，用于类型定义和静态常量声明。

## 典型用途

- 适用于需要在编译期判断排列奇偶性的场景，如行列式符号、置换群、组合数学等。
- 通过模板元编程实现零运行时开销的数学属性判定。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: combination.hpp 文档

---

# combination.hpp

## 简介

该头文件实现了组合数（combination）的计算函数和模板，支持运行时和编译时的组合数计算。组合数 $C(n, m)$ 表示从 $n$ 个不同元素中取出 $m$ 个元素的方式数，是组合数学中的基础运算。

## 主要内容

### 1. combination 函数模板

```cpp
template<typename T>
typename boost::enable_if<boost::is_class<T>, T>::type
    combination(const T& n, const T& m);

template<typename T>
typename boost::disable_if<boost::is_class<T>, T>::type
    combination(T n, T m);
```

- **功能**：计算组合数 $C(n, m)$。
- **实现**：内部调用 `detail::pascals_triangle_detail<T>`，利用杨辉三角递推公式进行组合数计算。
- **重载**：分别支持类类型和非类类型参数。

### 2. combination_t 编译时组合数模板

```cpp
template<std::size_t N, std::size_t M>
struct combination_t : public detail::pascals_triangle_t<N, M> {};
```

- **功能**：在编译期计算组合数 $C(N, M)$，适用于模板元编程场景。
- **依赖**：`detail::pascals_triangle_t`，用于组合数的编译期计算。

### 3. 依赖关系

- 依赖于 pascals_triangle.hpp，用于组合数的递推实现。
- 使用了 Boost 的类型萃取工具。

## 典型用途

- 适用于需要组合数计算的数学、算法、统计等领域。
- 支持运行时和编译时两种方式，便于泛型编程和模板元编程。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: const_var.hpp 文档

---

# const_var.hpp

## 简介

该头文件定义了常用数学常数（如 $\pi$、$e$、对数、根号等）的常量和静态获取方法，支持多种浮点类型。便于在数学、科学计算等场景中安全、便捷地获取高精度常数。

## 主要内容

### 1. 宏定义

- 定义了常用数学常数的宏，如：
  - $\pi$ (`YGGR_PP_MATH_PI`)
  - $\pi/2$、$\pi/4$、$1/\pi$、$2/\pi$
  - $e$、$\log_2 e$、$\log_{10} e$、$\ln 2$、$\ln 10$
  - $\sqrt{2}$、$\sqrt{1/2}$

### 2. const_var 结构体

```cpp
struct const_var
{
    // pi
    static f64 pi();
    template<typename T> static T pi();

    static f64 pi_div_2();
    template<typename T> static T pi_div_2();

    static f64 pi_div_4();
    template<typename T> static T pi_div_4();

    static f64 eins_div_pi();
    template<typename T> static T eins_div_pi();

    static f64 zwei_div_pi();
    template<typename T> static T zwei_div_pi();

    // e
    static f64 e();
    template<typename T> static T e();

    static f64 log2e();
    template<typename T> static T log2e();

    static f64 log10e();
    template<typename T> static T log10e();

    static f64 ln2();
    template<typename T> static T ln2();

    static f64 ln10();
    template<typename T> static T ln10();

    // sqrt(2)
    static f64 sqrt2();
    template<typename T> static T sqrt2();

    static f64 sqrt_1_div_2();
    template<typename T> static T sqrt_1_div_2();
};
```

- **功能**：以静态成员函数形式提供常用数学常数，支持 `f64`（double）和任意浮点类型（如 `float`、`long double`）。
- **类型安全**：模板方法通过 `BOOST_MPL_ASSERT` 保证类型为浮点型。

### 3. 依赖关系

- 依赖 yggrdef.h、static_assert.hpp 和 Boost 类型萃取。
- 头文件末尾取消了相关宏定义，避免污染全局命名空间。

## 典型用途

- 适用于需要高精度数学常数的科学计算、工程计算、图形学等领域。
- 支持多种浮点类型，便于泛型编程。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: determinant.hpp 文档

---

# determinant.hpp

## 简介

该头文件实现了通用的行列式（Determinant）模板类，支持任意类型、任意行列数的矩阵行列式运算。支持拷贝、移动、赋值、比较、交换等操作，并可与自定义数组类型协作。适用于线性代数、数值计算、工程计算等领域。

## 主要内容

### 1. determinant 模板类

```cpp
template<typename Val, std::size_t ROW, std::size_t COL,
         template<typename _Val, std::size_t> class Base = yggr::array>
class determinant : public Base< Base<typename upper_signed<Val>::type, COL>, ROW>
{
    // ...成员类型定义...
    determinant();
    determinant(const base_type& right);
    determinant(BOOST_RV_REF(base_type) right);
    determinant(const this_type& right);
    determinant(BOOST_RV_REF(this_type) right);
    template<typename OVal, template<typename, std::size_t> class OBase>
    determinant(const OBase<OVal, E_ROW_LENGTH * E_COL_LENGTH>& right);
    // ...赋值、比较、交换等成员函数...
};
```

- **Val**：元素类型（如 float、double、int 等）
- **ROW**、**COL**：行数、列数
- **Base**：底层数组类型模板，默认为 `yggr::array`

#### 主要成员函数
- 构造函数、拷贝/移动构造、赋值运算符
- `swap`：交换内容
- `equal_to`/`not_equal_to`：矩阵内容比较
- `row_size`/`col_size`：获取行列数
- 其它成员（如零化、赋值、访问等，详见源码）

### 2. 依赖与扩展

- 支持 Boost 移动语义、类型萃取、哈希等
- 支持自定义容器类型
- 依赖 array_indexes_permutation_parity.hpp、flaw_comparer.hpp 等用于数学运算和精度比较
- 支持序列化（包含相关头文件）

### 3. 典型用途

- 任意类型、任意维度的矩阵行列式运算
- 线性代数、工程计算、科学计算等领域
- 支持泛型编程和高性能数值计算

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: division_ex.hpp 文档

---

# division_ex.hpp

## 简介

该头文件实现了多种扩展除法操作，包括向下取整（floor）、四舍五入（round）、向上取整（ceil）三种除法方式，支持整数和浮点类型的自动区分。适用于数值计算、分页、分块等需要精确控制除法结果的场景。

## 主要内容

### 1. division_ex_floor / division_ex_round / division_ex_ceil 模板结构体

- **功能**：分别实现 floor、round、ceil 三种除法方式，自动根据参与运算的类型（整数/浮点）选择不同实现。
- **实现**：
  - 对于浮点类型，直接调用 `std::floor`、`std::ceil`，round 采用 $\text{floor}((l + r/2)/r)$。
  - 对于整数类型，floor 直接整除，round 采用 $(l + r/2)/r$，ceil 采用 $(l + r - 1)/r$。

### 2. division_floor / division_round / division_ceil 内联函数

```cpp
template<typename T1, typename T2>
typename detail::division_ex_floor<T1, T2>::result_type
    division_floor(const T1& l, const T2& r);

template<typename T1, typename T2>
typename detail::division_ex_round<T1, T2>::result_type
    division_round(const T1& l, const T2& r);

template<typename T1, typename T2>
typename detail::division_ex_ceil<T1, T2>::result_type
    division_ceil(const T1& l, const T2& r);
```

- **功能**：对外提供统一接口，自动选择合适的除法实现。
- **参数**：支持任意可除类型的组合。

### 3. 依赖关系

- 依赖 upper_types.hpp、operator_result.hpp 等类型萃取工具。
- 依赖 `<cmath>` 标准库。

## 典型用途

- 适用于分页、分块、资源分配等需要精确控制除法取整方式的场景。
- 支持泛型编程，自动适配整数和浮点类型。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: elo_rating.hpp 文档

---

# elo_rating.hpp

## 简介

该头文件实现了 Elo 等级分系统的快速和标准两种评分算法，适用于棋类、竞技游戏等对抗性项目的选手积分计算。支持自定义分数类型和胜负结果类型，便于泛型和高性能应用。

## 主要内容

### 1. fast_elo_rating 类

- **功能**：实现简化版 Elo 评分算法，适合对性能要求高、积分变化规则简单的场景。
- **主要静态常量**：
  - `E_normal_k = 16`
  - `E_profession_k = 16`
- **主要方法**：
  - `delta_rating(ra, rb)`：根据双方分数计算分差（积分变化量）。
  - `rating(s, ra, rb)`：根据胜负结果和双方分数计算新分数。
  - `operator()`：重载，等价于 `rating`。
- **实现特点**：分差计算采用线性近似，积分变化有上下限保护。

### 2. elo_rating 类

- **功能**：实现标准 Elo 评分算法，适合需要精确积分调整的场景。
- **主要静态常量**：
  - `E_normal_k = 32`
  - `E_profession_k = 16`
- **主要方法**：
  - `delta_rating(s, k, ra, rb)`：根据胜负结果、K因子和双方分数计算分差。
  - `rating(s, k, ra, rb)`：根据胜负结果、K因子和双方分数计算新分数。
  - `operator()`：重载，等价于 `rating`。
- **实现特点**：采用标准 Elo 公式，支持浮点运算，积分结果向下取整。

### 3. 内部实现

- 使用 `upper_unsigned`、`upper_float` 等类型萃取，保证类型安全和泛型兼容。
- 内部 `s_elo` 方法实现了 Elo 期望得分的标准公式。

### 4. 依赖关系

- 依赖 `<complex>`、`<cmath>`、upper_types.hpp、limits.hpp 等。

## 典型用途

- 适用于棋类、电竞、体育等积分排名系统。
- 支持自定义分数类型和胜负结果类型，便于扩展和泛型编程。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: factorial.hpp 文档

---

# factorial.hpp

## 简介

该头文件实现了阶乘（factorial）的运行时和编译时计算，支持任意整数类型和自定义类型。适用于组合数学、概率统计、算法竞赛等需要阶乘运算的场景。

## 主要内容

### 1. 阶乘运行时计算

```cpp
template<typename T>
typename boost::enable_if<boost::is_class<T>, T>::type
    factorial(const T& val);

template<typename T>
typename boost::disable_if<boost::is_class<T>, T>::type
    factorial(T val);
```

- **功能**：计算 $n!$（n 的阶乘）。
- **实现**：通过 `factorial_detail<T>` 结构体实现，支持类型安全检查和泛型编程。
- **断言**：保证输入为非负整数。

### 2. 阶乘编译时计算（模板元编程）

```cpp
template<std::size_t N>
struct factorial_t : public detail::factorial_t_detail<N> {};
```

- **功能**：在编译期递归计算 $N!$，适用于模板元编程场景。
- **实现**：递归继承 `boost::mpl::size_t`，支持 $N=0$ 和 $N=1$ 的特化。

### 3. 依赖关系

- 依赖 native_t.hpp、upper_types.hpp、flaw_comparer.hpp 等类型萃取和比较工具。
- 使用 Boost 的类型萃取和 MPL 元编程库。

## 典型用途

- 适用于组合数、排列数、概率统计等数学运算。
- 支持运行时和编译时两种方式，便于泛型和模板元编程。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: flaw_comparer.hpp 文档

---

# flaw_comparer.hpp

## 简介

该头文件实现了浮点数和通用类型的“容差比较器”（flaw comparer），用于解决浮点数直接比较时的精度误差问题。支持自定义精度生成器，提供了丰富的比较操作符重载，适用于科学计算、工程计算等对数值精度有要求的场景。

## 主要内容

### 1. 精度宏定义

- `YGGR_MATH_F32_DEFAULT_PRECISION`、`YGGR_MATH_F64_DEFAULT_PRECISION`、`YGGR_MATH_FLDB_DEFAULT_PRECISION`：分别定义 float、double、long double 的默认比较精度，默认采用对应类型的 `EPSILON`。

### 2. default_flaw_genner 及 choose_default_flaw_genner

- 针对不同类型，生成默认的比较精度（浮点型返回 EPSILON，其他类型返回 0）。

### 3. flaw_comparer 模板类

```cpp
template<typename T, typename FlawGen = typename detail::choose_default_flaw_genner<T>::type>
class flaw_comparer
{
    // ...
    flaw_comparer(const value_type& val);
    flaw_comparer(const value_type& val, const TFlawGen& gen);
    // ...
    // 支持 ==, !=, <, <=, >, >= 等比较操作
};
```

- **功能**：对浮点数等类型进行带容差的比较，避免因精度误差导致的比较异常。
- **自定义精度**：可通过第二模板参数自定义精度生成器。
- **操作符重载**：支持与普通类型、另一个 flaw_comparer 之间的各种比较操作。

### 4. 非成员操作符重载

- 全面支持 flaw_comparer 与普通类型、flaw_comparer 之间的 `==, !=, <, <=, >, >=` 比较。

### 5. 工具函数

- `make_flaw_comparer`：便捷生成 flaw_comparer 对象，支持自定义精度。

### 6. 依赖关系

- 依赖 flawcmp.hpp（实现具体的比较逻辑）。
- 依赖 Boost MPL、类型萃取等。

## 典型用途

- 浮点数的安全比较（如 $0.1 + 0.2 == 0.3$ 问题）。
- 需要自定义比较精度的数值计算场景。
- 泛型算法、模板元编程中的数值比较。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: gcd_lcm.hpp 文档

---

# gcd_lcm.hpp

## 简介

该头文件实现了最大公约数（GCD）和最小公倍数（LCM）的运行时和编译时计算，支持泛型整数类型和模板元编程。适用于数论、分数约简、算法竞赛等需要 GCD/LCM 运算的场景。

## 主要内容

### 1. 运行时 GCD/LCM 计算

```cpp
template<typename T>
typename boost::enable_if<boost::is_class<T>, T>::type
    gcd(const T& num1, const T& num2);

template<typename T>
typename boost::disable_if<boost::is_class<T>, T>::type
    gcd(T num1, T num2);

template<typename T>
typename boost::enable_if<boost::is_class<T>, T>::type
    lcm(const T& num1, const T& num2);

template<typename T>
typename boost::disable_if<boost::is_class<T>, T>::type
    lcm(T num1, T num2);
```

- **功能**：计算两个数的最大公约数和最小公倍数。
- **实现**：GCD 使用辗转相除法，LCM 通过 $lcm(a, b) = a \times b / gcd(a, b)$ 计算。
- **类型安全**：仅限整数类型，编译期断言。

### 2. 编译时 GCD/LCM 计算（模板元编程）

```cpp
template<int dividend, int divisor>
struct gcd_t : public boost::mpl::int_<...> {};

template<int dividend, int divisor>
struct lcm_t : public boost::mpl::int_<...> {};
```

- **功能**：在编译期递归计算 GCD 和 LCM，适用于模板元编程场景。
- **实现**：递归继承 `boost::mpl::int_`，支持 $divisor=0$ 的特化。

### 3. 依赖关系

- 依赖 native_t.hpp、foo_input_arg_t.hpp、Boost MPL 等。

## 典型用途

- 适用于分数约简、数论算法、数学建模等场景。
- 支持运行时和编译时两种方式，便于泛型和模板元编程。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: make_zero_value.hpp 文档

---

# make_zero_value.hpp

## 简介

该头文件实现了通用的“零值生成器”工具，可用于任意类型和构造参数，自动生成该类型的“零值”。常用于泛型编程、数值初始化、矩阵/向量等数学对象的零化。

## 主要内容

### 1. make_zero_value_t 模板结构体

- **功能**：通过构造参数生成一个对象，并返回其“零值”（即 `val - val`）。
- **实现**：
  - 支持 C++11 可变参数模板（或通过宏兼容旧编译器）。
  - 适用于所有支持减法操作的类型。

### 2. make_zero_value 全局函数模板

```cpp
template<typename T, typename ...Args>
T make_zero_value(Args&&... args);
```

- **功能**：对外提供统一接口，支持任意类型和参数，生成该类型的零值。
- **实现**：内部调用 `make_zero_value_t<T>`。

### 3. 兼容性

- 支持 C++11 及更早版本（通过宏和预处理器兼容变参模板）。
- 依赖 `boost::forward` 实现参数转发。

### 4. 依赖关系

- 依赖 yggrdef.h 及相关宏定义。

## 典型用途

- 泛型算法中安全生成零值（如矩阵、向量、数值类型等）。
- 避免手动硬编码零值，提升代码通用性和可维护性。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: math.hpp 文档

---

# math.hpp

## 简介

该头文件为 yggr 数学模块的总入口，统一包含了常用数学常量、基础算法、数值工具、向量与矩阵等相关头文件。便于用户一次性引入全部数学功能，提升开发效率和代码可维护性。

## 主要内容

### 1. 统一包含的模块

- **常量与基础工具**：const_var.hpp, `range_value.hpp`, `modulus.hpp`, `sign.hpp`, `sqrt.hpp`
- **数值算法**：gcd_lcm.hpp（最大公约数/最小公倍数）、factorial.hpp（阶乘）、division_ex.hpp（扩展除法）、`odd_even_number.hpp`（奇偶性判断）
- **组合数学**：`pascals_triangle.hpp`, arrangement.hpp, combination.hpp
- **概率与统计**：elo_rating.hpp（Elo 评分）、`odds.hpp`（赔率）、`moving_avg_accumulator.hpp`（滑动平均）
- **数值比较**：flaw_comparer.hpp（容差比较器）
- **泛型工具**：make_zero_value.hpp（零值生成器）
- **线性代数**：`vector2d.hpp`, `vector3d.hpp`, `matrix2d.hpp`, `matrix3d.hpp`
- **排列相关**：array_indexes_permutation_parity.hpp
- **复数支持**：`<complex>`

### 2. 用法

只需包含本头文件，即可获得 yggr 数学模块的全部功能，无需单独包含各子模块。

```cpp
#include <yggr/math/math.hpp>
```

### 3. 典型用途

- 科学计算、工程计算、算法竞赛、数据分析等需要丰富数学工具的场景。
- 便于统一管理和升级数学相关代码。

---

如需生成 Doxygen 风格注释或更详细的模块说明，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: matrix2d_t.hpp 文档

---

# matrix2d_t.hpp

## 简介

该头文件实现了通用二维矩阵（3x3）模板类 `matrix2d`，支持任意数值类型和底层数组/基类定制。提供矩阵的构造、赋值、基本运算、行列式等功能，适用于图形学、物理仿真、工程计算等二维线性代数场景。

## 主要内容

### 1. matrix2d 模板类

```cpp
template<
    typename Val,
    template<typename _Val, std::size_t> class Array = ::yggr::array,
    template<typename _Val, std::size_t, std::size_t, template<typename __Val, std::size_t> class _Base> class Base = determinant
>
class matrix2d : public Base<typename upper_signed<Val>::type, 3, 3, Array>
{
    // ...
};
```

- **Val**：元素类型（如 float、double、int 等）
- **Array**：底层一维数组类型模板，默认为 `yggr::array`
- **Base**：基类模板，默认为 `determinant`，支持行列式等扩展

#### 主要成员
- 静态常量：行数、列数、最大秩均为 3
- 类型定义：元素类型、行类型、基类类型
- 构造函数：支持默认、元素列表、数组、标量、拷贝等多种方式
- 赋值、比较、交换、矩阵运算等（详见源码）

### 2. 依赖与扩展

- 支持 Boost 移动语义、类型萃取、哈希等
- 支持序列化（包含相关头文件）
- 依赖 determinant.hpp、flaw_comparer.hpp 等
- 适配泛型算法和高性能数值计算

### 3. 典型用途

- 二维仿射变换、图形学、物理仿真等
- 任意类型、任意底层实现的 3x3 矩阵运算
- 泛型编程和模板元编程场景

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: matrix2d.hpp 文档

---

# matrix2d.hpp

## 简介

该头文件为 3x3 二维矩阵与二维向量的乘法运算提供了泛型重载，支持不同类型、不同底层实现的矩阵与向量混合运算。适用于图形学、仿射变换、工程计算等二维线性代数场景。

## 主要内容

### 1. 主要包含内容

- 包含 `vector2d_t.hpp` 和 matrix2d_t.hpp，提供向量和矩阵的基础定义。

### 2. 运算符重载

#### 向量 × 矩阵

```cpp
template<typename ValL, typename ValR, ...>
vector2d<...> operator*(const vector2d<ValL, BaseL>& l, const matrix2d<ValR, Array, BaseR>& r);
```
- **功能**：实现列向量与矩阵的乘法，返回新向量。

#### 矩阵 × 向量

```cpp
template<typename ValL, typename ValR, ...>
vector2d<...> operator*(const matrix2d<ValL, Array, BaseL>& l, const vector2d<ValR, BaseR>& r);
```
- **功能**：实现矩阵与列向量的乘法，返回新向量。

#### 向量 *= 矩阵

```cpp
template<typename ValL, typename ValR, ...>
vector2d<ValL, BaseL>& operator*=(vector2d<ValL, BaseL>& l, const matrix2d<ValR, Array, BaseR>& r);
```
- **功能**：实现向量自乘矩阵，结果赋值回自身。

### 3. 依赖关系

- 依赖 vector2d_t.hpp、matrix2d_t.hpp。
- 支持泛型类型和底层实现的灵活组合。

## 典型用途

- 二维仿射变换、图形学、物理仿真等
- 任意类型、任意底层实现的 3x3 矩阵与二维向量运算

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: matrix3d_t.hpp 文档

---

# matrix3d_t.hpp

## 简介

该头文件实现了通用三维矩阵（4x4）模板类 `matrix3d`，支持任意数值类型和底层数组/基类定制。提供矩阵的构造、赋值、基本运算、行列式等功能，适用于三维图形学、物理仿真、工程计算等三维线性代数场景。

## 主要内容

### 1. matrix3d 模板类

```cpp
template<
    typename Val,
    template<typename _Val, std::size_t> class Array = ::yggr::array,
    template<typename _Val, std::size_t, std::size_t, template<typename __Val, std::size_t> class _Base> class Base = determinant
>
class matrix3d : public Base<typename upper_signed<Val>::type, 4, 4, Array>
{
    // ...
};
```

- **Val**：元素类型（如 float、double、int 等）
- **Array**：底层一维数组类型模板，默认为 `yggr::array`
- **Base**：基类模板，默认为 `determinant`，支持行列式等扩展

#### 主要成员
- 静态常量：行数、列数、最大秩均为 4
- 类型定义：元素类型、行类型、基类类型
- 构造函数：支持默认、元素列表、数组、标量、拷贝等多种方式
- 赋值、比较、交换、矩阵运算等（详见源码）

### 2. 依赖与扩展

- 支持 Boost 移动语义、类型萃取、哈希等
- 支持序列化（包含相关头文件）
- 依赖 determinant.hpp、geo_plane.hpp 等
- 适配泛型算法和高性能数值计算

### 3. 典型用途

- 三维仿射变换、图形学、物理仿真等
- 任意类型、任意底层实现的 4x4 矩阵运算
- 泛型编程和模板元编程场景

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: matrix3d.hpp 文档

---

# matrix3d.hpp

## 简介

该头文件为 4x4 三维矩阵与三维向量的乘法运算提供了泛型重载，支持不同类型、不同底层实现的矩阵与向量混合运算。适用于三维图形学、仿射变换、工程计算等三维线性代数场景。

## 主要内容

### 1. 主要包含内容

- 包含 `vector3d_t.hpp` 和 matrix3d_t.hpp，提供三维向量和三维矩阵的基础定义。

### 2. 运算符重载

#### 向量 × 矩阵

```cpp
template<typename ValL, typename ValR, ...>
vector3d<...> operator*(const vector3d<ValL, BaseL>& l, const matrix3d<ValR, Array, BaseR>& r);
```
- **功能**：实现列向量与 4x4 矩阵的乘法，返回新向量。

#### 矩阵 × 向量

```cpp
template<typename ValL, typename ValR, ...>
vector3d<...> operator*(const matrix3d<ValL, Array, BaseL>& l, const vector3d<ValR, BaseR>& r);
```
- **功能**：实现 4x4 矩阵与列向量的乘法，返回新向量。

#### 向量 *= 矩阵

```cpp
template<typename ValL, typename ValR, ...>
vector3d<ValL, BaseL>& operator*=(vector3d<ValL, BaseL>& l, const matrix3d<ValR, Array, BaseR>& r);
```
- **功能**：实现向量自乘矩阵，结果赋值回自身。

### 3. 依赖关系

- 依赖 vector3d_t.hpp、matrix3d_t.hpp。
- 支持泛型类型和底层实现的灵活组合。

## 典型用途

- 三维仿射变换、图形学、物理仿真等
- 任意类型、任意底层实现的 4x4 矩阵与三维向量运算

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: modulus.hpp 文档

---

# modulus.hpp

## 简介

该头文件实现了整数和浮点数的统一取模（模运算）工具，支持泛型类型和自动类型推导。适用于数值计算、循环结构、信号处理等需要模运算的场景。

## 主要内容

### 1. modulus_handler 模板结构体

- **功能**：根据类型是否为浮点数，自动选择合适的模运算实现。
- **实现**：
  - 对于整数类型，使用 `%` 运算符。
  - 对于浮点类型，使用 `std::fmod`。

### 2. modulus / modulus_set 函数模板

```cpp
template<typename L, typename R>
auto modulus(const L& l, const R& r) -> ...;

template<typename L, typename R>
L& modulus_set(L& l, const R& r);
```

- **功能**：
  - `modulus`：返回 $l$ 对 $r$ 的模结果，自动适配类型。
  - `modulus_set`：将 $l$ 取模后赋值回自身，返回引用。
- **类型推导**：通过 `modulus_operator_result` 自动推导返回类型。

### 3. 依赖关系

- 依赖 operator_result.hpp、Boost 类型萃取、`<cmath>`。

## 典型用途

- 适用于整数和浮点数的统一模运算需求。
- 泛型算法、模板元编程中的数值取模。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: moving_avg_accumulator.hpp 文档

---

# moving_avg_accumulator.hpp

## 简介

该头文件实现了多种滑动平均（Moving Average）累加器的元编程工厂和类型检查工具，支持简单、加权、指数等多种滑动平均算法的组合与泛型扩展。适用于信号处理、金融分析、数据平滑等需要滑动平均的场景。

## 主要内容

### 1. make_accumulator 模板结构体

```cpp
template<typename Val, typename Collector, typename Cdt_Genner, typename Result_Getter, typename Calculator>
struct make_accumulator
{
    // ...
    typedef yggr::tuple<Val, Collector, Cdt_Genner, Result_Getter, Calculator> type;
};
```
- **功能**：将滑动平均相关类型（值类型、收集器、条件生成器、结果获取器、计算器）组合为元组，便于统一管理和泛型扩展。
- **类型约束**：要求 `Val` 必须为浮点型或有符号整型。

### 2. make_accumlator_group 模板结构体

- **功能**：批量生成滑动平均累加器类型组（元组），支持多种滑动平均算法的组合。

### 3. maa_check_group 元编程类型检查

- **功能**：递归检查累加器组中各类型是否匹配，保证滑动平均算法组合的类型安全。
- **实现**：利用 Boost MPL 和元组工具，递归判断各类型之间的兼容性。

### 4. 依赖与扩展

- 支持多种滑动平均算法（SMA、CMA、MMA、EMA、WMA），通过包含相关头文件实现。
- 依赖 tuple.hpp、`yggr/math/moving_avg/*`、Boost MPL、类型萃取等。

## 典型用途

- 金融行情、传感器数据、实时信号等滑动平均处理。
- 泛型算法、模板元编程场景下的滑动平均算法组合与类型安全校验。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: odd_even_number.hpp 文档

---

# odd_even_number.hpp

## 简介

该头文件实现了奇偶性判断的泛型工具，支持运行时和编译时判断任意类型（主要为整数类型）的奇数和偶数。适用于算法开发、模板元编程、数值分析等需要奇偶性判断的场景。

## 主要内容

### 1. odd_checker / even_checker 模板结构体

- **功能**：运行时判断一个数是否为奇数或偶数。
- **实现**：
  - 对于整数类型，直接通过按位与 `1` 判断。
  - 对于非整数类型，先转换为整数再判断。
- **用法**：
  ```cpp
  odd_checker<int> odd_chk(5);
  bool is_odd = odd_chk; // true
  even_checker<int> even_chk(6);
  bool is_even = even_chk; // true
  ```

### 2. odd_t_checker / even_t_checker 编译时判断

- **功能**：在编译期判断常量是否为奇数或偶数，适用于模板元编程。
- **实现**：继承自 `boost::mpl::bool_`，可用于静态断言和类型选择。

### 3. is_odd_number / is_even_number 函数模板

- **功能**：运行时判断任意类型变量的奇偶性，返回 `bool` 或自定义类型。
- **用法**：
  ```cpp
  bool b1 = is_odd_number(7); // true
  bool b2 = is_even_number(8); // true
  ```

### 4. is_odd_number_t / is_even_number_t 编译时类型

- **功能**：编译期常量判断，适合模板元编程。

### 5. 依赖关系

- 依赖 Boost MPL、类型萃取等。

## 典型用途

- 算法开发、模板元编程、数值分析等需要奇偶性判断的场景。
- 支持运行时和编译时两种方式，便于泛型和高性能开发。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: odds.hpp 文档

---

# odds.hpp

## 简介

该头文件实现了赔率（Odds）、胜率（Winning）、失败率（Failure Rate）等概率相关的转换工具，支持浮点型和整型赔率的互转、概率计算等。适用于博彩、金融、风险评估等概率与赔率相关的场景。

## 主要内容

### 1. 赔率与浮动赔率互转

- `odds_to_floating_odds`：赔率转浮动赔率（如欧赔，$odds+1$）。
- `floating_odds_to_odds`：浮动赔率转赔率（$odds-1$）。

### 2. 赔率与胜率/失败率互转

- `odds_to_winning`：赔率转胜率，支持浮点和整型赔率。
- `odds_to_failure_rate`：赔率转失败率。
- `winning_to_odds` / `winning_to_floating_odds`：胜率转赔率/浮动赔率。
- `failure_rate_to_odds` / `failure_rate_to_floating_odds`：失败率转赔率/浮动赔率。

### 3. 其它概率工具

- `single_lose_odds`：单次失败赔率。
- `limit_continuous_lose_count`：给定游戏次数和赔率，计算极限连续失败次数。

### 4. 依赖关系

- 依赖 Boost 类型萃取、断言、cmath 等。

## 典型用途

- 博彩、金融、风险评估等概率与赔率相关的计算。
- 支持浮点和整型赔率，适合多种业务场景。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: operator_cross.hpp 文档

---

# operator_cross.hpp

## 简介

该头文件实现了通用的“交叉操作符”适配器（crosser），用于泛型编程中对向量、矩阵等类型的交叉（如叉积、外积）操作进行类型安全的包装和适配。适用于线性代数、几何计算等需要交叉运算的场景。

## 主要内容

### 1. crosser 模板结构体

```cpp
template<typename T>
struct crosser
{
    typedef T value_type;
    // ...
    crosser(const value_type& val);
    ~crosser();
    operator chk_type() const;
    const value_type& get() const;
};
```

- **功能**：包装一个值，便于后续进行交叉操作（如向量叉积）。
- **类型安全**：通过 `operator_result_t_getter` 获取交叉操作的返回类型，保证类型安全。
- **接口**：
  - 构造/析构
  - 类型转换操作符
  - `get()`：获取原始值引用

### 2. cross 工具函数

```cpp
template<typename T>
crosser<T> cross(const T& val);
```
- **功能**：便捷生成 `crosser` 对象，适用于泛型交叉操作。

### 3. 依赖关系

- 依赖 operator_result.hpp、Boost `reference_wrapper`。

## 典型用途

- 泛型向量、矩阵等类型的交叉（叉积）操作适配。
- 保证类型安全的线性代数、几何计算。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: operator_dot.hpp 文档

---

# operator_dot.hpp

## 简介

该头文件实现了通用的“点积操作符”适配器（doter），用于泛型编程中对向量、矩阵等类型的点积（内积）操作进行类型安全的包装和适配。适用于线性代数、几何计算等需要点积运算的场景。

## 主要内容

### 1. doter 模板结构体

```cpp
template<typename T>
struct doter
{
    typedef T value_type;
    // ...
    doter(const value_type& val);
    ~doter();
    operator chk_type() const;
    const value_type& get() const;
};
```

- **功能**：包装一个值，便于后续进行点积操作（如向量内积）。
- **类型安全**：通过 `operator_result_t_getter` 获取点积操作的返回类型，保证类型安全。
- **接口**：
  - 构造/析构
  - 类型转换操作符
  - `get()`：获取原始值引用

### 2. dot 工具函数

```cpp
template<typename T>
doter<T> dot(const T& val);
```
- **功能**：便捷生成 `doter` 对象，适用于泛型点积操作。

### 3. 依赖关系

- 依赖 operator_result.hpp、Boost `reference_wrapper`。

## 典型用途

- 泛型向量、矩阵等类型的点积（内积）操作适配。
- 保证类型安全的线性代数、几何计算。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: pascals_triangle.hpp 文档

---

# pascals_triangle.hpp

## 简介

该头文件实现了杨辉三角（Pascal's Triangle）相关的组合数计算工具，支持运行时和编译时两种方式。适用于组合数学、概率统计、算法竞赛等需要组合数 $C(n, m)$ 运算的场景。

## 主要内容

### 1. pascals_triangle_detail 结构体

- **功能**：递归实现杨辉三角的组合数计算。
- **实现**：采用递归公式 $C(n, m) = C(n-1, m-1) + C(n-1, m)$，边界 $C(n, 0) = C(n, n) = 1$。

### 2. pascals_triangle 函数模板

```cpp
template<typename T>
T pascals_triangle(const T& n, const T& m);
```
- **功能**：运行时计算组合数 $C(n, m)$，支持类类型和基础类型。

### 3. pascals_triangle_t 模板结构体（编译时）

```cpp
template<std::size_t N, std::size_t M>
struct pascals_triangle_t : public boost::mpl::size_t<...> {};
```
- **功能**：编译期递归计算组合数 $C(N, M)$，适用于模板元编程。
- **实现**：递归继承 `boost::mpl::size_t`，边界 $C(N, 0) = C(N, N) = 1$。

### 4. 依赖关系

- 依赖 native_t.hpp、foo_input_arg_t.hpp、Boost MPL 等。

## 典型用途

- 组合数、排列数、概率统计等数学运算。
- 支持运行时和编译时两种方式，便于泛型和模板元编程。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: range_value.hpp 文档

---

# range_value.hpp

## 简介

该头文件实现了通用的区间裁剪（clamp）工具函数，可将任意值限制在指定区间范围内。适用于数值归一化、参数安全检查、信号处理等需要区间约束的场景。

## 主要内容

### 1. range_value 函数模板

```cpp
template<typename T>
T range_value(const T& val, const T& min, const T& max);

template<typename T, template<typename _T1, typename _T2> class Pair>
T range_value(const T& val, const Pair<T, T>& range);
```

- **功能**：将输入值 `val` 限制在 `[min, max]` 或 `range.first ~ range.second` 区间内。
- **实现**：若 `val < min` 返回 `min`，若 `val > max` 返回 `max`，否则返回 `val` 本身。
- **重载**：支持直接传入区间上下界或区间对（如 `std::pair`）。

### 2. 依赖关系

- 依赖 `<utility>`，支持 `std::pair` 等泛型区间类型。

## 典型用途

- 数值归一化、参数安全检查、信号处理、图形学等需要区间裁剪的场景。
- 泛型编程，适用于任意可比较类型。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: sign.hpp 文档

---

# sign.hpp

## 简介

该头文件实现了通用的符号函数（sign），用于判断任意数值类型的正负号。支持有符号和无符号类型，自动适配。适用于数值分析、信号处理、泛型算法等需要符号判断的场景。

## 主要内容

### 1. sign_result 模板结构体

- **功能**：根据类型是否有符号，返回 $-1$、$0$、$1$ 或 $0$、$1$。
- **实现**：
  - 有符号类型：小于 0 返回 $-1$，等于 0 返回 $0$，大于 0 返回 $1$。
  - 无符号类型：等于 0 返回 $0$，否则返回 $1$。

### 2. sign 函数模板

```cpp
template<typename T>
typename upper_signed<T>::type sign(const T& x);
```

- **功能**：返回输入值的符号（$-1$、$0$、$1$）。
- **实现**：内部使用 flaw_comparer 进行安全比较，适配各种类型。

### 3. 依赖关系

- 依赖 upper_types.hpp、flaw_comparer.hpp 等。

## 典型用途

- 数值分析、信号处理、泛型算法等需要符号判断的场景。
- 支持有符号和无符号类型，适合泛型编程。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: sqrt.hpp 文档

---

# sqrt.hpp

## 简介

该头文件实现了多种类型的平方根（sqrt）和倒平方根（rsqrt）计算，支持快速近似算法和标准库精确算法，适用于浮点数、复数及泛型类型。适用于图形学、物理仿真、数值分析等对性能和精度有不同需求的场景。

## 主要内容

### 1. 快速平方根与倒平方根

- `fast_sqrt` / `fast_rsqrt`：采用著名的快速平方根算法（Quake III Fast Inverse Square Root），支持 `f32` 和 `f64`，可选多次迭代提升精度。
- 通过宏 `YGGR_USE_FAST_MATH` 控制是否默认使用快速算法。

### 2. 标准平方根与倒平方根

- 若未定义 `YGGR_USE_FAST_MATH`，则默认使用 `std::sqrt` 及其倒数。

### 3. 泛型与复数支持

- 支持 `std::complex<T>` 类型的平方根和倒平方根。
- 支持任意类型，自动提升为更高精度的浮点类型后计算。

### 4. 依赖关系

- 依赖 `<cmath>`、`<complex>`、`yggr/type_traits/upper_types.hpp>` 等。

## 典型用途

- 图形学、物理仿真、信号处理等对性能和精度有不同需求的场景。
- 支持快速近似和高精度计算，适合泛型编程。

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: vector2d_t.hpp 文档

---

# vector2d_t.hpp

## 简介

该头文件实现了通用二维向量（vector2d）模板类，支持任意数值类型和底层数组定制。提供向量的构造、赋值、基本运算、几何变换、序列化等功能，适用于图形学、物理仿真、工程计算等二维线性代数场景。

## 主要内容

### 1. vector2d 模板类

```cpp
template<
    typename Val,
    template <typename _Val, std::size_t> class Base = yggr::array
>
class vector2d : public Base<typename upper_signed<Val>::type, 3>
{
    // ...
};
```

- **Val**：元素类型（如 float、double、int 等）
- **Base**：底层一维数组类型模板，默认为 `yggr::array`

#### 主要成员
- 静态常量：维度为 2，底层数组长度为 3（齐次坐标支持）
- 类型定义：元素类型、底层数组类型
- 构造函数：支持默认、元素列表、数组、拷贝等多种方式
- 赋值、比较、交换、向量运算（加减乘除、点积、叉积、归一化、模长等）
- 成员变量：`x`、`y`、`w`（齐次坐标）

### 2. 依赖与扩展

- 支持 Boost 移动语义、类型萃取、哈希等
- 支持序列化（包含相关头文件）
- 依赖 sqrt.hpp、sign.hpp、modulus.hpp、flaw_comparer.hpp 等
- 适配泛型算法和高性能数值计算

### 3. 典型用途

- 二维仿射变换、图形学、物理仿真等
- 任意类型、任意底层实现的二维向量运算
- 泛型编程和模板元编程场景

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！

alucard-dracula: 为这个文件生成文档

GitHub Copilot: vector2d.hpp 文档

---

# vector2d.hpp

## 简介

该头文件为二维向量（vector2d）提供了点积（dot）和叉积（cross）操作的泛型重载，支持不同类型、不同底层实现的向量混合运算。适用于图形学、物理仿真、工程计算等二维线性代数场景。

## 主要内容

### 1. 主要包含内容

- 包含 vector2d_t.hpp（向量定义）、operator_dot.hpp（点积适配器）、operator_cross.hpp（叉积适配器）。

### 2. 运算符重载

#### 点积（dot product）

- 支持以下形式的点积运算：
  - `vector2d * doter<vector2d>`
  - `doter<vector2d> * vector2d`
  - `doter<vector2d> * doter<vector2d>`
- 实现方式：调用向量的 `dot` 成员函数。

#### 叉积（cross product）

- 支持以下形式的叉积运算：
  - `vector2d * crosser<vector2d>`
  - `crosser<vector2d> * vector2d`
  - `crosser<vector2d> * crosser<vector2d>`
- 实现方式：调用向量的 `cross` 成员函数。

### 3. 依赖关系

- 依赖 vector2d_t.hpp、operator_dot.hpp、operator_cross.hpp。
- 支持泛型类型和底层实现的灵活组合。

## 典型用途

- 二维仿射变换、图形学、物理仿真等
- 任意类型、任意底层实现的二维向量点积与叉积运算

---

如需生成 Doxygen 风格注释或更详细的函数/类注释，请告知！