alucard-dracula: 为这个文件生成文档

GitHub Copilot: 该文件 `align_vector.hpp` 主要用于在特定 MSVC 版本下（MSVC2010 及更早版本）为 `std::vector` 提供对齐包装支持，解决老版本 STL 在某些类型对齐上的兼容性问题。以下是详细文档说明：

---

# align_vector.hpp 文档

## 概述

`align_vector.hpp` 是 yggdrasil 项目中的一个头文件，主要用于在 MSVC 2010 及更早版本下，为 `std::vector` 提供类型对齐包装。其核心思想是通过 `align_wrapper` 模板结构体对类型进行包裹，并为 `std::vector<align_wrapper<T>>` 提供特化实现，从而解决老版本 MSVC STL 在类型对齐和移动语义上的兼容性问题。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

### 1. 头文件保护

使用宏 `__YGGR_CONTAINER_ALIGN_VECTOR_HPP__` 防止头文件重复包含。

### 2. 依赖

- `<vector>`：标准容器 vector
- `<yggr/base/yggrdef.h>`：yggdrasil 基础定义
- `<yggr/move/move.hpp>`、`<yggr/mplex/static_assert.hpp>`、`<yggr/container/basic_function_adapter.hpp>`：yggdrasil 内部工具
- `<boost/type_traits/is_same.hpp>`：类型判断
- 仅在 MSVC 2010 及更早版本下启用特殊实现

### 3. align_wrapper 模板

```cpp
template<typename T, typename Nil = void>
struct align_wrapper
{
public:
    typedef T value_type;
};
```
- 用于对类型 T 进行包裹，便于后续 vector 特化。

### 4. 宏定义

- `YGGR_ALIGN_WRAPPER(__x__)`：对类型进行 align_wrapper 包裹
- `YGGR_ALIGN_VECTOR(__x__, __alloc__)`：生成带对齐包装的 vector 类型

### 5. std::vector 特化

对 `std::vector<align_wrapper<T>, Alloc>` 进行特化，重载了构造、赋值、插入、删除、移动等操作，保证在老版本 MSVC 下的兼容性和正确性。

- 支持拷贝、移动构造与赋值
- 支持 push_back、emplace_back、insert、erase、swap、resize、reserve 等常用操作
- 内部实现了内存分配、元素构造、移动、销毁等底层细节
- 兼容 C++11 部分特性（如 data、shrink_to_fit 等）

### 6. 兼容性处理

- 仅在 `defined(_MSC_VER) && !(_MSC_VER >1600)` 条件下启用特化
- 其他编译器或新版本 MSVC 下，宏直接退化为普通 vector

### 7. 结尾

- 头文件保护宏结束

---

## 适用场景

- 主要用于 MSVC 2010 及更早版本，解决 STL vector 在类型对齐、移动语义等方面的兼容性问题。
- 新版本编译器或其他平台无需特殊处理，直接使用标准 vector。

## 使用示例

```cpp
// 定义一个对齐 vector
YGGR_ALIGN_VECTOR(MyType, std::allocator<MyType>) my_vec;
```

---

如需进一步了解具体实现细节，可查阅源码注释及相关 yggdrasil 工具头文件。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `array.hpp` 的详细文档说明：

---

# array.hpp 文档

## 概述

`array.hpp` 是 yggdrasil 项目中的一个容器适配头文件，主要用于在不同编译环境下统一 `array` 类型的选择（支持 `std::array` 和 `boost::array`），并为其分配器、类型判断和原生数组引用转换等功能提供支持。该文件通过宏和类型萃取机制，屏蔽了底层实现差异，方便跨平台和不同标准库环境下的开发。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

### 1. 头文件保护

使用宏 `__YGGR_CONTAINER_ARRAY_HPP__` 防止头文件重复包含。

### 2. 依赖

- yggdrasil 基础设施头文件（如 `yggrdef.h`、`container_selector.hpp`、`move.hpp` 等）
- boost 库（如 `boost/array.hpp`、`boost/ref.hpp`、`boost/mpl/bool.hpp`）
- C++11 `<array>`（如可用）
- 相关类型萃取和适配器头文件

### 3. array 类型适配

根据编译选项和环境，自动选择使用 `boost::array` 或 `std::array` 作为 `yggr::container::array` 的实现：

- `YGGR_USE_BOOST_CONTAINER`：使用 `boost::array`
- `YGGR_USE_STL_CONTAINER` 且支持 C++11 `<array>`：使用 `std::array`
- 其他情况报错

并将 `yggr::container::array` 提升为 `yggr::array`，便于全局统一使用。

### 4. allocator_t 特化

为 `std::array` 和 `boost::array` 提供分配器类型特化，统一分配器接口，便于泛型编程。

### 5. 类型萃取

- `is_std_array`：判断类型是否为 `std::array`
- `is_boost_array`：判断类型是否为 `boost::array`

### 6. 原生数组引用转换

提供 `cast_to_native_array_reference` 系列模板函数，将 `std::array` 或 `boost::array` 转换为原生 C 数组的引用或指针，便于与底层 C 接口或需要原生数组的场景兼容。

- 支持非常量和常量版本
- 支持泛型模板（可扩展到其他类似 array 容器）

### 7. 兼容性说明

- boost::array 与 std::array 在接口和内存布局上保持一致，便于无缝切换
- array 不需要额外的兼容性调用器

---

## 适用场景

- 需要跨平台、跨标准库环境下统一 array 容器类型
- 需要泛型支持、类型萃取、分配器适配等高级用法
- 需要与底层 C 接口或原生数组高效交互

## 使用示例

```cpp
#include <yggr/container/array.hpp>

yggr::array<int, 10> arr; // 自动选择 std::array 或 boost::array

auto& native_arr = yggr::container::cast_to_native_array_reference(arr); // 转为原生数组引用
```

---

如需进一步了解具体实现细节，可查阅源码注释及相关 yggdrasil 工具头文件。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `basic_function_adapter.hpp` 的文档说明：

---

# basic_function_adapter.hpp 文档

## 概述

`basic_function_adapter.hpp` 是 yggdrasil 项目中的一个基础适配器头文件，主要用于统一容器的遍历接口。该文件通过包含 begin/end/rbegin/rend 等适配器头文件，为容器提供标准化的遍历入口，便于泛型算法和容器操作的统一调用。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含 yggdrasil 基础定义头文件。
- 包含 `begin.hpp`、`end.hpp`、`rbegin.hpp`、`rend.hpp`，为容器提供统一的正向和反向遍历接口适配。
- 本文件本身不直接实现函数，仅作为适配器头文件的聚合入口。

## 适用场景

- 需要对不同容器类型统一调用 `begin`、`end`、`rbegin`、`rend` 等遍历接口时。
- 作为 yggdrasil 容器库的基础适配层，便于后续扩展和维护。

## 使用示例

```cpp
#include <yggr/container/basic_function_adapter.hpp>

// 可直接使用 yggr::container::begin/ end/ rbegin/ rend 适配器
```

---

如需具体遍历适配实现，请查阅对应的 `begin.hpp`、`end.hpp`、`rbegin.hpp`、`rend.hpp` 文件。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `begin.hpp` 的文档说明：

---

# begin.hpp 文档

## 概述

`begin.hpp` 是 yggdrasil 项目中用于统一容器遍历起始迭代器获取的适配头文件。该文件通过引入 boost 的 `begin`，并提供 `cbegin`（常量容器起始迭代器）适配器，方便在泛型编程中统一获取各种容器的起始迭代器，兼容标准库和 boost 容器。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含 range_iterator_ex.hpp 和 `boost/range/begin.hpp`，用于增强迭代器类型推导和兼容性。
- `using boost::begin;`：直接引入 boost 的 `begin`，支持标准和 boost 容器。
- `cbegin` 模板函数：返回常量容器的起始迭代器，类型安全且兼容 boost/标准容器。
- 将 `container::begin` 和 `container::cbegin` 提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要统一获取各种容器（包括标准容器和 boost 容器）起始迭代器的场景。
- 泛型算法、模板编程中对 begin/cbegin 的统一适配需求。

## 使用示例

```cpp
#include <yggr/container/begin.hpp>

std::vector<int> v = {1, 2, 3};
auto it = yggr::begin(v);      // 获取起始迭代器
auto cit = yggr::cbegin(v);    // 获取常量起始迭代器
```

---

如需进一步了解迭代器适配细节，可查阅 range_iterator_ex.hpp 及 boost 文档。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `clear.hpp` 的文档说明：

---

# clear.hpp 文档

## 概述

`clear.hpp` 是 yggdrasil 项目中用于统一容器清空操作的适配头文件。该文件通过泛型 `clear` 函数，结合内部 `clear_helper` 机制，为各种容器类型（包括标准容器、自定义容器等）提供统一的清空接口，简化容器操作并提升代码可移植性和泛型编程能力。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含 clear_helper.hpp，用于实现具体的清空策略。
- 在 `yggr::container` 命名空间下定义泛型 `clear` 函数模板，自动选择合适的清空方式。
- 将 `container::clear` 提升到 yggr 命名空间，便于全局统一调用。

## 主要接口

```cpp
template<typename C>
void clear(C& c);
```
- 自动根据容器类型选择合适的清空实现（如调用 `c.clear()` 或其他自定义清空逻辑）。

## 适用场景

- 需要对不同类型容器（标准容器、boost容器、自定义容器等）统一进行清空操作时。
- 泛型算法、模板编程中对 clear 操作的统一适配需求。

## 使用示例

```cpp
#include <yggr/container/clear.hpp>

std::vector<int> v = {1, 2, 3};
yggr::clear(v); // 清空 vector

MyCustomContainer c;
yggr::clear(c); // 清空自定义容器（需有 clear_helper 支持）
```

---

如需扩展支持自定义容器，请实现对应的 `clear_helper` 特化。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `container_selector.hpp` 的文档说明：

---

# container_selector.hpp 文档

## 概述

`container_selector.hpp` 是 yggdrasil 项目中用于选择容器实现方案的配置头文件。该文件通过宏定义机制，自动选择使用标准库（STL）容器还是 Boost 容器，便于在不同编译环境下灵活切换容器实现，提升代码的可移植性和兼容性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含基础定义头文件 `<yggr/base/yggrdef.h>`。
- 检查是否已定义 `YGGR_USE_STL_CONTAINER` 或 `YGGR_USE_BOOST_CONTAINER` 宏。
- 如果两者都未定义，则默认定义 `YGGR_USE_BOOST_CONTAINER`，即优先使用 Boost 容器。

## 适用场景

- 需要在不同平台或项目配置下灵活切换容器实现（如 STL 或 Boost）。
- 作为 yggdrasil 容器库的基础配置文件，供其他容器适配头文件引用。

## 使用说明

- 在包含本头文件后，后续容器相关代码可通过 `YGGR_USE_STL_CONTAINER` 或 `YGGR_USE_BOOST_CONTAINER` 宏判断使用哪种容器实现。
- 用户可在项目编译选项或其他配置头文件中手动定义相关宏，以覆盖默认选择。

---

本文件为 yggdrasil 容器适配体系的基础配置组件，无需直接调用，仅需在项目中包含即可自动生效。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `data_range.hpp` 的文档说明：

---

# data_range.hpp 文档

## 概述

`data_range.hpp` 提供了一个线程安全的数据区间管理类 `data_range`，用于维护一个可递增/递减的区间值，常用于分布式、并发或资源池等场景下的区间分配与回收。该类支持原子操作，能安全地在多线程环境下进行区间游标的前进与后退，并在越界时抛出自定义错误。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

### 1. 头文件保护

防止重复包含。

### 2. 依赖

- `<yggr/base/error_make.hpp>`：自定义错误生成器
- `<boost/atomic.hpp>`：原子操作支持
- `<cassert>`：断言检查

### 3. data_range 类模板

#### 模板参数

- `T`：区间值类型，需支持比较、加减等操作。

#### 主要成员

- `value_type`：区间值类型别名
- `data_range(const value_type& start, const value_type& last)`：构造函数，指定区间起止
- `data_range(const value_type& start, const value_type& last, const value_type& now)`：指定当前值
- `is_in(const value_type& val)`：判断值是否在区间内（左闭右开）
- `is_not_in(const value_type& val)`：判断值是否不在区间内
- `left_limit()` / `right_limit()`：获取区间左右端点
- `now()`：获取当前值
- `reset()`：重置当前值为区间起点
- `next()`：原子递增当前值，返回递增前的值，超出右界抛出异常
- `before()`：原子递减当前值，返回递减前的值，超出左界抛出异常

#### 错误处理

- 内部定义了 `E_left_limited` 和 `E_right_limited` 两种错误码，分别表示越过左/右边界。

#### 线程安全

- 通过 `boost::atomic` 保证 `_now_val` 的原子性，支持多线程安全操作。

## 适用场景

- 并发环境下的区间分配、资源池管理、ID 生成等需要线程安全区间游标的场景。

## 使用示例

```cpp
yggr::container::data_range<int> dr(0, 100);
int v1 = dr.next();   // 获取下一个值
int v2 = dr.before(); // 获取上一个值
dr.reset();           // 重置为起点
```

---

如需扩展支持其他类型，请确保类型 T 支持必要的算术和比较操作。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `default_allocator.hpp` 的文档说明：

---

# default_allocator.hpp 文档

## 概述

`default_allocator.hpp` 是 yggdrasil 项目中用于统一容器默认分配器选择的配置头文件。该文件通过宏定义机制，根据编译环境和 Boost 版本，自动选择合适的分配器类型（如 `std::allocator` 或 `boost::container::new_allocator`），为容器适配提供一致的分配器接口。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含基础定义头文件 `<yggr/base/yggrdef.h>` 和容器选择头文件 `<yggr/container/container_selector.hpp>`。
- 根据 Boost 版本，包含 `<boost/container/new_allocator.hpp>`。
- 包含 `<memory>`，以支持 `std::allocator`。
- 通过宏 `YGGR_CONTAINER_DEFAULT_ALLOCATOR()`，根据以下规则选择默认分配器类型：
  - 如果使用 Boost 容器且 Boost 版本 >= 1.58.0，则使用 `boost::container::new_allocator`
  - 如果使用 Boost 容器但 Boost 版本 < 1.58.0，则使用 `std::allocator`
  - 如果使用标准库容器，则始终使用 `std::allocator`
  - 未知情况则报错

## 适用场景

- 需要在不同平台、不同 Boost 版本下统一容器分配器类型的场景。
- 作为 yggdrasil 容器库的基础分配器配置文件，供容器适配头文件和泛型容器代码引用。

## 使用说明

- 通过 `YGGR_CONTAINER_DEFAULT_ALLOCATOR()` 宏获取当前环境下的默认分配器类型。例如：
  ```cpp
  YGGR_CONTAINER_DEFAULT_ALLOCATOR()(int) alloc;
  ```
- 用户无需关心底层分配器实现，统一通过该宏适配即可。

---

本文件为 yggdrasil 容器适配体系的基础分配器配置组件，无需直接调用，仅需在项目中包含并使用宏即可自动生效。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `deque.hpp` 的文档说明：

---

# deque.hpp 文档

## 概述

`deque.hpp` 是 yggdrasil 项目中用于双端队列（deque）容器适配的头文件。该文件根据项目配置，自动选择使用标准库（`std::deque`）或 Boost（`boost::deque`）实现，并对分配器等相关类型进行统一适配，方便在不同平台和库环境下无缝切换和泛型编程。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含 yggdrasil 基础定义和容器选择相关头文件。
- 根据宏定义（如 `YGGR_USE_BOOST_CONTAINER` 或 `YGGR_USE_STL_CONTAINER`），自动选择 `std::deque` 或 `boost::deque` 作为 `yggr::container::deque` 的实现。
- 适配分配器类型，保证容器在不同实现下的分配器一致性。
- 可能包含类型萃取、辅助工具或兼容性适配代码，便于泛型算法和容器操作。

## 适用场景

- 需要跨平台、跨标准库环境下统一双端队列容器类型的场景。
- 需要在项目中灵活切换标准库或 Boost 实现的 deque。
- 泛型编程、模板库开发等对容器类型有适配需求的场景。

## 使用示例

```cpp
#include <yggr/container/deque.hpp>

yggr::container::deque<int> dq;
dq.push_back(1);
dq.push_front(2);
```

---

如需进一步了解具体实现细节，可查阅源码及相关 yggdrasil 容器适配头文件。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `empty.hpp` 的文档说明：

---

# empty.hpp 文档

## 概述

`empty.hpp` 是 yggdrasil 项目中用于统一容器判空操作的适配头文件。该文件通过引入 boost 的 `empty` 函数，为各种容器类型（包括标准容器、boost 容器、自定义容器等）提供统一的判空接口，便于泛型编程和容器操作的统一调用。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含基础定义头文件 `<yggr/base/yggrdef.h>`。
- 引入 `<boost/range/empty.hpp>`，使用 boost 的 `empty` 实现。
- 在 `yggr::container` 命名空间下直接使用 `boost::empty`。
- 将 `container::empty` 提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要对不同类型容器统一进行判空操作时。
- 泛型算法、模板编程中对 empty 操作的统一适配需求。

## 使用示例

```cpp
#include <yggr/container/empty.hpp>

std::vector<int> v;
if (yggr::empty(v)) {
    // 容器为空
}
```

---

本文件为 yggdrasil 容器适配体系的基础判空适配组件，无需直接实现判空逻辑，仅需包含并调用 `yggr::empty` 即可自动适配各种容器类型。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `end.hpp` 的文档说明：

---

# end.hpp 文档

## 概述

`end.hpp` 是 yggdrasil 项目中用于统一容器末尾迭代器获取的适配头文件。该文件通过引入 boost 的 `end`，并提供 `cend`（常量容器末尾迭代器）适配器，方便在泛型编程中统一获取各种容器的末尾迭代器，兼容标准库和 boost 容器。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含 range_iterator_ex.hpp 和 `boost/range/end.hpp`，用于增强迭代器类型推导和兼容性。
- `using boost::end;`：直接引入 boost 的 `end`，支持标准和 boost 容器。
- `cend` 模板函数：返回常量容器的末尾迭代器，类型安全且兼容 boost/标准容器。
- 将 `container::end` 和 `container::cend` 提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要统一获取各种容器（包括标准容器和 boost 容器）末尾迭代器的场景。
- 泛型算法、模板编程中对 end/cend 的统一适配需求。

## 使用示例

```cpp
#include <yggr/container/end.hpp>

std::vector<int> v = {1, 2, 3};
auto it = yggr::end(v);      // 获取末尾迭代器
auto cit = yggr::cend(v);    // 获取常量末尾迭代器
```

---

如需进一步了解迭代器适配细节，可查阅 range_iterator_ex.hpp 及 boost 文档。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `get_allocator.hpp` 的文档说明：

---

# get_allocator.hpp 文档

## 概述

`get_allocator.hpp` 是 yggdrasil 项目中用于统一获取容器分配器的适配头文件。该文件通过类型萃取和 SFINAE 技术，自动判断容器类型是否有分配器及 `get_allocator` 方法，并提供统一的 `get_allocator` 和 `create_empty_object_of_allocator` 泛型接口，便于泛型编程和容器适配。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含分配器类型萃取、分配器检测、SFINAE 相关头文件。
- 通过 `boost::enable_if`、`boost::disable_if`、`boost::mpl` 等工具，自动判断容器类型特性。
- 提供 `get_allocator(const T&)` 泛型函数，根据容器类型特性自动选择：
  - 有分配器类型且有 `get_allocator` 方法：直接调用
  - 有分配器类型但无 `get_allocator` 方法：返回默认分配器对象
  - 无分配器类型：返回默认分配器对象
- 提供 `create_empty_object_of_allocator(const T&)` 泛型函数，根据分配器类型是否为 `null_type`，自动选择构造方式：
  - 分配器为 `null_type`：直接默认构造
  - 否则：用分配器构造

- 将 `get_allocator` 和 `create_empty_object_of_allocator` 提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要对不同容器类型统一获取分配器的场景。
- 泛型算法、模板库开发中对分配器适配的需求。
- 需要根据分配器类型自动选择对象构造方式的场景。

## 使用示例

```cpp
#include <yggr/container/get_allocator.hpp>

std::vector<int> v;
auto alloc = yggr::get_allocator(v);

auto empty_obj = yggr::create_empty_object_of_allocator(v);
```

---

如需扩展支持自定义容器，请确保实现了分配器类型萃取和 `get_allocator` 检测。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `get_deque_options.hpp` 的文档说明：

---

# get_deque_options.hpp 文档

## 概述

`get_deque_options.hpp` 是 yggdrasil 项目中用于适配 Boost 版本下 deque 容器选项的辅助头文件。该文件通过模板结构体 `get_deque_options`，根据 Boost 版本自动选择合适的 deque 配置选项类型，保证在不同 Boost 版本下的兼容性和统一性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含 `<yggr/container/options.hpp>`，用于获取相关选项定义。
- 在 `yggr::container` 命名空间下定义模板结构体 `get_deque_options<TplArgOpt>`，用于根据模板参数和 Boost 版本选择 deque 配置类型。
- 对于 Boost 1.71.0 之前的版本，`type` 为 `deque_null_opt`（无选项）。
- 对于 Boost 1.71.0 及之后的版本，`type` 为 `boost::container::get_deque_opt<TplArgOpt>::type`，支持更多自定义选项。

## 适用场景

- 需要在不同 Boost 版本下统一适配 deque 容器选项的场景。
- 泛型容器、模板库开发中对 deque 配置选项的自动适配需求。

## 使用示例

```cpp
#include <yggr/container/get_deque_options.hpp>

typedef yggr::container::get_deque_options<MyOpt>::type my_deque_opt;
```

---

本文件为 yggdrasil 容器适配体系的 Boost 兼容性辅助组件，便于在不同 Boost 版本下安全、统一地获取 deque 容器选项类型。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `get_map_options.hpp` 的文档说明：

---

# get_map_options.hpp 文档

## 概述

`get_map_options.hpp` 是 yggdrasil 项目中用于适配 map/multimap 容器选项的辅助头文件。该文件通过模板结构体 `get_map_options` 和 `get_multimap_options`，基于底层 `get_tree_options` 实现，为 map 和 multimap 容器提供统一的选项类型适配，便于泛型容器和模板库开发。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含 `<yggr/container/detail/get_tree_options.hpp>`，用于获取底层树型容器选项适配。
- 在 `yggr::container` 命名空间下定义：
  - `get_map_options<TplArgOpt>`：继承自 `detail::get_tree_options<TplArgOpt>`，用于 map 容器选项适配。
  - `get_multimap_options<TplArgOpt>`：继承自 `detail::get_tree_options<TplArgOpt>`，用于 multimap 容器选项适配。

## 适用场景

- 需要在泛型编程中统一适配 map、multimap 容器选项的场景。
- 需要基于底层树型容器选项扩展 map/multimap 配置的场景。

## 使用示例

```cpp
#include <yggr/container/get_map_options.hpp>

typedef yggr::container::get_map_options<MyOpt>::type my_map_opt;
typedef yggr::container::get_multimap_options<MyOpt>::type my_multimap_opt;
```

---

本文件为 yggdrasil 容器适配体系的 map/multimap 选项适配组件，便于在模板库和泛型容器开发中统一处理相关配置。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `get_set_options.hpp` 的文档说明：

---

# get_set_options.hpp 文档

## 概述

`get_set_options.hpp` 是 yggdrasil 项目中用于适配 set/multiset 容器选项的辅助头文件。该文件通过模板结构体 `get_set_options` 和 `get_multiset_options`，基于底层 `get_tree_options` 实现，为 set 和 multiset 容器提供统一的选项类型适配，便于泛型容器和模板库开发。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含 `<yggr/container/detail/get_tree_options.hpp>`，用于获取底层树型容器选项适配。
- 在 `yggr::container` 命名空间下定义：
  - `get_set_options<TplArgOpt>`：继承自 `detail::get_tree_options<TplArgOpt>`，用于 set 容器选项适配。
  - `get_multiset_options<TplArgOpt>`：继承自 `detail::get_tree_options<TplArgOpt>`，用于 multiset 容器选项适配。

## 适用场景

- 需要在泛型编程中统一适配 set、multiset 容器选项的场景。
- 需要基于底层树型容器选项扩展 set/multiset 配置的场景。

## 使用示例

```cpp
#include <yggr/container/get_set_options.hpp>

typedef yggr::container::get_set_options<MyOpt>::type my_set_opt;
typedef yggr::container::get_multiset_options<MyOpt>::type my_multiset_opt;
```

---

本文件为 yggdrasil 容器适配体系的 set/multiset 选项适配组件，便于在模板库和泛型容器开发中统一处理相关配置。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `get_vector_options.hpp` 的文档说明：

---

# get_vector_options.hpp 文档

## 概述

`get_vector_options.hpp` 是 yggdrasil 项目中用于适配 Boost 版本下 vector 容器选项的辅助头文件。该文件通过模板结构体 `get_vector_options`，根据 Boost 版本自动选择合适的 vector 配置选项类型，保证在不同 Boost 版本下的兼容性和统一性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含 `<yggr/container/options.hpp>` 和 `<boost/container/vector.hpp>`，用于获取相关选项定义和 Boost vector 支持。
- 在 `yggr::container` 命名空间下定义模板结构体 `get_vector_options<TplArgOpt, Size>`，用于根据模板参数和 Boost 版本选择 vector 配置类型。
- 对于 Boost 1.67.0 之前的版本，`type` 为 `vector_null_opt`（无选项）。
- 对于 Boost 1.67.0 及之后的版本，`type` 为 `boost::container::get_vector_opt<TplArgOpt, Size>::type`，支持更多自定义选项。

## 适用场景

- 需要在不同 Boost 版本下统一适配 vector 容器选项的场景。
- 泛型容器、模板库开发中对 vector 配置选项的自动适配需求。

## 使用示例

```cpp
#include <yggr/container/get_vector_options.hpp>

typedef yggr::container::get_vector_options<MyOpt, MySize>::type my_vector_opt;
```

---

本文件为 yggdrasil 容器适配体系的 Boost 兼容性辅助组件，便于在不同 Boost 版本下安全、统一地获取 vector 容器选项类型。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `index_generator.hpp` 的文档说明：

---

# index_generator.hpp 文档

## 概述

`index_generator.hpp` 是 yggdrasil 项目中用于多索引容器（如 Boost.MultiIndex）索引生成的适配头文件。该文件通过引入并重命名 Boost.MultiIndex 的相关工具类型和宏，方便在 yggdrasil 项目中统一定义和管理多索引容器的索引类型、成员、成员函数等，提升代码的可读性和可维护性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含 `<yggr/base/yggrdef.h>` 和 Boost.MultiIndex 相关头文件。
- 在 `yggr::container` 命名空间下引入并重命名了 Boost.MultiIndex 的常用类型和工具，包括：
  - `indexed_by`、`identity`、`member`、`member_offset`
  - `mem_fun`、`const_mem_fun`、`mem_fun_explicit`、`const_mem_fun_explicit`
  - `global_fun`
  - `composite_key` 及其相关比较、哈希类型
- 定义了宏 `YGGR_INDEX_GENERATOR_MEMBER`、`YGGR_INDEX_GENERATOR_MEM_FUN`、`YGGR_INDEX_GENERATOR_CONST_MEM_FUN`，分别对应 Boost.MultiIndex 的成员和成员函数索引宏，便于统一书写风格。

## 适用场景

- 需要在项目中大量使用 Boost.MultiIndex 多索引容器时，统一索引定义方式。
- 泛型容器、数据表、索引结构等需要灵活定义多种索引的场景。

## 使用示例

```cpp
#include <yggr/container/index_generator.hpp>

// 定义多索引容器时可直接使用 yggr::container 命名空间下的类型和宏
```

---

本文件为 yggdrasil 多索引容器适配体系的基础组件，便于统一管理和扩展 Boost.MultiIndex 相关功能。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_isomeric_same_deque.hpp` 的文档说明：

---

# is_isomeric_same_deque.hpp 文档

## 概述

`is_isomeric_same_deque.hpp` 是 yggdrasil 项目中用于判断两个 deque 类型在“同构等价”意义下是否相同的类型萃取工具。该文件主要解决 Boost 1.70 及以后版本中 `boost::container::deque` 模板参数变化导致的类型兼容性问题，便于泛型编程时安全判断不同 deque 类型的等价性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 详细注释说明 Boost 1.70+ 版本 deque 模板参数变化及兼容性问题。
- 包含类型萃取、模板展开、分配器萃取等相关头文件。
- 在 `yggr::container::detail` 命名空间下实现 `_is_isomeric_same_deque_detail` 模板结构体，递归判断两个 deque 类型的模板参数、值类型、分配器类型等是否“同构等价”。
  - 对于模板参数数量不同、类型不同等情况，返回 `false_`。
  - 对于模板参数数量为 2 的情况，判断值类型和分配器类型是否一致，且第二模板参数（如 void）不同。
- 提供 `is_isomeric_same_deque<DqL, DqR>` 类型萃取，判断两个 deque 类型是否“同构等价”。
- 提供 `is_same_or_isomeric_same_deque<DqL, DqR>` 类型萃取，判断两个类型是否完全相同或“同构等价”。
- 将上述类型萃取提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要在泛型编程中判断不同 deque 类型（如模板参数不同但本质等价）是否可以安全互操作的场景。
- 解决 Boost 1.70+ 版本 deque 模板参数兼容性问题，提升代码健壮性和可移植性。

## 使用示例

```cpp
#include <yggr/container/is_isomeric_same_deque.hpp>

static_assert(
    yggr::is_isomeric_same_deque<
        boost::container::deque<int, void>,
        boost::container::deque<int, std::allocator<int>>
    >::value, "类型同构等价"
);
```

---

本文件为 yggdrasil 容器适配体系的类型兼容性辅助组件，便于在模板库和泛型容器开发中统一处理 deque 类型的等价性判断。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_isomeric_same_list.hpp` 的文档说明：

---

# is_isomeric_same_list.hpp 文档

## 概述

`is_isomeric_same_list.hpp` 是 yggdrasil 项目中用于判断两个 list 类型在“同构等价”意义下是否相同的类型萃取工具。该文件主要解决 Boost 1.70 及以后版本中 `boost::container::list` 模板参数变化导致的类型兼容性问题，便于泛型编程时安全判断不同 list 类型的等价性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 注释说明 Boost 1.70+ 版本 list/vector 等容器模板参数变化及兼容性问题。
- 包含类型萃取、模板展开、分配器萃取等相关头文件。
- 在 `yggr::container::detail` 命名空间下实现 `_is_isomeric_same_list_detail` 模板结构体，递归判断两个 list 类型的模板参数、值类型、分配器类型等是否“同构等价”。
  - 对于模板参数数量不同、类型不同等情况，返回 `false_`。
  - 对于模板参数数量为 2 的情况，判断值类型和分配器类型是否一致，且第二模板参数（如 void）不同。
- 提供 `is_isomeric_same_list<LstL, LstR>` 类型萃取，判断两个 list 类型是否“同构等价”。
- 提供 `is_same_or_isomeric_same_list<LstL, LstR>` 类型萃取，判断两个类型是否完全相同或“同构等价”。
- 将上述类型萃取提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要在泛型编程中判断不同 list 类型（如模板参数不同但本质等价）是否可以安全互操作的场景。
- 解决 Boost 1.70+ 版本 list/vector 等容器模板参数兼容性问题，提升代码健壮性和可移植性。

## 使用示例

```cpp
#include <yggr/container/is_isomeric_same_list.hpp>

static_assert(
    yggr::is_isomeric_same_list<
        boost::container::list<int, void>,
        boost::container::list<int, std::allocator<int>>
    >::value, "类型同构等价"
);
```

---

本文件为 yggdrasil 容器适配体系的类型兼容性辅助组件，便于在模板库和泛型容器开发中统一处理 list 类型的等价性判断。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_isomeric_same_map.hpp` 的文档说明：

---

# is_isomeric_same_map.hpp 文档

## 概述

`is_isomeric_same_map.hpp` 是 yggdrasil 项目中用于判断两个 map 或 multimap 类型在“同构等价”意义下是否相同的类型萃取工具。该文件主要解决 Boost 1.70 及以后版本中 `boost::container::map` 模板参数变化导致的类型兼容性问题，便于泛型编程时安全判断不同 map 类型的等价性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 注释说明 Boost 1.70+ 版本 map 容器模板参数变化及兼容性问题。
- 包含类型萃取、模板展开、分配器和比较器萃取等相关头文件。
- 在 `yggr::container::detail` 命名空间下实现 `_is_isomeric_same_map_detail` 模板结构体，递归判断两个 map 类型的模板参数、值类型、分配器类型、比较器类型等是否“同构等价”。
  - 对于模板参数数量不同、类型不同等情况，返回 `false_`。
  - 对于模板参数数量为 4 的情况，判断值类型、分配器类型、key 比较器类型一致，且第四模板参数（如 void）不同。
- 提供 `is_isomeric_same_map<MapL, MapR>` 类型萃取，判断两个 map 类型是否“同构等价”。
- 提供 `is_same_or_isomeric_same_map<MapL, MapR>` 类型萃取，判断两个类型是否完全相同或“同构等价”。
- 提供 `is_isomeric_same_multimap` 及 `is_same_or_isomeric_same_multimap`，用于 multimap 类型判断。
- 将上述类型萃取提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要在泛型编程中判断不同 map/multimap 类型（如模板参数不同但本质等价）是否可以安全互操作的场景。
- 解决 Boost 1.70+ 版本 map/multimap 容器模板参数兼容性问题，提升代码健壮性和可移植性。

## 使用示例

```cpp
#include <yggr/container/is_isomeric_same_map.hpp>

static_assert(
    yggr::is_isomeric_same_map<
        boost::container::map<int, int, std::less<int>, void>,
        boost::container::map<int, int, std::less<int>, std::allocator<std::pair<const int, int>>>
    >::value, "类型同构等价"
);
```

---

本文件为 yggdrasil 容器适配体系的类型兼容性辅助组件，便于在模板库和泛型容器开发中统一处理 map/multimap 类型的等价性判断。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_isomeric_same_options_deque.hpp` 的文档说明：

---

# is_isomeric_same_options_deque.hpp 文档

## 概述

`is_isomeric_same_options_deque.hpp` 是 yggdrasil 项目中用于判断带有选项参数的 deque 类型在“同构等价”意义下是否相同的类型萃取工具。该文件主要解决 Boost 1.70 及以后版本中 `boost::container::deque` 模板参数和选项参数变化导致的类型兼容性问题，便于泛型编程时安全判断不同 deque 类型（含 options）的等价性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含类型萃取、模板展开、分配器萃取、选项适配等相关头文件。
- 在 `yggr::container::detail` 命名空间下实现 `_is_isomeric_same_options_deque_detail` 模板结构体，递归判断两个带 options 的 deque 类型的模板参数、值类型、分配器类型、options 类型等是否“同构等价”。
  - 对于模板参数数量不同、类型不同等情况，返回 `false_`。
  - 对于模板参数数量为 2 的情况，复用基础 deque 的同构判断。
  - 对于模板参数数量为 3 的情况，判断第二、三模板参数是否不同，值类型、分配器类型、options 类型是否一致。
- 提供 `is_isomeric_same_options_deque<DqL, DqR>` 类型萃取，判断两个带 options 的 deque 类型是否“同构等价”。
- 提供 `is_same_or_isomeric_same_options_deque<DqL, DqR>` 类型萃取，判断两个类型是否完全相同或“同构等价”。
- 将上述类型萃取提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要在泛型编程中判断不同带 options 的 deque 类型（如模板参数不同但本质等价）是否可以安全互操作的场景。
- 解决 Boost 1.70+ 版本 deque 容器模板参数和 options 兼容性问题，提升代码健壮性和可移植性。

## 使用示例

```cpp
#include <yggr/container/is_isomeric_same_options_deque.hpp>

static_assert(
    yggr::is_isomeric_same_options_deque<
        boost::container::deque<int, void, MyOpt1>,
        boost::container::deque<int, std::allocator<int>, MyOpt2>
    >::value, "类型同构等价"
);
```

---

本文件为 yggdrasil 容器适配体系的类型兼容性辅助组件，便于在模板库和泛型容器开发中统一处理带 options 的 deque 类型的等价性判断。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_isomeric_same_options_map.hpp` 的文档说明：

---

# is_isomeric_same_options_map.hpp 文档

## 概述

`is_isomeric_same_options_map.hpp` 是 yggdrasil 项目中用于判断带有选项参数的 map/multimap 类型在“同构等价”意义下是否相同的类型萃取工具。该文件主要解决 Boost 1.70 及以后版本中 `boost::container::map` 模板参数和 options 参数变化导致的类型兼容性问题，便于泛型编程时安全判断不同 map 类型（含 options）的等价性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 注释说明 Boost 1.70+ 版本 map 容器模板参数和 options 兼容性问题。
- 包含类型萃取、模板展开、分配器和比较器萃取、选项适配等相关头文件。
- 在 `yggr::container::detail` 命名空间下实现 `_is_isomeric_same_options_map_detail` 模板结构体，递归判断两个带 options 的 map 类型的模板参数、值类型、分配器类型、key 比较器类型、options 类型等是否“同构等价”。
  - 对于模板参数数量不同、类型不同等情况，返回 `false_`。
  - 对于模板参数数量为 4 的情况，复用基础 map 的同构判断。
  - 对于模板参数数量为 5 的情况，判断第三、四模板参数是否不同，值类型、分配器类型、key 比较器类型、options 类型是否一致。
- 提供 `is_isomeric_same_options_map<MapL, MapR>` 类型萃取，判断两个带 options 的 map 类型是否“同构等价”。
- 提供 `is_same_or_isomeric_same_options_map<MapL, MapR>` 类型萃取，判断两个类型是否完全相同或“同构等价”。
- 提供 `is_isomeric_same_options_multimap` 及 `is_same_or_isomeric_same_options_multimap`，用于 multimap 类型判断。
- 将上述类型萃取提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要在泛型编程中判断不同带 options 的 map/multimap 类型（如模板参数不同但本质等价）是否可以安全互操作的场景。
- 解决 Boost 1.70+ 版本 map/multimap 容器模板参数和 options 兼容性问题，提升代码健壮性和可移植性。

## 使用示例

```cpp
#include <yggr/container/is_isomeric_same_options_map.hpp>

static_assert(
    yggr::is_isomeric_same_options_map<
        boost::container::map<int, int, std::less<int>, void, MyOpt1>,
        boost::container::map<int, int, std::less<int>, std::allocator<std::pair<const int, int>>, MyOpt2>
    >::value, "类型同构等价"
);
```

---

本文件为 yggdrasil 容器适配体系的类型兼容性辅助组件，便于在模板库和泛型容器开发中统一处理带 options 的 map/multimap 类型的等价性判断。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_isomeric_same_options_set.hpp` 的文档说明：

---

# is_isomeric_same_options_set.hpp 文档

## 概述

`is_isomeric_same_options_set.hpp` 是 yggdrasil 项目中用于判断带有选项参数的 set/multiset 类型在“同构等价”意义下是否相同的类型萃取工具。该文件主要解决 Boost 1.70 及以后版本中 `boost::container::set` 模板参数和 options 参数变化导致的类型兼容性问题，便于泛型编程时安全判断不同 set 类型（含 options）的等价性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 注释说明 Boost 1.70+ 版本 set 容器模板参数和 options 兼容性问题。
- 包含类型萃取、模板展开、分配器和比较器萃取、选项适配等相关头文件。
- 在 `yggr::container::detail` 命名空间下实现 `_is_isomeric_same_options_set_detail` 模板结构体，递归判断两个带 options 的 set 类型的模板参数、值类型、分配器类型、key 比较器类型、options 类型等是否“同构等价”。
  - 对于模板参数数量不同、类型不同等情况，返回 `false_`。
  - 对于模板参数数量为 3 的情况，复用基础 set 的同构判断。
  - 对于模板参数数量为 4 的情况，判断第二、三模板参数是否不同，值类型、分配器类型、key 比较器类型、options 类型是否一致。
- 提供 `is_isomeric_same_options_set<SetL, SetR>` 类型萃取，判断两个带 options 的 set 类型是否“同构等价”。
- 提供 `is_same_or_isomeric_same_options_set<SetL, SetR>` 类型萃取，判断两个类型是否完全相同或“同构等价”。
- 提供 `is_isomeric_same_options_multiset` 及 `is_same_or_isomeric_same_options_multiset`，用于 multiset 类型判断。
- 将上述类型萃取提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要在泛型编程中判断不同带 options 的 set/multiset 类型（如模板参数不同但本质等价）是否可以安全互操作的场景。
- 解决 Boost 1.70+ 版本 set/multiset 容器模板参数和 options 兼容性问题，提升代码健壮性和可移植性。

## 使用示例

```cpp
#include <yggr/container/is_isomeric_same_options_set.hpp>

static_assert(
    yggr::is_isomeric_same_options_set<
        boost::container::set<int, void, MyOpt1>,
        boost::container::set<int, std::less<int>, std::allocator<int>, MyOpt2>
    >::value, "类型同构等价"
);
```

---

本文件为 yggdrasil 容器适配体系的类型兼容性辅助组件，便于在模板库和泛型容器开发中统一处理带 options 的 set/multiset 类型的等价性判断。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_isomeric_same_options_vector.hpp` 的文档说明：

---

# is_isomeric_same_options_vector.hpp 文档

## 概述

`is_isomeric_same_options_vector.hpp` 是 yggdrasil 项目中用于判断带有选项参数的 vector 类型在“同构等价”意义下是否相同的类型萃取工具。该文件主要解决 Boost 1.70 及以后版本中 `boost::container::vector` 模板参数和 options 参数变化导致的类型兼容性问题，便于泛型编程时安全判断不同 vector 类型（含 options）的等价性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含类型萃取、模板展开、分配器萃取、选项适配等相关头文件。
- 在 `yggr::container::detail` 命名空间下实现 `_is_isomeric_same_options_vector_detail` 模板结构体，递归判断两个带 options 的 vector 类型的模板参数、值类型、分配器类型、options 类型等是否“同构等价”。
  - 对于模板参数数量不同、类型不同等情况，返回 `false_`。
  - 对于模板参数数量为 2 的情况，复用基础 vector 的同构判断。
  - 对于模板参数数量为 3 的情况，判断第二、三模板参数是否不同，值类型、分配器类型、options 类型是否一致。
- 提供 `is_isomeric_same_options_vector<VtL, VtR>` 类型萃取，判断两个带 options 的 vector 类型是否“同构等价”。
- 提供 `is_same_or_isomeric_same_options_vector<VtL, VtR>` 类型萃取，判断两个类型是否完全相同或“同构等价”。
- 将上述类型萃取提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要在泛型编程中判断不同带 options 的 vector 类型（如模板参数不同但本质等价）是否可以安全互操作的场景。
- 解决 Boost 1.70+ 版本 vector 容器模板参数和 options 兼容性问题，提升代码健壮性和可移植性。

## 使用示例

```cpp
#include <yggr/container/is_isomeric_same_options_vector.hpp>

static_assert(
    yggr::is_isomeric_same_options_vector<
        boost::container::vector<int, void, MyOpt1>,
        boost::container::vector<int, std::allocator<int>, MyOpt2>
    >::value, "类型同构等价"
);
```

---

本文件为 yggdrasil 容器适配体系的类型兼容性辅助组件，便于在模板库和泛型容器开发中统一处理带 options 的 vector 类型的等价性判断。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_isomeric_same_set.hpp` 的文档说明：

---

# is_isomeric_same_set.hpp 文档

## 概述

`is_isomeric_same_set.hpp` 是 yggdrasil 项目中用于判断 set/multiset 类型在“同构等价”意义下是否相同的类型萃取工具。该文件主要解决 Boost 1.70 及以后版本中 `boost::container::set` 模板参数变化导致的类型兼容性问题，便于泛型编程时安全判断不同 set 类型的等价性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 注释说明 Boost 1.70+ 版本 set 容器模板参数兼容性问题。
- 包含类型萃取、模板展开、分配器和比较器萃取等相关头文件。
- 在 `yggr::container::detail` 命名空间下实现 `_is_isomeric_same_set_detail` 模板结构体，递归判断两个 set 类型的模板参数、值类型、分配器类型、key 比较器类型等是否“同构等价”。
  - 对于模板参数数量不同、类型不同等情况，返回 `false_`。
  - 对于模板参数数量为 3 的情况，判断第三模板参数（如 void）不同，值类型、分配器类型、key 比较器类型一致。
- 提供 `is_isomeric_same_set<SetL, SetR>` 类型萃取，判断两个 set 类型是否“同构等价”。
- 提供 `is_same_or_isomeric_same_set<SetL, SetR>` 类型萃取，判断两个类型是否完全相同或“同构等价”。
- 提供 `is_isomeric_same_multiset` 及 `is_same_or_isomeric_same_multiset`，用于 multiset 类型判断。
- 将上述类型萃取提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要在泛型编程中判断不同 set/multiset 类型（如模板参数不同但本质等价）是否可以安全互操作的场景。
- 解决 Boost 1.70+ 版本 set/multiset 容器模板参数兼容性问题，提升代码健壮性和可移植性。

## 使用示例

```cpp
#include <yggr/container/is_isomeric_same_set.hpp>

static_assert(
    yggr::is_isomeric_same_set<
        boost::container::set<int, void, MyOpt1>,
        boost::container::set<int, std::less<int>, std::allocator<int>>
    >::value, "类型同构等价"
);
```

---

本文件为 yggdrasil 容器适配体系的类型兼容性辅助组件，便于在模板库和泛型容器开发中统一处理 set/multiset 类型的等价性判断。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_isomeric_same_vector.hpp` 的文档说明：

---

# is_isomeric_same_vector.hpp 文档

## 概述

`is_isomeric_same_vector.hpp` 是 yggdrasil 项目中用于判断 vector 类型在“同构等价”意义下是否相同的类型萃取工具。该文件主要解决 Boost 1.70 及以后版本中 `boost::container::vector` 模板参数变化导致的类型兼容性问题，便于泛型编程时安全判断不同 vector 类型的等价性。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 注释说明 Boost 1.70+ 版本 vector 容器模板参数兼容性问题。
- 包含类型萃取、模板展开、分配器萃取等相关头文件。
- 在 `yggr::container::detail` 命名空间下实现 `_is_isomeric_same_vector_detail` 模板结构体，递归判断两个 vector 类型的模板参数、值类型、分配器类型等是否“同构等价”。
  - 对于模板参数数量不同、类型不同等情况，返回 `false_`。
  - 对于模板参数数量为 2 的情况，判断第二模板参数（如 void）不同，值类型和分配器类型一致。
- 提供 `is_isomeric_same_vector<VtL, VtR>` 类型萃取，判断两个 vector 类型是否“同构等价”。
- 提供 `is_same_or_isomeric_same_vector<VtL, VtR>` 类型萃取，判断两个类型是否完全相同或“同构等价”。
- 将上述类型萃取提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要在泛型编程中判断不同 vector 类型（如模板参数不同但本质等价）是否可以安全互操作的场景。
- 解决 Boost 1.70+ 版本 vector 容器模板参数兼容性问题，提升代码健壮性和可移植性。

## 使用示例

```cpp
#include <yggr/container/is_isomeric_same_vector.hpp>

static_assert(
    yggr::is_isomeric_same_vector<
        boost::container::vector<int, void>,
        boost::container::vector<int, std::allocator<int>>
    >::value, "类型同构等价"
);
```

---

本文件为 yggdrasil 容器适配体系的类型兼容性辅助组件，便于在模板库和泛型容器开发中统一处理 vector 类型的等价性判断。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `iterator_cast.hpp` 的文档说明：

---

# iterator_cast.hpp 文档

## 概述

`iterator_cast.hpp` 是 yggdrasil 项目中用于容器迭代器类型转换的辅助头文件。该文件提供了将 const_iterator 转换为 iterator 以及对 iterator 的引用进行类型适配的工具函数，便于在泛型编程和容器操作中安全、统一地进行迭代器类型转换。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含基础定义头文件 `<yggr/base/yggrdef.h>` 和 `<iterator>`。
- 在 `yggr::container` 命名空间下定义：
  - `cast_to_iterator(Container&, const Container::iterator&)`：返回 iterator 的常量引用。
  - `cast_to_iterator(Container&, Container::iterator&)`：返回 iterator 的非常量引用。
  - `cast_to_iterator(Container&, const Container::const_iterator&)`：将 const_iterator 转换为 iterator，通过 begin() 和 std::advance/std::distance 实现位置同步。

## 适用场景

- 需要在泛型算法或容器操作中，将 const_iterator 转换为 iterator 的场景。
- 需要对 iterator 引用进行类型适配，保证接口统一的场景。

## 使用示例

```cpp
#include <yggr/container/iterator_cast.hpp>

std::vector<int> v = {1, 2, 3};
auto cit = v.cbegin();
auto it = yggr::container::cast_to_iterator(v, cit); // 转为 iterator
```

---

本文件为 yggdrasil 容器适配体系的迭代器类型转换辅助组件，便于在模板库和泛型容器开发中统一处理迭代器类型转换。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `list.hpp` 的文档说明：

---

# list.hpp 文档

## 概述

`list.hpp` 是 yggdrasil 项目中用于统一适配 `std::list` 和 `boost::container::list` 的容器适配头文件。该文件根据编译环境和 Boost 版本，自动选择合适的 list 实现，并为 list 容器提供 emplace、erase、remove、unique、swap 等统一接口和兼容性扩展，支持泛型编程和高效容器操作。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含基础定义、容器选择、SFINAE、类型萃取、辅助宏等相关头文件。
- 兼容 `std::list` 和 `boost::container::list`，并根据 Boost 版本自动适配。
- 提供统一的 emplace、emplace_front、emplace_back、erase、erase_if、remove、remove_if、unique 等接口，支持变参模板和宏展开，兼容 C++11 及更早标准。
- 支持 isomeric same 类型判断，保证不同模板参数下的 list 类型安全转换和操作。
- 对于 Boost 1.70 及以上版本，提供自定义 detail::list 实现，支持更多构造、赋值、swap、remove、unique 等操作，并与 boost::container::list 互操作。
- 提供 swap 支持和 range size 支持，便于与标准库和 boost 生态无缝集成。
- 通过宏和类型萃取，支持泛型编程和容器类型自动推断。

## 适用场景

- 需要跨平台、跨标准库环境下统一 list 容器类型的场景。
- 需要在项目中灵活切换标准库或 Boost 实现的 list。
- 泛型编程、模板库开发等对容器类型有适配和扩展需求的场景。
- 需要高效、统一的 list 容器操作接口（如 emplace、erase、remove、unique、swap 等）。

## 使用示例

```cpp
#include <yggr/container/list.hpp>

yggr::list<int> l;
l.push_back(1);
l.emplace_back(2);
l.remove(1);
l.unique();
```

---

本文件为 yggdrasil 容器适配体系的 list 适配与扩展组件，便于在模板库和泛型容器开发中统一处理 list 类型的构造、操作和兼容性问题。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `map.hpp` 的文档说明：

---

# map.hpp 文档

## 概述

`map.hpp` 是 yggdrasil 项目中用于统一适配 `std::map` 和 `boost::container::map` 的容器适配头文件。该文件根据项目配置和 Boost 版本，自动选择合适的 map 实现，并为 map 容器提供 insert、erase、find、emplace、swap 等统一接口和兼容性扩展，支持泛型编程和高效容器操作。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含基础定义、容器选择、类型萃取、辅助宏等相关头文件。
- 兼容 `std::map` 和 `boost::container::map`，并根据 Boost 版本自动适配。
- 提供统一的 insert、emplace、erase、find、swap、clear、size、empty 等接口，支持变参模板和宏展开，兼容 C++11 及更早标准。
- 支持 isomeric same 类型判断，保证不同模板参数下的 map 类型安全转换和操作。
- 对于 Boost 1.70 及以上版本，支持自定义 options、分配器等参数的 map 类型，并与 boost::container::map 互操作。
- 提供 swap 支持和 range size 支持，便于与标准库和 boost 生态无缝集成。
- 通过宏和类型萃取，支持泛型编程和容器类型自动推断。

## 适用场景

- 需要跨平台、跨标准库环境下统一 map 容器类型的场景。
- 需要在项目中灵活切换标准库或 Boost 实现的 map。
- 泛型编程、模板库开发等对容器类型有适配和扩展需求的场景。
- 需要高效、统一的 map 容器操作接口（如 emplace、insert、erase、swap 等）。

## 使用示例

```cpp
#include <yggr/container/map.hpp>

yggr::map<int, std::string> m;
m[1] = "hello";
m.emplace(2, "world");
m.erase(1);
```

---

本文件为 yggdrasil 容器适配体系的 map 适配与扩展组件，便于在模板库和泛型容器开发中统一处理 map 类型的构造、操作和兼容性问题。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `mapped_value.hpp` 的文档说明：

---

# mapped_value.hpp 文档

## 概述

`mapped_value.hpp` 是 yggdrasil 项目中用于通用容器元素“映射值”和“映射键”访问的辅助头文件。该文件通过类型萃取和泛型工具，统一为 map、set、pair 及普通类型等容器元素提供 mapped_value（映射值）和 mapped_key（映射键）的获取接口，便于泛型算法和容器操作中安全、统一地访问元素的 value 或 key。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含基础定义、pair、类型萃取、适配器等相关头文件。
- 在 `yggr::container::detail` 命名空间下实现 `mapped_value_helper` 和 `mapped_key_helper`，根据容器是否为“映射容器”自动选择访问 pair 的第二项（value）或第一项（key），否则直接返回对象本身。
- 提供泛型接口 `mapped_value<Container, T>(T&)` 和 `mapped_key<Container, T>(T&)`，自动根据容器类型和元素类型返回正确的 value 或 key 引用。
- 支持常量和非常量版本。
- 将 `mapped_value` 和 `mapped_key` 提升到 yggr 命名空间，便于全局统一调用。

## 适用场景

- 需要在泛型算法或容器操作中，统一访问 map、set、pair、普通类型等容器元素的 value 或 key。
- 需要屏蔽容器类型差异，提升代码复用性和可维护性的场景。

## 使用示例

```cpp
#include <yggr/container/mapped_value.hpp>

std::map<int, std::string>::value_type p = {1, "hello"};
auto& v = yggr::mapped_value<std::map<int, std::string>>(p); // 获取 value
auto& k = yggr::mapped_key<std::map<int, std::string>>(p);   // 获取 key
```

---

本文件为 yggdrasil 容器适配体系的元素访问辅助组件，便于在模板库和泛型容器开发中统一处理容器元素的 value/key 访问。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `multi_index_config.hpp` 的文档说明：

---

# multi_index_config.hpp 文档

## 概述

`multi_index_config.hpp` 是 yggdrasil 项目中用于适配 Boost.MultiIndex 不同版本特性的配置头文件。该文件通过检测 Boost 版本，自动定义一系列宏，标记当前 Boost.MultiIndex 是否支持 emplace、shrink_to_fit、哈希索引比较器、ranked_index、6参数 ordered_index 等特性，便于后续代码根据这些特性进行条件编译和兼容性处理。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含基础定义头文件 `<yggr/base/yggrdef.h>`。
- 根据 Boost 版本号，自动定义以下特性宏：
  - `YGGR_BOOST_MULTI_INDEX_HAS_EMPLACE`：Boost >= 1.55.0 时支持 emplace
  - `YGGR_BOOST_MULTI_INDEX_HAS_SHRINK_TO_FIT`：Boost >= 1.55.0 时支持 shrink_to_fit
  - `YGGR_BOOST_MULTI_INDEX_HASHED_INDEX_HAS_COMPARER`：Boost >= 1.56.0 时哈希索引支持比较器
  - `YGGR_BOOST_MULTI_INDEX_HAS_RANKED_INDEX`：Boost >= 1.59.0 时支持 ranked_index
  - `YGGR_BOOST_MULTI_INDEX_ARGS6_VER_ORDERED_INDEX`：Boost >= 1.59.0 时 ordered_index 支持 6 个参数
- 这些宏可用于后续多索引容器相关代码的条件编译，提升兼容性和可移植性。

## 适用场景

- 需要在不同 Boost 版本下，自动适配 Boost.MultiIndex 新特性或兼容性差异的场景。
- 泛型容器、模板库开发中对 Boost.MultiIndex 特性检测的需求。

## 使用示例

```cpp
#include <yggr/container/multi_index_config.hpp>

#ifdef YGGR_BOOST_MULTI_INDEX_HAS_EMPLACE
// 使用 emplace 相关代码
#endif
```

---

本文件为 yggdrasil 容器适配体系的 Boost.MultiIndex 版本特性检测与配置组件，便于在模板库和泛型容器开发中统一处理多索引容器的特性兼容性。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `multi_index_container.hpp` 的文档说明：

---

# multi_index_container.hpp 文档

## 概述

`multi_index_container.hpp` 是 yggdrasil 项目中对 Boost.MultiIndex 容器的适配与扩展头文件。该文件统一引入并适配 `boost::multi_index::multi_index_container`，并为多索引容器的类型推导、节点句柄、范围操作等提供辅助工具和宏，便于泛型编程和高效多索引容器操作。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含基础定义、类型展开、SFINAE、配置、节点句柄 traits、范围 size 支持等相关头文件。
- 统一引入 `boost::multi_index::multi_index_container`，并提升为 `yggr::container::multi_index_container`。
- 提供 `cast_to_indexed_by` 模板工具，将自定义模板类型转换为 `boost::multi_index::indexed_by` 类型，支持变参模板和宏展开，兼容 C++11 及更早标准。
- 支持节点句柄相关 hacking 和范围 size 支持，便于与标准库和 boost 生态无缝集成。
- 通过宏和类型萃取，支持泛型编程和多索引容器类型自动推断。

## 适用场景

- 需要在项目中统一使用 Boost.MultiIndex 多索引容器的场景。
- 泛型编程、模板库开发等对多索引容器类型有适配和扩展需求的场景。
- 需要高效、统一的多索引容器类型推导、节点句柄操作、范围 size 支持等。

## 使用示例

```cpp
#include <yggr/container/multi_index_container.hpp>

yggr::multi_index_container<MyType, MyIndex> c;
auto size = c.size();
```

---

本文件为 yggdrasil 容器适配体系的多索引容器适配与扩展组件，便于在模板库和泛型容器开发中统一处理多索引容器的类型推导、节点句柄和范围操作等问题。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `multi_index_hashed_index.hpp` 的文档说明：

---

# multi_index_hashed_index.hpp 文档

## 概述

`multi_index_hashed_index.hpp` 是 yggdrasil 项目中对 Boost.MultiIndex 哈希索引（`hashed_unique`/`hashed_non_unique`）的适配与扩展头文件。该文件统一引入并适配 Boost.MultiIndex 的哈希索引类型，提供 emplace、insert、extract、节点句柄等兼容性接口，并在低版本 Boost 下补充了哈希索引的比较器（==/!=）支持，便于泛型编程和高效多索引容器操作。

## 版权声明

- 作者：xu yang
- 版权归 yggdrasil 项目所有，2010-2024
- 采用 MIT 许可证，允许自由使用、修改、分发和商业化，但需保留版权声明和许可声明。

## 主要内容

- 头文件保护宏，防止重复包含。
- 包含基础定义、类型展开、SFINAE、算法、配置、节点句柄 traits、范围 size 支持等相关头文件。
- 统一引入 `boost::multi_index::hashed_unique` 和 `hashed_non_unique`，并提升为 `yggr::container` 命名空间成员。
- 提供哈希索引的 emplace、emplace_hint、insert、extract 等接口，兼容 C++11 及更早标准，并根据 Boost 版本自动适配。
- 对于 Boost 1.74.0 之前的版本，提供节点句柄 insert/extract 的 hacking 支持。
- 对于 Boost 1.56.0 之前的版本，补充哈希索引的比较器（==/!=）实现，保证不同版本下的容器可比性。
- 支持哈希索引的范围 size 操作，便于与标准库和 boost 生态无缝集成。
- 通过宏和类型萃取，支持泛型编程和多索引容器类型自动推断。

## 适用场景

- 需要在项目中统一使用 Boost.MultiIndex 哈希索引的场景。
- 泛型编程、模板库开发等对哈希索引类型有适配和扩展需求的场景。
- 需要高效、统一的哈希索引 emplace、insert、extract、节点句柄、比较等操作。

## 使用示例

```cpp
#include <yggr/container/multi_index_hashed_index.hpp>

yggr::container::hashed_unique<...> idx;
auto it = yggr::container::emplace(idx, ...);
```

---

本文件为 yggdrasil 容器适配体系的多索引哈希索引适配与扩展组件，便于在模板库和泛型容器开发中统一处理哈希索引的构造、操作和兼容性问题。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 已汇总会话历史记录以下是对 `multi_index_ordered_index.hpp` 的详细技术文档：

---

# 文件：multi_index_ordered_index.hpp

## 版权声明

```
Copyright (c) 2010-2024 yggdrasil
author: xu yang

本文件遵循MIT开源协议，允许自由使用、复制、修改、分发和再授权，但需保留版权声明和许可声明。文件按“原样”提供，不附带任何明示或暗示的担保。
```

## 文件概述

本头文件是 yggdrasil 容器库对 Boost.MultiIndex 有序索引（ordered_index）的适配与扩展，主要用于增强 Boost.MultiIndex 的有序索引功能，提供更好的兼容性、可移植性和便捷的接口封装，支持不同 Boost 版本和 C++ 标准下的有序索引操作。

## 主要内容

1. **头文件依赖**  
   - 依赖 yggdrasil 自身的 move、预处理宏、类型扩展、SFINAE、配置、节点句柄等模块。
   - 依赖 Boost.MultiIndex 的 ordered_index 及相关 MPL、类型特征工具。

2. **命名空间导入**  
   - 将 `boost::multi_index::ordered_unique` 和 `ordered_non_unique` 引入 `yggr::container` 命名空间，便于直接使用。

3. **emplace/emplace_hint 封装**  
   - 针对不同 C++ 标准（C++11 及以上的变参模板，或旧标准下的宏展开）和 Boost 版本，封装了 `emplace` 和 `emplace_hint` 方法，支持有序索引的高效原地构造插入。
   - 兼容 Boost 早期版本不支持 emplace 的情况，自动降级为 insert。

4. **节点句柄（node handle）相关操作**  
   - 对 Boost 1.74.0 之前的版本，提供了 extract（节点提取）和 insert（节点插入）接口，支持节点级别的高效移动和插入操作，便于容器间元素迁移。
   - 通过 reinterpret_cast 及 hacking 技巧，兼容 Boost 内部实现的差异。

5. **宏与元编程支持**  
   - 利用宏和预处理展开，支持不同参数数量的 emplace/emplace_hint 重载，兼容无变参模板的编译环境。
   - 提供 YGGR_PP_CONTAINER_RANGE_SIZE_SUPPORT 宏，扩展 ordered_index 的范围大小支持。

## 典型使用场景

- 需要在 yggdrasil 框架下使用 Boost.MultiIndex 的有序索引，并希望获得更好的跨版本兼容性和接口一致性。
- 需要在 C++11 及以上标准下高效地原地构造插入元素（emplace），或在旧标准下自动降级为 insert。
- 需要支持节点句柄（node handle）操作，实现容器间元素的高效迁移（如 extract/insert）。
- 需要对 Boost.MultiIndex 的 ordered_index 进行进一步的元编程扩展。

## 主要接口说明

- `emplace` / `emplace_hint`  
  支持变参模板和宏展开两种方式，自动适配 Boost 版本和 C++ 标准，原地构造插入元素。

- `extract`  
  从有序索引中提取节点，返回节点句柄，便于后续插入到其他容器。

- `insert`  
  支持节点句柄的插入，兼容 Boost 1.74.0 之前的实现。

- `ordered_unique` / `ordered_non_unique`  
  直接引入 Boost.MultiIndex 的有序唯一/非唯一索引类型。

## 示例代码

```cpp
#include <yggr/container/multi_index_ordered_index.hpp>
#include <boost/multi_index_container.hpp>
#include <string>

struct Person {
    int id;
    std::string name;
};

using namespace yggr::container;
using namespace boost::multi_index;

typedef multi_index_container<
    Person,
    indexed_by<
        ordered_unique<member<Person, int, &Person::id>>,
        ordered_non_unique<member<Person, std::string, &Person::name>>
    >
> person_set;

person_set ps;

// 原地构造插入（C++11及以上）
ps.get<0>().emplace(1, "Alice");

// 节点提取与插入（Boost 1.74.0及以下）
#if (BOOST_VERSION < 107400)
auto node = extract(ps.get<0>(), 1);
insert(ps.get<0>(), std::move(node));
#endif
```

## 注意事项

- 该头文件大量使用条件编译和宏，确保在不同 Boost 版本和 C++ 标准下都能正常工作。
- 节点句柄相关操作仅在 Boost 1.74.0 及以下版本有效，1.74.0 及以上请直接使用 Boost 官方接口。
- 依赖 yggdrasil 的预处理宏和类型工具，需确保相关头文件已正确包含。

---

如需更详细的接口说明或特定用法示例，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是对 `multi_index_random_access_index.hpp` 的详细技术文档：

---

# 文件：multi_index_random_access_index.hpp

## 版权声明

```
Copyright (c) 2010-2024 yggdrasil
author: xu yang

本文件遵循MIT开源协议，允许自由使用、复制、修改、分发和再授权，但需保留版权声明和许可声明。文件按“原样”提供，不附带任何明示或暗示的担保。
```

## 文件概述

本头文件是 yggdrasil 容器库对 Boost.MultiIndex 随机访问索引（random_access_index）的适配与扩展，主要用于增强 Boost.MultiIndex 的随机访问索引功能，提供更好的跨版本兼容性、接口一致性和便捷的节点操作支持。

## 主要内容

1. **头文件依赖**  
   - 依赖 yggdrasil 的 move、预处理宏、类型扩展、SFINAE、配置、节点句柄等模块。
   - 依赖 Boost.MultiIndex 的 random_access_index 及相关类型工具。

2. **命名空间导入**  
   - 将 `boost::multi_index::random_access` 引入 `yggr::container` 命名空间，便于直接使用。

3. **emplace/emplace_front/emplace_back 封装**  
   - 针对不同 C++ 标准（C++11 及以上的变参模板，或旧标准下的宏展开）和 Boost 版本，封装了 `emplace_front`、`emplace_back`、`emplace` 方法，支持随机访问索引的高效原地构造插入。
   - 兼容 Boost 早期版本不支持 emplace 的情况，自动降级为 push_front/push_back/insert。

4. **节点句柄（node handle）相关操作**  
   - 对 Boost 1.74.0 之前的版本，提供了 extract（节点提取）和 insert（节点插入）接口，支持节点级别的高效移动和插入操作，便于容器间元素迁移。
   - 通过 reinterpret_cast 及 hacking 技巧，兼容 Boost 内部实现的差异。

5. **宏与元编程支持**  
   - 利用宏和预处理展开，支持不同参数数量的 emplace/emplace_front/emplace_back 重载，兼容无变参模板的编译环境。

## 典型使用场景

- 需要在 yggdrasil 框架下使用 Boost.MultiIndex 的随机访问索引，并希望获得更好的跨版本兼容性和接口一致性。
- 需要在 C++11 及以上标准下高效地原地构造插入元素（emplace），或在旧标准下自动降级为 push/insert。
- 需要支持节点句柄（node handle）操作，实现容器间元素的高效迁移（如 extract/insert）。
- 需要对 Boost.MultiIndex 的 random_access_index 进行进一步的元编程扩展。

## 主要接口说明

- `emplace_front` / `emplace_back` / `emplace`  
  支持变参模板和宏展开两种方式，自动适配 Boost 版本和 C++ 标准，原地构造插入元素或在指定位置插入。

- `extract`  
  从随机访问索引中提取节点，返回节点句柄，便于后续插入到其他容器。

- `insert`  
  支持节点句柄的插入，兼容 Boost 1.74.0 之前的实现。

- `random_access`  
  直接引入 Boost.MultiIndex 的随机访问索引类型。

## 示例代码

```cpp
#include <yggr/container/multi_index_random_access_index.hpp>
#include <boost/multi_index_container.hpp>
#include <string>

struct Person {
    int id;
    std::string name;
};

using namespace yggr::container;
using namespace boost::multi_index;

typedef multi_index_container<
    Person,
    indexed_by<
        random_access<>
    >
> person_list;

person_list pl;

// 原地构造插入（C++11及以上）
pl.get<0>().emplace_back(1, "Alice");

// 节点提取与插入（Boost 1.74.0及以下）
#if (BOOST_VERSION < 107400)
auto node = extract(pl.get<0>(), pl.get<0>().begin());
insert(pl.get<0>(), pl.get<0>().end(), std::move(node));
#endif
```

## 注意事项

- 该头文件大量使用条件编译和宏，确保在不同 Boost 版本和 C++ 标准下都能正常工作。
- 节点句柄相关操作仅在 Boost 1.74.0 及以下版本有效，1.74.0 及以上请直接使用 Boost 官方接口。
- 依赖 yggdrasil 的预处理宏和类型工具，需确保相关头文件已正确包含。

---

如需更详细的接口说明或特定用法示例，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是对 `multi_index_ranked_index.hpp` 的详细技术文档：

---

# 文件：multi_index_ranked_index.hpp

## 版权声明

```
Copyright (c) 2010-2024 yggdrasil
author: xu yang

本文件遵循MIT开源协议，允许自由使用、复制、修改、分发和再授权，但需保留版权声明和许可声明。文件按“原样”提供，不附带任何明示或暗示的担保。
```

## 文件概述

本头文件是 yggdrasil 容器库对 Boost.MultiIndex ranked_index（有序排名索引）的适配与扩展，主要用于在 Boost 1.59 及以上版本下，便捷地使用 ranked_index 相关功能，并为 yggdrasil 框架提供统一的接口封装。

## 主要内容

1. **头文件依赖**  
   - 依赖 yggdrasil 的多项基础设施，包括预处理宏、类型扩展、SFINAE、ordered_index 适配、节点句柄 hacking 等。
   - 依赖 Boost.MultiIndex 的 ranked_index 及相关类型。

2. **条件编译与版本检测**  
   - 仅在定义了 `YGGR_BOOST_MULTI_INDEX_HAS_RANKED_INDEX`（即 Boost 版本 >= 1.59）时才允许编译和使用本模块，否则直接报错，防止低版本 Boost 环境下误用。

3. **命名空间导入**  
   - 将 `boost::multi_index::ranked_unique` 和 `ranked_non_unique` 引入 `yggr::container` 命名空间，便于直接使用。

4. **扩展与兼容性**  
   - 通过包含 `multi_index_ordered_index.hpp` 和节点 hacking 相关头文件，为 ranked_index 提供更好的兼容性和扩展能力，便于后续节点操作和元编程扩展。

## 典型使用场景

- 需要在 yggdrasil 框架下使用 Boost.MultiIndex 的 ranked_index（有序排名索引），并希望获得统一的接口风格和跨版本兼容性。
- 需要支持基于排名的高效元素访问、插入、删除等操作。
- 需要对 Boost.MultiIndex 的 ranked_index 进行进一步的元编程扩展或节点句柄操作。

## 主要接口说明

- `ranked_unique` / `ranked_non_unique`  
  直接引入 Boost.MultiIndex 的有序唯一/非唯一排名索引类型，支持基于排名的高效访问。

## 示例代码

```cpp
#include <yggr/container/multi_index_ranked_index.hpp>
#include <boost/multi_index_container.hpp>
#include <string>

struct Person {
    int id;
    std::string name;
};

using namespace yggr::container;
using namespace boost::multi_index;

typedef multi_index_container<
    Person,
    indexed_by<
        ranked_unique<member<Person, int, &Person::id>>
    >
> person_ranked_set;

person_ranked_set prs;

// 插入元素
prs.insert({1, "Alice"});
prs.insert({2, "Bob"});

// 基于排名访问
auto it = prs.get<0>().nth(1); // 获取排名为1的元素
if (it != prs.get<0>().end()) {
    // 使用 *it
}
```

## 注意事项

- 仅在 Boost 1.59 及以上版本可用，低版本会直接编译报错。
- 依赖 yggdrasil 的预处理宏和类型工具，需确保相关头文件已正确包含。
- 若需节点句柄相关操作，需结合 yggdrasil 的节点 hacking 支持。

---

如需更详细的接口说明或特定用法示例，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是对 `multi_index_sequenced_index.hpp` 的详细技术文档：

---

# 文件：multi_index_sequenced_index.hpp

## 版权声明

```
Copyright (c) 2010-2024 yggdrasil
author: xu yang

本文件遵循MIT开源协议，允许自由使用、复制、修改、分发和再授权，但需保留版权声明和许可声明。文件按“原样”提供，不附带任何明示或暗示的担保。
```

## 文件概述

本头文件是 yggdrasil 容器库对 Boost.MultiIndex sequenced_index（序列索引）的适配与扩展，主要用于增强 Boost.MultiIndex 的序列索引功能，提供更好的跨版本兼容性、接口一致性和便捷的节点操作支持。

## 主要内容

1. **头文件依赖**  
   - 依赖 yggdrasil 的 move、预处理宏、类型扩展、SFINAE、配置、节点句柄等模块。
   - 依赖 Boost.MultiIndex 的 sequenced_index 及相关类型工具。

2. **命名空间导入**  
   - 将 `boost::multi_index::sequenced` 引入 `yggr::container` 命名空间，便于直接使用。

3. **emplace/emplace_front/emplace_back 封装**  
   - 针对不同 C++ 标准（C++11 及以上的变参模板，或旧标准下的宏展开）和 Boost 版本，封装了 `emplace_front`、`emplace_back`、`emplace` 方法，支持序列索引的高效原地构造插入。
   - 兼容 Boost 早期版本不支持 emplace 的情况，自动降级为 push_front/push_back/insert。

4. **节点句柄（node handle）相关操作**  
   - 对 Boost 1.74.0 之前的版本，提供了 extract（节点提取）和 insert（节点插入）接口，支持节点级别的高效移动和插入操作，便于容器间元素迁移。
   - 通过 reinterpret_cast 及 hacking 技巧，兼容 Boost 内部实现的差异。

5. **宏与元编程支持**  
   - 利用宏和预处理展开，支持不同参数数量的 emplace/emplace_front/emplace_back 重载，兼容无变参模板的编译环境。
   - 提供 YGGR_PP_CONTAINER_RANGE_SIZE_SUPPORT 宏，扩展 sequenced_index 的范围大小支持。

## 典型使用场景

- 需要在 yggdrasil 框架下使用 Boost.MultiIndex 的 sequenced_index，并希望获得更好的跨版本兼容性和接口一致性。
- 需要在 C++11 及以上标准下高效地原地构造插入元素（emplace），或在旧标准下自动降级为 push/insert。
- 需要支持节点句柄（node handle）操作，实现容器间元素的高效迁移（如 extract/insert）。
- 需要对 Boost.MultiIndex 的 sequenced_index 进行进一步的元编程扩展。

## 主要接口说明

- `emplace_front` / `emplace_back` / `emplace`  
  支持变参模板和宏展开两种方式，自动适配 Boost 版本和 C++ 标准，原地构造插入元素或在指定位置插入。

- `extract`  
  从序列索引中提取节点，返回节点句柄，便于后续插入到其他容器。

- `insert`  
  支持节点句柄的插入，兼容 Boost 1.74.0 之前的实现。

- `sequenced`  
  直接引入 Boost.MultiIndex 的序列索引类型。

## 示例代码

```cpp
#include <yggr/container/multi_index_sequenced_index.hpp>
#include <boost/multi_index_container.hpp>
#include <string>

struct Person {
    int id;
    std::string name;
};

using namespace yggr::container;
using namespace boost::multi_index;

typedef multi_index_container<
    Person,
    indexed_by<
        sequenced<>
    >
> person_list;

person_list pl;

// 原地构造插入（C++11及以上）
pl.get<0>().emplace_back(1, "Alice");

// 节点提取与插入（Boost 1.74.0及以下）
#if (BOOST_VERSION < 107400)
auto node = extract(pl.get<0>(), pl.get<0>().begin());
insert(pl.get<0>(), pl.get<0>().end(), std::move(node));
#endif
```

## 注意事项

- 该头文件大量使用条件编译和宏，确保在不同 Boost 版本和 C++ 标准下都能正常工作。
- 节点句柄相关操作仅在 Boost 1.74.0 及以下版本有效，1.74.0 及以上请直接使用 Boost 官方接口。
- 依赖 yggdrasil 的预处理宏和类型工具，需确保相关头文件已正确包含。

---

如需更详细的接口说明或特定用法示例，请告知具体需求。