alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是针对 adapter_register_type_def.hpp 文件的文档说明：

---

# 文件：adapter_register_type_def.hpp

## 简介

该头文件定义了 `yggr::adapter::adapter_register_type_def` 结构体，用于适配器注册类型的常量定义。此文件属于 yggdrasil 项目，作者为 xu yang。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发，但需保留版权声明和许可信息。软件按“原样”提供，不附带任何明示或暗示的担保。

## 依赖

- yggrdef.h  
- static_constant.hpp

## 命名空间

- yggr
  - `adapter`

## 结构体：adapter_register_type_def

该结构体定义了四个静态常量，用于标识适配器注册的类型：

| 常量名         | 值           | 说明                   |
| -------------- | ------------ | ---------------------- |
| E_direct       | 0x00000000   | 标记值(无用)           |
| E_to_src       | 0x00000001   | 允许发送到源               |
| E_from_src     | 0x00000002   | 允许从源接收               |
| E_both         | 0x00000003   | 允许收发(E_to_src | E_from_src)|

这些常量可用于适配器注册相关的逻辑判断和类型区分。

## 示例用法

```cpp
#include <yggr/adapter/adapter_register_type_def.hpp>

u32 reg_type = yggr::adapter::adapter_register_type_def::E_both;
if (reg_type == yggr::adapter::adapter_register_type_def::E_both) {
    // 执行双向注册相关操作
}
```

## 结尾

该文件仅包含常量定义，无成员函数或复杂逻辑。适用于需要区分适配器注册类型的场景。

---

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 adapter_parser_helper.hpp 文件的文档说明：

---

# 文件：adapter_parser_helper.hpp

## 简介

该头文件定义了适配器ID解析相关的辅助模板和宏，主要用于统一管理和解析各种ID类型。适用于 yggdrasil 框架中需要对不同ID解析器进行统一封装和类型校验的场景。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发，但需保留版权声明和许可信息。软件按“原样”提供，不附带任何明示或暗示的担保。

## 依赖

- yggrdef.h
- static_assert.hpp
- ids_parsers.hpp
- Boost.TypeTraits（如 `is_same`, `remove_reference`, `remove_const`）

## 命名空间

- yggr
  - `adapter`

## 主要内容

### 1. 模板结构体：adapter_id_parser_def

```cpp
template<
    typename Reg_Send_ID_Parser,
    typename Reg_Recv_ID_Parser,
    typename Send_ID_Parser,
    typename Task_Send_ID_Parser,
    typename Task_Recv_ID_Parser,
    typename Recv_ID_Parser
>
struct adapter_id_parser_def { ... };
```

- 封装了六种ID解析器类型，并通过类型萃取获得对应的ID类型（去除引用和常量修饰）。
- 使用 `BOOST_MPL_ASSERT` 静态断言，确保相关ID类型一致性（如 `reg_send_id_type` 与 `send_id_type` 必须相同）。

### 2. 宏：YGGR_ADAPTER_ID_PARSER_DEF

用于快速定义与 `adapter_id_parser_def` 类似的结构体，并自动添加类型一致性静态断言。

### 3. 模板结构体：adapter_id_parser

```cpp
template<typename TagSend, typename TagRecv, typename Parser_Def>
struct adapter_id_parser { ... };
```

- 封装了发送和接收的标签类型，以及解析器定义类型。
- 内部定义了 `selector` 模板结构体，根据标签类型（发送/接收）选择不同的ID解析逻辑。
- 提供统一的接口方法：
  - `task_id`：获取任务ID
  - `value_id`：获取值ID
  - `reg_value_id`：获取注册值ID

### 4. selector 内部结构体

- 针对 `tag_send` 和 `tag_recv`，分别实现了对应的ID解析方法，便于在不同上下文下调用合适的解析器。

## 示例用法

```cpp
// 假设已定义相关ID解析器类型
typedef yggr::adapter::adapter_id_parser_def<
    MyRegSendIDParser, MyRegRecvIDParser, MySendIDParser,
    MyTaskSendIDParser, MyTaskRecvIDParser, MyRecvIDParser
> my_parser_def;

typedef yggr::adapter::adapter_id_parser<
    MyTagSend, MyTagRecv, my_parser_def
> my_adapter_id_parser;

my_adapter_id_parser parser;
auto id = parser.task_id<MyTagSend>(my_task);
```

## 结尾

本文件为适配器ID解析提供了高度通用和类型安全的辅助工具，适用于需要灵活切换和校验多种ID解析器的复杂场景。

---

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 adapter_mgr.hpp 文件的文档说明：

---

# 文件：adapter_mgr.hpp

## 简介

本头文件实现了 yggdrasil 框架中的适配器管理器（adapter_mgr），用于统一管理数据适配器的注册、注销、发送、接收等操作。通过模板参数实现高度通用性，支持多种数据类型和适配器转换方式，适用于复杂的数据流转和适配场景。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发，但需保留版权声明和许可信息。软件按“原样”提供，不附带任何明示或暗示的担保。

## 依赖

- yggdrasil 基础库（如 yggrdef.h、static_constant.hpp、bind.hpp 等）
- Boost 库（如 shared_mutex、type_traits、multi_index、enable_shared_from_this 等）
- 其他辅助模块（如 safe_container、exception、utility、adapter_parser_helper.hpp、adapter_register_type_def.hpp）

## 命名空间

- yggr
  - `adapter`

## 主要内容

### 1. 适配器基类与实现

- **base_send_adapter / send_adapter**  
  发送适配器基类与实现，负责将标准数据发送到源对象，支持不同数据类型的适配。
- **base_recv_adapter / recv_adapter**  
  接收适配器基类与实现，负责从任务数据中解析结果数据，并支持回调处理。

### 2. 适配器映射（adapter_mapping）

- 用于将发送ID、接收ID与对应的适配器实例（智能指针）进行绑定和管理。
- 支持通过标签（tag_send/tag_recv）访问、交换、合并、清理等操作。

### 3. 注销适配器辅助（unregister_adapter_helper）

- 针对发送ID和接收ID是否相同，分别实现注销逻辑，支持多种注销策略（E_both、E_to_src、E_from_src）。

### 4. 适配器管理器（adapter_mgr）

```cpp
template<
    typename Src,
    typename Send_Std_Data,
    typename Recv_Rst_Data,
    typename ID_Parser_Def,
    template<typename, typename, typename> class Conver,
    typename Mutex = boost::shared_mutex
>
class adapter_mgr;
```

- **主要职责**：
  - 注册/注销适配器（支持单类型、容器类型、指定ID注册等多种方式）
  - 数据发送（send）
  - 数据接收与回调（hold_recv/stop_recv/drop_task/drop_all_tasks）
  - 适配器映射的内部管理（基于 safe_multi_index_container 实现线程安全的多索引管理）
  - 错误处理（内置错误码与异常抛出机制）

- **主要成员类型**：
  - `src_type`：数据源类型
  - `send_std_data_type`：标准发送数据类型
  - `recv_rst_data_type`：接收结果数据类型
  - `id_parser_def_type`：ID 解析器定义
  - `conver_type`：适配器转换器类型
  - `adapter_map_type`：适配器映射容器

- **主要接口**：
  - `register_adapter`：注册适配器
  - `unregister_adapter`：注销适配器
  - `send`：发送数据
  - `hold_recv`：注册接收回调
  - `stop_recv`：停止接收
  - `drop_task`/`drop_all_tasks`：丢弃任务
  - `clear`：清空所有适配器和任务

- **错误处理**：
  - 内置错误码（如 E_invalid_non_reg_adp、E_invalid_not_send）
  - 通过 exception::exception 抛出详细错误信息

### 5. 线程安全

- 适配器映射容器基于 `safe_multi_index_container`，结合 `boost::shared_mutex` 实现多线程安全访问。

## 示例用法

```cpp
// 假设已定义相关类型
typedef yggr::adapter::adapter_mgr<
    MySrc, MySendStdData, MyRecvRstData, MyIDParserDef, MyConver
> my_adapter_mgr;

my_adapter_mgr mgr(src);
mgr.register_adapter<MyRealData>();
mgr.send(data);
mgr.hold_recv(owner_id, handler);
mgr.unregister_adapter<MyRealData>();
mgr.clear();
```

## 结尾

本文件为 yggdrasil 框架提供了强大、灵活且线程安全的适配器管理机制，适用于需要动态注册、注销和调度多种数据适配器的复杂系统。

---
