alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 inc_ver.h 的文档说明：

---

# inc_ver.h 文档

## 文件简介

inc_ver.h 定义了一个自增版本号类 `inc_ver`，用于线程安全地管理和递增64位无符号整数版本号。该类适用于需要版本控制或乐观锁等场景。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- `<yggr/move/move.hpp>`
- `<yggr/mplex/limits.hpp>`
- `<yggr/support/operator_t.hpp>`
- `<boost/ref.hpp>`
- `<boost/atomic.hpp>`

---

## 类定义

### yggr::inc_ver

#### 类型定义

- `value_type`：类型为 `u64`，即 64 位无符号整数。
- `ver_type`：类型为 `boost::atomic<value_type>`，用于原子操作的版本号。
- `numeric_limits_type`：用于获取 `value_type` 的数值极限。

#### 构造与析构

- `inc_ver()`：构造函数，初始化版本号为 0。
- `inc_ver(BOOST_RV_REF(this_type) right)`：移动构造函数。
- `inc_ver(const this_type& right)`：拷贝构造函数。
- `~inc_ver()`：析构函数。

#### 赋值操作

- `operator=(BOOST_RV_REF(this_type) right)`：移动赋值操作符，线程安全地赋值。
- `operator=(const this_type& right)`：拷贝赋值操作符，线程安全地赋值。

#### 主要成员函数

- `u64 grab(void) const`  
  原子性地将版本号加一（若未溢出），返回递增前的版本号。若已达最大值则回绕为 0。

- `u64 now_ver(void) const`  
  获取当前版本号。

- `operator bool(void) const`  
  判断当前版本号是否为非零。

- `operator u64(void) const`  
  隐式转换为 `u64`，返回当前版本号。

#### 成员变量

- `mutable ver_type _ver`  
  版本号，支持原子操作。

---

## 线程安全

所有对 `_ver` 的操作均通过 `boost::atomic` 实现，确保多线程环境下的安全性。

---

## 用法示例

````cpp
#include <yggr/base/inc_ver.h>

yggr::inc_ver ver;
u64 old_ver = ver.grab(); // 递增版本号
u64 current = ver.now_ver(); // 获取当前版本号
if(ver) { /* 版本号非零 */ }
````

---

## 注意事项

- 版本号达到最大值时会回绕为 0。
- 赋值和递增操作均为线程安全。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 random.h 的文档说明：

---

# random.h 文档

## 文件简介

random.h 提供了一个静态随机数生成工具类 `yggr::random`，支持生成整数和浮点数的随机值，并可指定随机数的范围。该实现基于 Boost.Random 库，适用于多种类型的随机数需求。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- `<yggr/mplex/limits.hpp>`
- `<yggr/type_traits/upper_types.hpp>`
- `<yggr/nonable/noncreateable.hpp>`
- `<boost/random/linear_congruential.hpp>`
- `<boost/random/uniform_int.hpp>`
- `<boost/random/uniform_real.hpp>`
- `<boost/random/variate_generator.hpp>`
- `<boost/type_traits/is_floating_point.hpp>`

---

## 命名空间

- yggr
- `yggr::detail`

---

## 主要类与函数

### yggr::random

- **说明**：静态工具类，禁止实例化（继承自 `nonable::noncreateable`）。
- **主要类型**：
  - `base_generator_type`：底层随机数生成器，使用 `boost::minstd_rand`。
- **主要静态方法**：
  - `static void init(void);`  
    初始化随机数生成器（实现未在头文件中给出）。
  - `template<typename T> static T gen_random(void);`  
    生成类型为 T 的随机数，范围为类型的最小值到最大值。
  - `template<typename T> static T gen_random(const T& s_range, const T& e_range);`  
    生成类型为 T 的随机数，范围为 `[s_range, e_range)`。

### 全局函数

- `template<typename T> T gen_random(void);`  
  等价于 `random::gen_random<T>()`。
- `template<typename T> T gen_random(const T& s_range, const T& e_range);`  
  等价于 `random::gen_random(s_range, e_range)`。

---

## 内部实现

### yggr::detail::genner

- 模板类 `genner<T, is_float>` 根据类型 T 是否为浮点数选择不同的随机数分布。
  - 对于浮点数类型，使用 `boost::uniform_real`。
  - 对于整数类型，使用 `boost::uniform_int`。
- 支持无参和带范围的随机数生成。

---

## 用法示例

````cpp
#include <yggr/base/random.h>

// 生成一个 int 类型的随机数
int r1 = yggr::gen_random<int>();

// 生成一个 [10, 100) 范围内的 int 随机数
int r2 = yggr::gen_random<int>(10, 100);

// 生成一个 double 类型的随机数
double r3 = yggr::gen_random<double>();

// 生成一个 [0.5, 2.5) 范围内的 double 随机数
double r4 = yggr::gen_random<double>(0.5, 2.5);
````

---

## 注意事项

- 随机数生成器为静态成员，线程安全性需根据实际使用场景评估。
- 整数范围的随机数生成要求 `s_range < e_range`，且范围在类型允许的最小最大值之间。
- 浮点数范围的随机数生成为左闭右开区间 `[s_range, e_range)`。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `random.h` 的详细中文文档：

---

# random.h 文档

## 文件简介

`random.h` 提供了一个静态随机数生成工具类 `yggr::random`，支持生成整数和浮点数的随机值，并可指定随机数的范围。该实现基于 Boost.Random 库，适用于多种类型的随机数需求。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- `<yggr/mplex/limits.hpp>`
- `<yggr/type_traits/upper_types.hpp>`
- `<yggr/nonable/noncreateable.hpp>`
- `<boost/random/linear_congruential.hpp>`
- `<boost/random/uniform_int.hpp>`
- `<boost/random/uniform_real.hpp>`
- `<boost/random/variate_generator.hpp>`
- `<boost/type_traits/is_floating_point.hpp>`

---

## 命名空间

- yggr
- `yggr::detail`

---

## 主要类与函数

### yggr::random

- **说明**：静态工具类，禁止实例化（继承自 `nonable::noncreateable`）。
- **主要类型**：
  - `base_generator_type`：底层随机数生成器，使用 `boost::minstd_rand`。
- **主要静态方法**：
  - `static void init(void);`  
    初始化随机数生成器（实现未在头文件中给出）。
  - `template<typename T> static T gen_random(void);`  
    生成类型为 T 的随机数，范围为类型的最小值到最大值。
  - `template<typename T> static T gen_random(const T& s_range, const T& e_range);`  
    生成类型为 T 的随机数，范围为 `[s_range, e_range)`。

### 全局函数

- `template<typename T> T gen_random(void);`  
  等价于 `random::gen_random<T>()`。
- `template<typename T> T gen_random(const T& s_range, const T& e_range);`  
  等价于 `random::gen_random(s_range, e_range)`。

---

## 内部实现

### yggr::detail::genner

- 模板类 `genner<T, is_float>` 根据类型 T 是否为浮点数选择不同的随机数分布。
  - 对于浮点数类型，使用 `boost::uniform_real`。
  - 对于整数类型，使用 `boost::uniform_int`。
- 支持无参和带范围的随机数生成。

---

## 用法示例

````cpp
#include <yggr/base/random.h>

// 生成一个 int 类型的随机数
int r1 = yggr::gen_random<int>();

// 生成一个 [10, 100) 范围内的 int 随机数

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 ref_count_info.h 的文档说明：

---

# ref_count_info.h 文档

## 文件简介

ref_count_info.h 提供了一个通用的线程安全引用计数工具模板类 `ref_count_info`，用于管理对象的引用计数，支持原子操作。还提供了引用计数锁辅助类 `ref_count_info_locker` 以及一组便捷的比较操作符重载。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- `<boost/atomic.hpp>`

---

## 命名空间

- yggr

---

## 主要模板类

### yggr::ref_count_info

#### 模板参数

- `Val`：引用计数的数值类型，默认为 `yggr::u64`。

#### 主要类型定义

- `value_type`：引用计数的数值类型。
- `count_type`：`boost::atomic<value_type>`，用于原子操作的计数类型。

#### 构造与析构

- `ref_count_info()`：构造函数，初始化计数为 0。
- `ref_count_info(const this_type& right)`：拷贝构造函数，计数值取自参数对象。
- `~ref_count_info()`：析构函数。

#### 主要成员函数

- `this_type& operator=(const this_type& right)`  
  拷贝赋值，计数值取自参数对象。

- `value_type grab()`  
  原子性地增加计数，返回增加前的计数值。

- `value_type drop()`  
  原子性地减少计数，返回减少前的计数值。

- `void reset()`  
  计数重置为 0。

- `value_type use_count() const`  
  获取当前计数值。

- `bool empty() const`  
  判断计数是否为 0。

#### 成员变量

- `count_type _count`  
  当前引用计数。

---

## 比较操作符重载

支持 `==`, `!=`, `<`, `<=`, `>`, `>=` 六种比较操作，允许 `ref_count_info` 与任意类型或两个 `ref_count_info` 之间直接比较，比较的实际是 `use_count()` 的值。

---

## 辅助结构体

### yggr::ref_count_info_locker

- **模板参数**：`T`，引用计数类型。
- **构造函数**：`ref_count_info_locker(ref_count_type& rc)`，构造时 grab()，析构时 drop()，用于自动管理引用计数的增减，适合作用域锁定。

---

## 用法示例

````cpp
#include <yggr/base/ref_count_info.h>

yggr::ref_count_info<> ref_cnt;
ref_cnt.grab(); // 引用计数+1
ref_cnt.drop(); // 引用计数-1

if(ref_cnt.empty()) { /* 计数为0 */ }

yggr::ref_count_info_locker<yggr::ref_count_info<>> locker(ref_cnt); // 作用域内自动grab/drop
````

---

## 注意事项

- 所有 grab/drop/reset 操作均为原子操作，适合多线程环境。
- 支持与普通数值类型直接比较引用计数。
- `ref_count_info_locker` 适合用于作用域自动管理引用计数。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 yggr_config.h 的文档说明：

---

# yggr_config.h 文档

## 文件简介

yggr_config.h 是 Yggdrasil 工程的全局配置头文件，负责平台、编译器、架构等环境的自动检测与宏定义，并集中管理各类编译选项、兼容性设置和特性开关。该文件是整个工程的基础配置入口，需在包含前确保已包含 `<yggr/base/yggrdef.h>`。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`（必须先包含）
- `<boost/config.hpp>`
- `<yggr/base/version.hpp>`
- `<yggr/base/user_config.hpp>`
- `<yggr/base/yggr_cpp_ver_config.hpp>`
- `<yggr/base/boost_cpp_version_check.hpp>`
- `<yggr/base/script_lua_cfg.hpp>`
- `<yggr/base/script_python_cfg.hpp>`
- `<yggr/base/compiler_config.hpp>`
- `<yggr/base/container_cfg.hpp>`
- `<yggr/base/endian.hpp>`
- `<yggr/base/noexcept_cfg.hpp>`
- `<yggr/base/constexpr_cfg.hpp>`
- `<yggr/base/attribute_cfg.hpp>`
- `<yggr/base/if_constexpr_cfg.hpp>`
- `<yggr/base/cpp17_features_cfg.hpp>`
- `<yggr/base/cpp20_features_cfg.hpp>`

---

## 主要功能

### 1. 编译器与平台检测

自动检测并定义如下宏：

- 编译器相关：`YGGR_MSVC`, `YGGR_GCC`, `YGGR_CLANG`, `YGGR_INTEL`, `YGGR_BORLANDC`, `YGGR_CODEGEARC`, `YGGR_EMBTC`
- 架构相关：`YGGR_ARM`, `YGGR_ARM64`, `YGGR_RISCV`, `YGGR_X86`, `YGGR_X86_64`
- 平台相关：`YGGR_AT_WINDOWS`, `YGGR_AT_LINUX`, `YGGR_AT_DARWIN`, `YGGR_AT_IOS`, `YGGR_AT_ANDROID`, `YGGR_AT_MOBILE`
- 系统位数：`YGGR_SYSTEM_64`

### 2. MSVC 警告转错误

在 MSVC 下，将常见的编译警告提升为错误，保证代码质量（可通过 `YGGR_WARNING_NOT_TO_ERROR` 关闭）。

### 3. 宏定义说明

文件中详细注释了所有可用的编译宏及其作用，包括但不限于：

- 平台与架构相关宏
- 字符串与字符集相关宏
- 文件系统相关宏
- C++ 标准版本相关宏
- 容器与字符串实现选择
- 兼容性与优化开关
- 第三方库（如 OpenSSL、ICU、Lua）相关宏
- 其他工程特性开关

### 4. 平台兼容性处理

- 针对 Android 平台禁用 `std::atomic`，以兼容 Boost.Asio。
- 自动设置 Windows 版本宏 `_WIN32_WINNT`。

### 5. 其他配置

- 包含工程内各类特性、容器、编译器、C++标准、字节序等配置头文件。
- 提供调试辅助宏 `YGGR_DBG_VAR_ERR()`。

---

## 用法说明

- 本文件应在所有 Yggdrasil 工程源码的最前面包含（在 `<yggr/base/yggrdef.h>` 之后）。
- 通过定义或取消定义相关宏，可灵活控制工程的编译特性和兼容性。
- 详细的宏说明可参考文件内注释。

---

## 示例

````cpp
#include <yggr/base/yggrdef.h>
#include <yggr/base/yggr_config.h>

// 根据平台自动定义 YGGR_AT_WINDOWS/YGGR_AT_LINUX 等宏
#ifdef YGGR_AT_WINDOWS
    // Windows 平台相关代码
#endif
````

---

## 注意事项

- 必须先包含 `<yggr/base/yggrdef.h>`，否则会编译报错。
- 本文件为工程全局配置核心，建议不要随意修改，若需自定义配置请在 `user_config.hpp` 中进行。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 yggr_msg_macro.h 的文档说明：

---

# yggr_msg_macro.h 文档

## 文件简介

yggr_msg_macro.h 提供了调试环境下的消息输出宏，主要用于输出性能警告和异常信息。该文件通过条件编译，在 Debug 模式下输出详细信息，在 Release 模式下宏为空操作。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- `<iostream>`（仅 Debug 模式）
- `<string>`（仅 Debug 模式）

---

## 主要宏定义

### __YGGR_MSG_PCRE_WARNING(__msg__)

- **作用**：在 Debug 模式下，将 `__msg__` 作为 PCRE 警告信息输出到标准错误流（`std::cerr`）。
- **Release 模式下**：为空操作。

### __YGGR_MSG_EXCEPTION(__msg__)

- **作用**：在 Debug 模式下，将 `__msg__` 作为异常信息输出到标准错误流（`std::cerr`）。
- **Release 模式下**：为空操作。

### YGGR_MSG_PCRE_WARNING

- **作用**：对 `__YGGR_MSG_PCRE_WARNING` 的别名，便于统一调用。

---

## 用法示例

````cpp
#include <yggr/base/yggr_msg_macro.h>

void foo() {
    YGGR_MSG_PCRE_WARNING("性能警告示例");
    __YGGR_MSG_EXCEPTION("异常信息示例");
}
````

- 在 Debug 模式下，以上代码会输出警告和异常信息到标准错误流。
- 在 Release 模式下，宏不会产生任何输出。

---

## 注意事项

- 仅在 `_DEBUG` 宏定义时（即 Debug 编译）宏才会输出信息。
- 推荐仅用于调试和开发阶段，避免在生产环境依赖这些宏进行日志输出。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 yggrdef.h 的文档说明：

---

# yggrdef.h 文档

## 文件简介

yggrdef.h 是 Yggdrasil 工程的基础类型定义头文件，统一定义了常用的整数、浮点数、字符类型别名，以及与平台相关的指针、序列化等类型。该文件为整个工程提供了类型基础，便于跨平台开发和类型一致性维护。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggr_config.h>`
- `<yggr/base/pragma_message.hpp>`
- `<yggr/base/third_party_issues_config.hpp>`
- `<yggr/base/new.hpp>`
- `<boost/cstdint.hpp>`
- `<cstddef>`

---

## 主要内容

### 1. DLL 导出/导入宏定义（仅 MSVC）

- 处理 `BOOST_SYMBOL_EXPORT` 和 `BOOST_SYMBOL_IMPORT`，用于处理MSVC包含BOOST头文件后EXE输出LIB文件的问题。

### 2. 基础类型别名

在 `namespace yggr` 内定义了如下类型别名：

- **整数类型**
  - `s8`  ：有符号 8 位整数（`boost::int8_t`）
  - `u8`  ：无符号 8 位整数（`boost::uint8_t`）
  - `s16` ：有符号 16 位整数（`boost::int16_t`）
  - `u16` ：无符号 16 位整数（`boost::uint16_t`）
  - `s32` ：有符号 32 位整数（`boost::int32_t`）
  - `u32` ：无符号 32 位整数（`boost::uint32_t`）
  - `s64` ：有符号 64 位整数（`boost::int64_t`）
  - `u64` ：无符号 64 位整数（`boost::uint64_t`）
  - `sint`：有符号 int
  - `uint`：无符号 int

- **浮点类型**
  - `f32` ：32 位浮点数（`float`）
  - `f64` ：64 位浮点数（`double`）

- **字符类型**
  - `c8`  ：8 位字符（`char8_t`，如未禁用）
  - `c16` ：16 位字符（`char16_t`，如未禁用）
  - `c32` ：32 位字符（`char32_t`，如未禁用）

- **指针与序列化相关类型**
  - `size_type`    ：平台相关的无符号整数（32/64 位）
  - `s_size_type`  ：平台相关的有符号整数（32/64 位）
  - `ptr_num_type` ：指针数值类型（32/64 位）
  - `ser_size_type`：序列化用的长度类型（可强制为 32 位）

### 3. 枚举值类型 enum_value_t

- 通过模板 `enum_value_t_maker` 根据枚举类型大小自动选择合适的无符号整数类型（u8/u16/u32/u64）。
- `enum_value_t` 用于统一工程内枚举值的底层类型。

---

## 用法示例

````cpp
#include <yggr/base/yggrdef.h>

yggr::u32 a = 100;
yggr::f64 b = 3.14;
yggr::size_type sz = 1024;
yggr::enum_value_t ev = 1;
````

---

## 注意事项

- 本文件应在所有 Yggdrasil 工程源码的最前面包含。
- 类型定义依赖于 Boost 的定长整数类型，确保跨平台一致性。
- 指针和序列化相关类型会根据平台自动适配 32 位或 64 位。
- 若需自定义类型宽度或禁用某些类型，可通过相关宏控制（如 `YGGR_NO_CHAR8_T`）。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 attribute_cfg.hpp 的文档说明：

---

# attribute_cfg.hpp 文档

## 文件简介

attribute_cfg.hpp 主要用于统一管理和封装 C++ 属性（attribute）相关的宏定义，便于在 Yggdrasil 工程中跨平台、跨编译器地使用如 `[[nodiscard]]`、`[[no_unique_address]]` 等现代 C++ 属性。该文件自动适配 Boost 配置，保证属性宏在不同环境下的兼容性。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`
- `<boost/config.hpp>`
- `<boost/detail/workaround.hpp>`

---

## 主要内容

### 1. 头文件包含保护

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 2. 属性宏定义

- **YGGR_ATTRIBUTE_UNUSED**  
  用于标记未使用的变量或函数，防止编译器警告。若 Boost 支持 `BOOST_ATTRIBUTE_UNUSED`，则定义为空宏。

- **YGGR_ATTRIBUTE_NODISCARD**  
  用于标记函数返回值不可忽略。  
  - 若 Boost 未定义 `BOOST_ATTRIBUTE_NODISCARD`，则为空宏。
  - 若 Boost 定义且编译器支持，则使用 `BOOST_ATTRIBUTE_NODISCARD`。
  - 针对 GCC 7 及以下且非 C++11 的特殊情况，做了兼容处理。

- **YGGR_ATTRIBUTE_NO_UNIQUE_ADDRESS**  
  用于标记成员变量可优化为无唯一地址（C++20 特性）。  
  - 若 Boost 未定义 `BOOST_ATTRIBUTE_NO_UNIQUE_ADDRESS`，则为空宏。
  - 若 Boost 定义，则使用 `BOOST_ATTRIBUTE_NO_UNIQUE_ADDRESS`。

---

## 用法示例

````cpp
#include <yggr/base/attribute_cfg.hpp>

class Foo {
    YGGR_ATTRIBUTE_NO_UNIQUE_ADDRESS int x;
};

YGGR_ATTRIBUTE_NODISCARD int bar();

void func(YGGR_ATTRIBUTE_UNUSED int unused_param) {
    // ...
}
````

---

## 注意事项

- 需先包含 `<yggr/base/yggrdef.h>`，否则编译报错。
- 该文件仅定义属性相关宏，不直接实现功能，需配合实际代码使用。
- 属性宏会根据 Boost 和编译器能力自动适配，保证跨平台兼容性。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 bit_options.hpp 的文档说明：

---

# bit_options.hpp 文档

## 文件简介

bit_options.hpp 提供了一组用于按位操作选项（bit options/flags）的通用模板函数，支持检测、添加、移除、替换等常见位操作。适用于枚举类型或整型作为位掩码的场景，如权限、状态、配置标志等。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`

---

## 命名空间

- yggr

---

## 主要功能与接口

### 检查操作

- `has_bit_options(opts, chk)`  
  检查 `opts` 是否包含 `chk` 指定的所有位（全包含）。

- `has_bit_options_in(opts, chk)`  
  检查 `opts` 是否包含 `chk` 指定的任意一位（部分包含）。

- `check_bit_options(opts, chk)`  
  返回 `opts` 与 `chk` 的按位与结果。

### 移除（擦除）操作

- `erase_bit_options(opts, rm)`  
  从 `opts` 中移除 `rm` 指定的位。

- `erase_bit_options_if_exists(opts, chk, rm)`  
  仅当 `opts` 包含 `chk` 时，移除 `rm` 指定的位。

- `erase_bit_options_if_not_exists(opts, chk, rm)`  
  仅当 `opts` 不包含 `chk` 时，移除 `rm` 指定的位。

- `erase_bit_options_if_in(opts, chk)`  
  仅当 `opts` 与 `chk` 有交集时，移除 `chk` 指定的位。

- `erase_bit_options_if_in(opts, chk, rm)`  
  仅当 `opts` 与 `chk` 有交集时，移除 `rm` 指定的位。

- `erase_bit_options_if_not_in(opts, chk, rm)`  
  仅当 `opts` 与 `chk` 没有交集时，移除 `rm` 指定的位。

### 添加（追加）操作

- `append_bit_options(opts, add)`  
  向 `opts` 添加 `add` 指定的位。

- `append_bit_options_if_exists(opts, chk, add)`  
  仅当 `opts` 包含 `chk` 时，添加 `add` 指定的位。

- `append_bit_options_if_not_exists(opts, chk, add)`  
  仅当 `opts` 不包含 `chk` 时，添加 `add` 指定的位。

- `append_bit_options_if_in(opts, chk)`  
  仅当 `opts` 与 `chk` 有交集时，添加 `chk` 指定的位。

- `append_bit_options_if_not_in(opts, chk)`  
  仅当 `opts` 与 `chk` 没有交集时，添加 `chk` 指定的位。

- `append_bit_options_if_in(opts, chk, add)`  
  仅当 `opts` 与 `chk` 有交集时，添加 `add` 指定的位。

- `append_bit_options_if_not_in(opts, chk, add)`  
  仅当 `opts` 与 `chk` 有交集时，添加 `add` 指定的位。

### 替换操作

- `replace_bit_options(opts, rm, add)`  
  先移除 `rm` 指定的位，再添加 `add` 指定的位。

- `replace_bit_options_if_exists(opts, chk, add)`  
  仅当 `opts` 包含 `chk` 时，替换为 `add` 指定的位。

- `replace_bit_options_if_exists(opts, chk, rm, add)`  
  仅当 `opts` 包含 `chk` 时，移除 `rm` 并添加 `add`。

- `replace_bit_options_if_not_exists(opts, chk, rm, add)`  
  仅当 `opts` 不包含 `chk` 时，移除 `rm` 并添加 `add`。

- `replace_bit_options_if_in(opts, chk, add)`  
  仅当 `opts` 与 `chk` 有交集时，替换为 `add`。

- `replace_bit_options_if_not_in(opts, chk, add)`  
  仅当 `opts` 与 `chk` 有交集时，替换为 `add`。

- `replace_bit_options_if_in(opts, chk, rm, add)`  
  仅当 `opts` 与 `chk` 有交集时，移除 `rm` 并添加 `add`。

- `replace_bit_options_if_not_in(opts, chk, rm, add)`  
  仅当 `opts` 与 `chk` 没有交集时，移除 `rm` 并添加 `add`。

---

## 用法示例

````cpp
#include <yggr/base/bit_options.hpp>

enum MyFlags {
    FLAG_A = 0x01,
    FLAG_B = 0x02,
    FLAG_C = 0x04
};

int opts = FLAG_A | FLAG_B;

if (yggr::has_bit_options(opts, FLAG_A)) {
    opts = yggr::erase_bit_options(opts, FLAG_A);
}

opts = yggr::append_bit_options(opts, FLAG_C);
````

---

## 注意事项

- 所有函数均为模板，适用于整型、枚举等支持位运算的类型。
- 返回值均为新值，不会修改原参数。
- 推荐用于位掩码、标志位等场景，提升代码可读性和复用性。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 boost_cpp_version_check.hpp 的文档说明：

---

# boost_cpp_version_check.hpp 文档

## 文件简介

boost_cpp_version_check.hpp 用于在编译期间检测 Boost 版本与 C++ 标准版本的兼容性，防止因 Boost 版本过低或 C++ 标准过高导致的编译或运行时问题。该文件会在不兼容时直接报错或给出编译警告。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<boost/config/pragma_message.hpp>`
- 必须先包含 `<yggr/base/yggrdef.h>`

---

## 主要功能

### 1. 头文件包含保护

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 2. C++ 标准与 Boost 版本兼容性检查

- **C++17 检查**  
  - 如果当前 C++ 标准高于 C++14（即 C++17 及以上），且 Boost 版本低于 1.66.0，则编译报错：  
    “boost 1.53.0 - boost 1.65.1 not support cpp17 and later”

- **C++20 检查**  
  - 如果当前 C++ 标准高于 C++17（即 C++20 及以上），且 Boost 版本低于 1.82.0，则编译时给出警告：  
    “boost 1.66.0 - boost 1.81.0 not recommend using cpp20”

- **C++23 检查**  
  - 如果当前 C++ 标准高于 C++20（即 C++23 及以上），则直接编译报错：  
    “yggdrail has not been tested for cpp23 support”

---

## 用法说明

- 本文件会在工程编译初期自动检测 Boost 和 C++ 标准的兼容性，确保开发环境安全。
- 不建议在未通过检测的环境下继续开发或部署。

---

## 注意事项

- 必须先包含 `<yggr/base/yggrdef.h>`，否则会编译报错。
- 若需支持更高版本的 C++ 标准，请确保 Boost 版本满足要求，并根据提示升级 Boost。
- 若遇到编译警告或错误，请根据提示调整 Boost 版本或 C++ 标准。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 compiler_config.hpp 的文档说明：

---

# compiler_config.hpp 文档

## 文件简介

compiler_config.hpp 负责根据编译器、C++标准版本和 Boost 配置，自动检测和定义一系列兼容性宏。该文件用于屏蔽不同编译器和标准下的特性差异，保证 Yggdrasil 工程在多平台、多编译器环境下的可移植性和稳定性。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`
- 依赖 Boost 配置相关宏

---

## 主要内容

### 1. 头文件包含保护

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 2. MSVC 安全警告屏蔽

- 对于 MSVC 2012 及以上版本，自动定义 `_SCL_SECURE_NO_WARNINGS`，屏蔽部分安全警告。

### 3. auto_ptr 支持检测

- C++17 及以上标准下，自动禁用 `auto_ptr`，定义 `YGGR_NO_AUTO_PTR` 和 `BOOST_NO_AUTO_PTR`。

### 4. 字符类型与字符串支持检测

- 检测并定义如下宏，适配不同标准和编译器对宽字符、UTF 字符类型的支持：
  - `YGGR_NO_CWCHAR`, `BOOST_NO_CWCHAR`：不支持宽字符头文件
  - `YGGR_NO_WSTRING`, `BOOST_NO_STD_WSTRING`：不支持宽字符串
  - `YGGR_NO_CHAR8_T`, `YGGR_NO_U8STRING_T`：不支持 `char8_t` 和 `u8string`
  - `YGGR_NO_CHAR16_T`, `YGGR_NO_U16STRING_T`：不支持 `char16_t` 和 `u16string`
  - `YGGR_NO_CHAR32_T`, `YGGR_NO_U32STRING_T`：不支持 `char32_t` 和 `u32string`
- 针对 Apple Clang 特定版本和 C++20 做了特殊兼容处理。

### 5. 容器特性支持检测

- 检测并定义如下容器相关宏：
  - `YGGR_NO_CXX11_HDR_ARRAY`：不支持 `<array>`
  - `YGGR_NO_CXX11_HDR_UNORDERED_SET`：不支持 `<unordered_set>`
  - `YGGR_NO_CXX11_HDR_UNORDERED_MAP`：不支持 `<unordered_map>`
  - `YGGR_NO_CXX11_STD_UNORDERED`：不支持 C++11 标准库 unordered 容器
  - `YGGR_HAS_CXX11_STD_HASH`：支持 C++11 标准库 hash

### 6. 语言特性支持检测

- 检测并定义如下语言特性相关宏：
  - `YGGR_NO_CXX11_VARIADIC_TEMPLATES`, `YGGR_NO_CXX14_VARIADIC_TEMPLATES`：不支持可变参数模板
  - `YGGR_NO_CXX11_DECLTYPE`：不支持 `decltype`
  - `YGGR_NO_CXX11_VARIADIC_MACROS`：不支持可变参数宏
  - `YGGR_NO_CXX11_HDR_INITIALIZER_LIST`：不支持 `<initializer_list>`
  - `YGGR_NO_CXX11_SMART_PTR`：不支持 C++11 智能指针
  - `YGGR_NO_CXX11_HDR_TUPLE`：不支持 `<tuple>`

---

## 用法说明

- 本文件会在工程编译初期自动检测编译器和标准特性，定义相关兼容性宏，供后续代码条件编译使用。
- 通过这些宏，可以安全地在不同平台和标准下屏蔽或启用特定特性。

---

## 注意事项

- 必须先包含 `<yggr/base/yggrdef.h>`，否则会编译报错。
- 不建议手动修改这些宏，若需自定义兼容性配置，请在更高层的配置文件中处理。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 constexpr_cfg.hpp 的文档说明：

---

# constexpr_cfg.hpp 文档

## 文件简介

constexpr_cfg.hpp 负责根据 Boost 版本、C++ 标准版本和编译器能力，自动检测并定义一组与 `constexpr` 相关的宏。通过这些宏，可以在 Yggdrasil 工程中跨平台、跨标准地安全使用 `constexpr`，并兼容不同 C++ 版本的特性。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`
- `<boost/config.hpp>`
- `<yggr/base/yggr_cpp_ver_config.hpp>`

---

## 主要内容

### 1. 头文件包含保护

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 2. constexpr 支持检测与宏定义

- 根据 Boost 版本和 `BOOST_NO_CONSTEXPR`，自动检测是否支持 `constexpr`。
- 若不支持，则定义 `YGGR_NO_CONSTEXPR`，并将所有相关宏降级为 `inline`、`const` 或 `static`。
- 若支持，则根据 Boost 或标准定义，自动适配 `constexpr` 相关宏。

#### 主要宏

- `YGGR_CONSTEXPR`  
  标记为 `constexpr` 或降级为 `inline`。

- `YGGR_CONSTEXPR_OR_INLINE`  
  支持 `constexpr` 时为 `constexpr`，否则为 `inline`。

- `YGGR_STATIC_CONSTEXPR_OR_INLINE_STATIC`  
  支持 `constexpr` 时为 `static constexpr`，否则为 `inline static`。

- `YGGR_CONSTEXPR_OR_CONST`  
  支持 `constexpr` 时为 `constexpr`，否则为 `const`。

- `YGGR_CONSTEXPR_OR_STATIC`  
  支持 `constexpr` 时为 `constexpr`，否则为 `static`。

- `YGGR_CONSTEXPR_OR_STATIC_CONST`  
  支持 `constexpr` 时为 `constexpr`，否则为 `static const`。

### 3. 针对不同 C++ 标准的 constexpr 宏

- 针对 C++11、C++14、C++17、C++20、C++23，分别定义了对应的 `YGGR_CXX??_CONSTEXPR` 及其变体宏。
- 若当前标准支持，则为 `constexpr`，否则降级为 `inline`、`const`、`static` 等。
- 对于 C++20/C++23，若支持 `__cpp_lib_constexpr_dynamic_alloc` 且非 Clang，则可用 `constexpr`，否则降级。

---

## 用法示例

````cpp
#include <yggr/base/constexpr_cfg.hpp>

YGGR_CONSTEXPR int foo(int x) { return x + 1; }

struct Bar {
    YGGR_STATIC_CONSTEXPR_OR_INLINE_STATIC int value = 42;
};
````

---

## 注意事项

- 需先包含 `<yggr/base/yggrdef.h>`，否则编译报错。
- 推荐使用这些宏替代直接写 `constexpr`，以保证跨平台和跨标准兼容性。
- 宏会根据实际编译环境自动适配，避免因标准或 Boost 版本不支持而导致的编译错误。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 container_cfg.hpp 的文档说明：

---

# container_cfg.hpp 文档

## 文件简介

container_cfg.hpp 用于配置和适配 Yggdrasil 工程中容器相关的兼容性宏和内联优化宏。该文件根据编译器、Boost 版本等环境，自动检测并定义容器特性支持情况，以及为容器相关代码提供可控的内联/非内联宏，提升跨平台兼容性和性能调优能力。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`
- 依赖 Boost 相关宏

---

## 主要内容

### 1. 头文件包含保护

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 2. 容器特性支持检测

- 针对 MSVC 1800（VS2013）以下版本，自动禁用 C++11 标准库的 `unordered_set`、`unordered_map`，并定义：
  - `YGGR_NO_CXX11_HDR_UNORDERED_SET`
  - `YGGR_NO_CXX11_HDR_UNORDERED_MAP`
  - `YGGR_NO_CXX11_STD_UNORDERED`

### 3. 容器内联/非内联宏定义

- 当 Boost 版本大于等于 1.62.0 时，支持如下宏（可通过注释/定义控制）：
  - `YGGR_CONTAINER_FORCEINLINE`  
    控制容器相关函数的强制内联。根据不同编译器和宏定义自动适配为 `inline`、`BOOST_FORCEINLINE` 或空。
  - `YGGR_CONTAINER_CONSTRUCT_FORCEINLINE`  
    构造相关函数的强制内联，等价于 `YGGR_CONTAINER_FORCEINLINE`。
  - `YGGR_CONTAINER_NOINLINE`  
    控制容器相关函数的非内联。可通过 `YGGR_CONTAINER_DISABLE_NOINLINE` 控制，默认等价于 `BOOST_FORCEINLINE` 或空。

- 若 Boost 版本低于 1.62.0，则上述宏均为空。

---

## 用法示例

````cpp
#include <yggr/base/container_cfg.hpp>

class MyContainer {
public:
    YGGR_CONTAINER_FORCEINLINE void fast_func() { /* ... */ }
    YGGR_CONTAINER_NOINLINE void slow_func() { /* ... */ }
};
````

---

## 注意事项

- 推荐在所有自定义容器或与容器相关的性能敏感代码中使用这些宏，便于后续统一调整和跨平台兼容。
- 宏的具体行为会根据编译器、Boost 版本和相关宏定义自动适配，无需手动干预。
- 若需强制禁用/启用内联，可通过定义 `YGGR_CONTAINER_DISABLE_FORCEINLINE` 或 `YGGR_CONTAINER_FORCEINLINE_IS_BOOST_FORCELINE` 等宏实现。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 cpp17_features_cfg.hpp 的文档说明：

---

# cpp17_features_cfg.hpp 文档

## 文件简介

cpp17_features_cfg.hpp 负责检测和配置 C++17 相关标准库特性的可用性，主要用于判断 `<string_view>` 等 C++17 新增头文件和特性的支持情况，并定义相应的兼容性宏。该文件确保 Yggdrasil 工程在不同编译器、标准库和 Boost 版本下对 C++17 特性的正确适配。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`
- 依赖 Boost 配置相关宏

---

## 主要内容

### 1. 头文件包含保护

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 2. C++17 `<string_view>` 支持检测

- 通过多重条件判断当前编译环境是否支持 `<string_view>`，并定义宏：
  - `YGGR_NO_CXX17_HDR_STRING_VIEW`：不支持 `<string_view>`
  - `BOOST_NO_CXX17_HDR_STRING_VIEW`：Boost 不支持 `<string_view>`
- 检查内容包括：
  - C++ 标准版本是否大于等于 C++17
  - 是否存在 `<string_view>` 头文件
  - 标准库和编译器版本（如 MSVC、libc++、libstdc++ 等）
  - Boost 对 `<string_view>` 的支持情况

### 3. C++98 function_base 支持检测

- 检查并定义：
  - `YGGR_NO_CXX98_FUNCTION_BASE`：不支持 C++98 function_base
- 主要针对 MSVC 2017 及以上，若 `_HAS_AUTO_PTR_ETC == 0`，则禁用 C++98 function_base。

---

## 用法说明

- 通过检测宏 `YGGR_NO_CXX17_HDR_STRING_VIEW`，可在代码中安全判断是否可以使用 `<string_view>`，避免因环境不支持导致的编译错误。
- 通过检测宏 `YGGR_NO_CXX98_FUNCTION_BASE`，可判断是否需要规避 C++98 function_base 相关代码。

````cpp
#ifndef YGGR_NO_CXX17_HDR_STRING_VIEW
#include <string_view>
#endif
````

---

## 注意事项

- 推荐所有涉及 C++17 新特性的代码均通过这些宏进行条件编译，保证跨平台和跨标准兼容性。
- 宏的具体定义会根据编译器、标准库和 Boost 版本自动适配，无需手动干预。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 cpp20_features_cfg.hpp 的文档说明：

---

# cpp20_features_cfg.hpp 文档

## 文件简介

cpp20_features_cfg.hpp 负责检测和配置 C++20 相关标准库特性的可用性，主要用于判断 C++98 绑定器（binders）等旧特性在 C++20 及以上环境下的支持情况，并定义相应的兼容性宏。该文件确保 Yggdrasil 工程在不同编译器、标准库和 Boost 版本下对 C++20 特性的正确适配。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`
- 依赖 Boost 配置相关宏

---

## 主要内容

### 1. 头文件包含保护

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 2. C++98 Binders（绑定器）支持检测

- 检查 Boost 是否定义了 `BOOST_NO_CXX98_BINDERS`。
- 若未定义，则进一步检测 MSVC 标准库版本（`_CPPLIB_VER`）：
  - 若 `_CPPLIB_VER >= 650`（即 Visual Studio 2015 及以上），并且：
    - `_HAS_AUTO_PTR_ETC == 0`，则定义 `YGGR_NO_CXX98_BINDERS`
    - 或 `_HAS_DEPRECATED_ADAPTOR_TYPEDEFS == 0`，则定义 `YGGR_NO_CXX98_BINDERS`
- 若 Boost 已定义 `BOOST_NO_CXX98_BINDERS`，则直接定义 `YGGR_NO_CXX98_BINDERS`。

### 3. 预留扩展

- 文件末尾注释 `// append other...`，用于后续扩展更多 C++20 特性检测与宏定义。

---

## 用法说明

- 通过检测宏 `YGGR_NO_CXX98_BINDERS`，可在代码中安全判断是否可以使用 C++98 绑定器（如 `std::bind1st`、`std::bind2nd` 等），避免因环境不支持导致的编译错误。

````cpp
#ifndef YGGR_NO_CXX98_BINDERS
#include <functional> // 可安全使用 C++98 绑定器
#endif
````

---

## 注意事项

- 推荐所有涉及 C++98 绑定器等旧特性的代码均通过这些宏进行条件编译，保证跨平台和跨标准兼容性。
- 宏的具体定义会根据编译器、标准库和 Boost 版本自动适配，无需手动干预。
- 该文件为 C++20 及以后特性适配的基础，可根据实际需求扩展更多特性检测。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 endian.hpp 的文档说明：

---

# endian.hpp 文档

## 文件简介

endian.hpp 用于检测和定义当前平台的字节序（Endian），为 Yggdrasil 工程提供统一的字节序宏。通过适配不同 Boost 版本的字节序检测机制，自动定义大端、小端、PDP端等相关宏，便于跨平台处理二进制数据的序列化、网络传输等场景。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`
- Boost 1.69.0 及以下：`<boost/detail/endian.hpp>`
- Boost 1.69.0 及以上：`<boost/predef/other/endian.h>`

---

## 主要内容

### 1. 头文件包含保护

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 2. 字节序宏定义（兼容不同 Boost 版本）

#### Boost 1.69.0 及以下

- 通过 endian.hpp 检测并定义：
  - `YGGR_BIG_ENDIAN`：大端字节序
  - `YGGR_LITTLE_ENDIAN`：小端字节序
  - `YGGR_PDP_ENDIAN`：PDP 字节序
  - `YGGR_BYTE_ORDER`：字节序数值（如 4321、1234、2143）

#### Boost 1.69.0 及以上

- 通过 `boost/predef/other/endian.h` 检测并定义：
  - `YGGR_BIG_ENDIAN`：大端字节序（`BOOST_ENDIAN_BIG_BYTE`）
  - `YGGR_LITTLE_ENDIAN`：小端字节序（`BOOST_ENDIAN_LITTLE_BYTE`）
  - `YGGR_PDP_ENDIAN`：PDP 字节序（`BOOST_ENDIAN_LITTLE_WORD`）
  - `YGGR_BYTE_ORDER`：字节序数值（4321、1234、2134）

---

## 用法说明

- 通过检测宏 `YGGR_BIG_ENDIAN`、`YGGR_LITTLE_ENDIAN`、`YGGR_PDP_ENDIAN`，可在代码中安全判断当前平台字节序，进行字节序相关处理。
- `YGGR_BYTE_ORDER` 提供了数值型的字节序标识，便于条件编译或运行时判断。

````cpp
#if defined(YGGR_BIG_ENDIAN)
// 大端处理
#elif defined(YGGR_LITTLE_ENDIAN)
// 小端处理
#endif
````

---

## 注意事项

- 推荐所有涉及二进制数据处理、网络通信、文件序列化等场景均通过这些宏进行字节序判断，保证跨平台兼容性。
- 宏的具体定义会根据 Boost 版本自动适配，无需手动干预。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 error_make.hpp 的文档说明：

---

# error_make.hpp 文档

## 文件简介

error_make.hpp 提供了一套用于快速定义错误码枚举和错误信息生成器的宏工具。通过这些宏，可以方便地为类或模块批量定义错误码、错误消息，并自动生成统一的错误对象，提升错误处理的规范性和开发效率。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- `<yggr/base/error.hpp>`

---

## 主要内容

### 1. 错误码定义相关宏

- `ERROR_CODE_DEF(__code__)`  
  定义单个错误码枚举项。

- `ERROR_CODE_KEY_VAL_DEF(__key__, __val__)`  
  定义带指定值的错误码枚举项。

- `ERROR_CODE_DEF_BEGIN(__s_code__)`  
  错误码枚举定义起始，指定起始值（含 `E_success` 和 `E_code_start`）。

- `ERROR_CODE_DEF_NON_CODE_BEGIN()`

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 error_make.hpp 的文档说明：

---

# error_make.hpp 文档

## 文件简介

error_make.hpp 提供了一套用于快速定义错误码枚举和错误消息生成器的宏工具，简化错误码管理和错误信息构造流程。通过这些宏，可以方便地为类或模块批量定义错误码、错误消息，并自动生成统一的错误对象，提升代码一致性和可维护性。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- `<yggr/base/error.hpp>`

---

## 主要内容

### 1. 错误码定义相关宏

- `ERROR_CODE_DEF(__code__)`  
  定义单个错误码枚举项。

- `ERROR_CODE_KEY_VAL_DEF(__key__, __val__)`  
  定义带指定值的错误码枚举项。

- `ERROR_CODE_DEF_BEGIN(__s_code__)`  
  错误码枚举定义起始，指定起始值。

- `ERROR_CODE_DEF_NON_CODE_BEGIN()`  
  错误码枚举定义起始（无起始值）。

- `ERROR_CODE_DEF_END(__e_code__)`  
  错误码枚举定义结束，指定结束值。

- `ERROR_CODE_DEF_NON_CODE_END()`  
  错误码枚举定义结束（无结束值）。

### 2. 错误消息生成相关宏

- `ERROR_CODE_MSG(__code__, __msg__)`  
  为指定错误码添加错误消息分支。

- `ERROR_CODE_MSG_BEGIN()`  
  错误消息生成函数定义起始，自动生成 `make_error` 静态方法。

- `ERROR_CODE_MSG_END()`  
  错误消息生成函数定义结束，处理未知错误码。

### 3. 错误生成器类宏

- `ERROR_MAKER_BEGIN(__class_name__)`  
  错误生成器类定义起始，指定类名。

- `ERROR_MAKER_END()`  
  错误生成器类定义结束。

- `ERROR_MAKE_NON(__class_name__)`  
  定义一个无错误码的默认错误生成器。

---

## 用法示例

````cpp
class MyClass {
    ERROR_MAKER_BEGIN("MyClass")
        ERROR_CODE_DEF_BEGIN(1000)
            ERROR_CODE_DEF(E_error1)
            ERROR_CODE_KEY_VAL_DEF(E_error2, 1002)
        ERROR_CODE_DEF_END(1999)
        ERROR_CODE_MSG_BEGIN()
            ERROR_CODE_MSG(E_error1, "错误1描述")
            ERROR_CODE_MSG(E_error2, "错误2描述")
        ERROR_CODE_MSG_END()
    ERROR_MAKER_END()
};
````

- 这样会自动生成错误码枚举和 `make_error` 静态方法，可用于统一创建带有详细消息的错误对象。

---

## 注意事项

- 错误码枚举项需在 `ERROR_CODE_DEF_BEGIN` 和 `ERROR_CODE_DEF_END` 之间定义。
- 错误消息分支需在 `ERROR_CODE_MSG_BEGIN` 和 `ERROR_CODE_MSG_END` 之间定义。
- 推荐每个模块或类单独定义一套错误码和错误生成器，便于定位和维护。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 error.hpp 的文档说明：

---

# error.hpp 文档

## 文件简介

error.hpp 定义了 Yggdrasil 工程通用的错误对象类 `yggr::error`，用于封装错误码与错误信息，并支持拷贝、移动、交换等操作。该类便于在工程中统一管理和传递错误状态，支持与标准输出流集成，便于调试和日志记录。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- `<yggr/base/static_constant.hpp>`
- `<yggr/move/move.hpp>`
- `<yggr/utility/copy_or_move_or_swap.hpp>`
- `<yggr/support/operator_t.hpp>`
- `<ostream>`
- `<string>`

---

## 命名空间

- yggr

---

## 主要类

### yggr::error

#### 类型定义

- `err_string_type`：错误消息字符串类型，等价于 `std::string`。

#### 静态常量

- `E_unknown_error`：未知错误码，值为 `0xffffffff`。

#### 构造与析构

- `error()`  
  默认构造函数，错误码为 0，消息为空。
- `error(u32 code)`  
  指定错误码构造，消息为空。
- `error(u32 code, const err_string_type& msg)`  
  指定错误码和消息构造。
- `error(u32 code, const err_string_type& class_name, const err_string_type& other_msg, const err_string_type& msg)`  
  指定错误码、类名、附加消息和主消息构造。
- `error(const error& right)`  
  拷贝构造函数。
- `error(BOOST_RV_REF(error) right)`  
  移动构造函数。
- `~error()`  
  析构函数。

#### 赋值与交换

- `error& operator=(const error& right)`  
  拷贝赋值。
- `error& operator=(BOOST_RV_REF(error) right)`  
  移动赋值。
- `void swap(error& right)`  
  与另一个 `error` 对象交换内容。
- `void swap(BOOST_RV_REF(error) right)`  
  与右值 `error` 对象交换内容。

#### 成员函数

- `u32 code() const`  
  获取错误码。
- `const err_string_type& message() const`  
  获取错误消息。
- `const err_string_type& what() const`  
  获取错误消息（等价于 `message()`）。
- `explicit operator bool() const`  
  判断错误对象是否有效（错误码非 0 时为真）。

---

## 运算符重载

- `operator<<`  
  支持将 `error` 对象输出到标准输出流，格式为：
  ```
  code: <错误码>
  msg: <错误消息>
  ```

---

## 用法示例

````cpp
#include <yggr/base/error.hpp>

yggr::error err1; // 默认无错误
yggr::error err2(1001, "文件未找到");
if (err2) {
    std::cout << err2 << std::endl;
}
````

---

## 注意事项

- 错误码为 0 时，`error` 对象视为无错误。
- 支持拷贝、移动和交换，适合在容器、函数返回值等多种场景下使用。
- 推荐配合 `error_make.hpp` 的宏工具批量定义错误码和错误消息。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 if_constexpr_cfg.hpp 的文档说明：

---

# if_constexpr_cfg.hpp 文档

## 文件简介

if_constexpr_cfg.hpp 用于自动检测当前编译环境是否支持 C++17 的 `if constexpr` 语法，并定义一组兼容性宏。通过这些宏，Yggdrasil 工程可以在不同 C++ 标准下安全地使用条件编译，保证代码既能利用新标准特性，也能兼容旧标准。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`
- `<boost/config.hpp>`
- `<yggr/base/yggr_cpp_ver_config.hpp>`

---

## 主要内容

### 1. 头文件包含保护

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 2. if constexpr 兼容性宏定义

- 检测当前 C++ 标准版本和 Boost 能力，若支持 C++17 的 `if constexpr`，则定义：
  - `YGGR_IF_CONSTEXPR` 为 `if constexpr`
  - `YGGR_CPP17_IF_CONSTEXPR` 为 `if constexpr`
- 否则，降级为普通 `if`，保证旧标准下代码可编译。

### 3. 针对 C++20/C++23 的 if constexpr 宏

- `YGGR_CPP20_IF_CONSTEXPR`  
  - C++20 及以上为 `if constexpr`，否则为 `if`
- `YGGR_CPP23_IF_CONSTEXPR`  
  - C++23 及以上为 `if constexpr`，否则为 `if`

---

## 用法示例

````cpp
#include <yggr/base/if_constexpr_cfg.hpp>

template<typename T>
void foo(const T& val) {
    YGGR_IF_CONSTEXPR (std::is_integral<T>::value) {
        // 编译期分支：T为整型
    } else {
        // 其他类型
    }
}
````

---

## 注意事项

- 推荐所有需要 `if constexpr` 的代码均通过这些宏进行条件编译，保证跨平台和跨标准兼容性。
- 宏会根据实际编译环境自动适配，无需手动干预。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 new.hpp 的文档说明：

---

# new.hpp 文档

## 文件简介

new.hpp 为 Yggdrasil 工程提供了统一的 `new` 运算符宏定义，便于跨平台、跨标准地使用普通和不抛异常的 `new`。通过宏 `yggr_new` 和 `yggr_nothrow_new`，可以简化内存分配代码，并提升代码可读性和可维护性。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<new>`（C++ 标准头文件，提供 `std::nothrow`）

---

## 主要内容

### 1. 宏定义

- `yggr_new`  
  等价于标准的 `new` 运算符，用于普通内存分配。

- `yggr_nothrow_new`  
  等价于 `new (std::nothrow)`，用于不抛出异常的内存分配（分配失败时返回 `nullptr` 而不是抛出异常）。

### 2. 命名空间

- `namespace yggr { }`  
  预留命名空间，便于后续扩展。

---

## 用法示例

````cpp
#include <yggr/base/new.hpp>

int* p1 = yggr_new int;                // 普通new
int* p2 = yggr_nothrow_new int;        // 不抛异常的new

if (!p2) {
    // 分配失败处理
}
````

---

## 注意事项

- 推荐在 Yggdrasil 工程中统一使用 `yggr_new` 和 `yggr_nothrow_new`，便于后续全局替换或自定义内存分配策略。
- `yggr_nothrow_new` 分配失败时返回 `nullptr`，不会抛出 `std::bad_alloc` 异常。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 noexcept_cfg.hpp 的文档说明：

---

# noexcept_cfg.hpp 文档

## 文件简介

noexcept_cfg.hpp 负责根据 Boost 配置、C++ 标准版本和编译器能力，自动检测并定义一组与 `noexcept` 相关的宏。通过这些宏，Yggdrasil 工程可以在不同 C++ 标准下安全地使用 `noexcept`，并兼容旧标准或不支持 `noexcept` 的环境。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`
- `<boost/config.hpp>`
- `<yggr/base/yggr_cpp_ver_config.hpp>`

---

## 主要内容

### 1. 头文件包含保护

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 2. noexcept 支持检测与宏定义

- 检测 Boost 是否定义 `BOOST_NO_CXX11_NOEXCEPT`，若不支持 `noexcept`，则：
  - 定义 `YGGR_NO_CXX11_NOEXCEPT`
  - `YGGR_NOEXCEPT` 为空
  - `YGGR_NOEXCEPT_OR_NOTHROW` 为 `throw()`
  - `YGGR_NOEXCEPT_IF(Predicate)` 为空
  - `YGGR_NOEXCEPT_EXPR(Expression)` 为 `false`
- 若支持 `noexcept`，则：
  - `YGGR_NOEXCEPT` 为 `noexcept`
  - `YGGR_NOEXCEPT_OR_NOTHROW` 为 `noexcept`
  - `YGGR_NOEXCEPT_IF(Predicate)` 为 `noexcept((Predicate))`
  - `YGGR_NOEXCEPT_EXPR(Expression)` 为 `noexcept((Expression))`

### 3. 针对不同 C++ 标准的 noexcept 宏

- 针对 C++11、C++14、C++17、C++20、C++23，分别定义了对应的 `YGGR_CXX??_NOEXCEPT` 及其变体宏。
- 若当前标准支持，则为 `YGGR_NOEXCEPT`，否则为空。
- 变体包括：
  - `YGGR_CXX??_NOEXCEPT_OR_NOTHROW`
  - `YGGR_CXX??_NOEXCEPT_IF(Predicate)`
  - `YGGR_CXX??_NOEXCEPT_EXPR(Expression)`

---

## 用法示例

````cpp
#include <yggr/base/noexcept_cfg.hpp>

void foo() YGGR_NOEXCEPT;
void bar() YGGR_CXX17_NOEXCEPT_OR_NOTHROW;
template<typename T>
void baz() YGGR_NOEXCEPT_IF(std::is_nothrow_move_constructible<T>::value);
````

---

## 注意事项

- 推荐所有需要 `noexcept` 的代码均通过这些宏进行条件编译，保证跨平台和跨标准兼容性。
- 宏会根据实际编译环境自动适配，无需手动干预。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 obj_creator.hpp 的文档说明：

---

# obj_creator.hpp 文档

## 文件简介

obj_creator.hpp 提供了一个通用的对象静态工厂模板 `yggr::obj_creator`，用于统一和简化对象的创建流程。支持普通对象和 `void` 特化，兼容 C++11 可变参数模板和旧标准下的多参数构造。还提供了便捷的全局工厂函数接口，适合在泛型编程、工厂模式、单例等场景下使用。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- `<yggr/nonable/noncreateable.hpp>`
- `<yggr/ppex/foo_params.hpp>`
- `<boost/type_traits/add_reference.hpp>`
- `<boost/type_traits/add_const.hpp>`
- Boost 预处理器相关宏

---

## 命名空间

- yggr

---

## 主要类与接口

### 1. 模板类 `yggr::obj_creator<T>`

- **功能**：禁止实例化，仅提供静态成员函数用于对象创建。
- **类型定义**：
  - `value_type`：对象类型 `T`
  - `reference_type`：`T&`
  - `const_reference_type`：`const T&`
  - `create_result_type`：返回值类型（一般为 `T`）
  - `static_create_result_type`：静态对象返回类型（`T&`）
  - `static_const_create_result_type`：静态常量对象返回类型（`const T&`）

- **主要静态成员函数**：
  - `create(...)`  
    创建一个临时对象并返回（按值返回）。
  - `static_create(...)`  
    创建或返回一个静态对象（单例），返回引用。
  - `static_const_create(...)`  
    创建或返回一个静态常量对象，返回常量引用。

- **参数支持**：
  - C++11 及以上：支持任意参数个数（可变参数模板）。
  - 旧标准：通过 Boost 预处理器宏支持多参数重载。

### 2. `yggr::obj_creator<void>` 特化

- 针对 `void` 类型的特化，所有成员函数均为空实现（用于泛型兼容）。

### 3. 全局工厂函数

- `create_object<T>(...)`  
  等价于 `obj_creator<T>::create(...)`
- `static_create_object<T>(...)`  
  等价于 `obj_creator<T>::static_create(...)`
- `static_const_create_object<T>(...)`  
  等价于 `obj_creator<T>::static_const_create(...)`
- 支持可变参数模板或多参数重载。

---

## 用法示例

````cpp
#include <yggr/base/obj_creator.hpp>

struct Foo {
    Foo(int a, double b) : x(a), y(b) {}
    int x;
    double y;
};

// 创建临时对象
Foo f = yggr::obj_creator<Foo>::create(1, 2.0);

// 获取静态对象（单例）
Foo& f_static = yggr::obj_creator<Foo>::static_create(3, 4.0);

// 全局工厂函数用法
auto f2 = yggr::create_object<Foo>(5, 6.0);
````

---

## 注意事项

- 该工厂模板禁止实例化，仅能通过静态成员函数调用。
- 静态对象（`static_create`/`static_const_create`）每种参数组合只会构造一次，适合单例或缓存场景。
- 兼容 C++11 及更早标准，参数数量受限于 `YGGR_PP_FOO_DEFAULT_PARAMS_LEN` 宏设置。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 pragma_message.hpp 的文档说明：

---

# pragma_message.hpp 文档

## 文件简介

pragma_message.hpp 提供了跨平台、跨编译器的编译期消息输出宏 `YGGR_PRAGMA_MESSAGE`，用于在编译过程中输出自定义提示、警告或信息。该文件自动适配 Boost 版本和主流编译器，保证在不同环境下都能安全、统一地输出编译期消息，便于调试和配置提示。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<boost/version.hpp>`
- Boost 1.67.0 及以上：`<boost/config/pragma_message.hpp>`

---

## 主要内容

### 1. 宏定义与适配

- **YGGR_DISABLE_PRAGMA_MESSAGE**  
  若 Boost 禁用 `PRAGMA_MESSAGE`，则同步禁用 Yggdrasil 的消息宏。

- **YGGR_PRAGMA_MESSAGE(x)**  
  编译期消息输出宏。根据 Boost 版本和编译器自动适配：
  - Boost 1.67.0 及以上：直接使用 `BOOST_PRAGMA_MESSAGE`
  - Boost 1.67.0 以下：根据编译器分别实现
    - MSVC/Intel：`__pragma(message(...))`
    - GCC：`_Pragma("message(...)")`
    - 其他：空操作

- **YGGR_TMP_STRINGIZE(X)**  
  辅助宏，将参数转为字符串，用于拼接消息内容。

### 2. 用法说明

- 在代码中插入 `YGGR_PRAGMA_MESSAGE("你的提示信息")`，即可在编译时输出自定义信息。
- 支持输出当前文件名和行号（MSVC/Intel）。

---

## 用法示例

````cpp
#include <yggr/base/pragma_message.hpp>

YGGR_PRAGMA_MESSAGE("编译到此处，检查配置！")
````

编译时会在输出窗口看到类似：
```
e:\path\to\file.hpp(42): note: 编译到此处，检查配置！
```

---

## 注意事项

- 若定义了 `BOOST_DISABLE_PRAGMA_MESSAGE` 或 `YGGR_DISABLE_PRAGMA_MESSAGE`，则该宏为空操作。
- 推荐用于配置检测、特性提示、弃用警告等场景。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 ptr_single.hpp 的文档说明：

---

# ptr_single.hpp 文档

## 文件简介

ptr_single.hpp 提供了一个线程安全的单例智能指针模板类 `yggr::ptr_single`，用于全局唯一对象的懒加载与安全访问。支持多种构造参数，兼容 C++11 可变参数模板和旧标准下的多参数重载。适用于需要全局唯一实例且线程安全的场景，如配置管理器、资源池等。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- `<yggr/base/static_constant.hpp>`
- `<yggr/bind/bind.hpp>`
- `<yggr/move/move.hpp>`
- `<yggr/smart_ptr_ex/shared_ptr.hpp>`
- `<yggr/nonable/noncreateable.hpp>`
- `<yggr/ppex/foo_params.hpp>`
- `<yggr/safe_container/safe_wrap.hpp>`
- `<boost/weak_ptr.hpp>`
- `<boost/shared_mutex.hpp>`

---

## 命名空间

- yggr

---

## 主要模板类

### yggr::ptr_single<T, Mutex, ver>

#### 模板参数

- `T`：单例对象类型。
- `Mutex`：用于线程安全的互斥量类型，默认为 `boost::shared_mutex`。
- `ver`：版本号，默认为 0。

#### 类型定义

- `obj_type` / `value_type`：对象类型 `T`
- `obj_ptr_type`：`shared_ptr<T>`，对象的智能指针类型
- `obj_weak_ptr_type`：`weak_ptr<T>`，对象的弱引用类型
- `version_type`：`yggr::u32`，版本号类型

#### 主要静态方法

- `get_ins()`  
  获取单例对象的 `shared_ptr`。

- `get_weak_ins()`  
  获取单例对象的 `weak_ptr`。

- `init_ins(const obj_ptr_type& ptr)`  
  用已有的智能指针初始化单例对象。

- `init_ins(Args&&... args)`  
  使用参数构造并初始化单例对象（C++11 可变参数模板）。

- `init_ins_d(D&& d, Args&&... args)`  
  支持带自定义分配器或删除器的初始化。

- `init_ins_da(D&& d, A&& a, Args&&... args)`  
  支持带自定义分配器和参数的初始化。

- `uninstall()`  
  卸载并销毁单例对象。

- `version()`  
  获取当前单例模板的版本号。

#### 内部机制

- 使用 `safe_wrap` 包装对象，保证多线程安全。
- 通过静态局部变量实现单例，懒加载。
- 支持自定义构造参数、分配器、删除器等。

---

## 用法示例

````cpp
#include <yggr/base/ptr_single.hpp>

struct Config {
    int value;
    Config(int v) : value(v) {}
};

// 初始化单例对象
auto ptr = yggr::ptr_single<Config>::init_ins(42);

// 获取单例对象
auto shared = yggr::ptr_single<Config>::get_ins();
if (shared) {
    std::cout << shared->value << std::endl;
}

// 卸载单例对象
yggr::ptr_single<Config>::uninstall();
````

---

## 注意事项

- 禁止实例化（继承自 `nonable::noncreateable`），只能通过静态方法访问。
- 支持多参数构造，兼容 C++11 及更早标准。
- 单例对象在 `uninstall()` 后会被销毁，需谨慎管理生命周期。
- 线程安全，适合多线程环境下的全局对象管理。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 script_lua_cfg.hpp 的文档说明：

---

# script_lua_cfg.hpp 文档

## 文件简介

script_lua_cfg.hpp 用于配置 Yggdrasil 工程中 Lua 脚本支持的兼容性宏，确保不同版本的 Lua（如 5.1、5.2、5.3、5.4）在工程中能统一使用特定特性。该文件通过定义一系列 Lua 兼容性宏，提升 Lua 脚本集成的灵活性和兼容性。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`，否则编译报错。

---

## 主要内容

### 1. Lua 64位整数支持

- `LUA_USELONGLONG`  
  启用 Lua 对 long long（64位整数）的支持，适用于 Lua 5.1.4 及以上版本。

### 2. Lua 兼容性宏

- `LUA_COMPAT_ALL`  
  启用所有 Lua 5.2 兼容特性，适用于 Lua 5.2.1 及以上版本。

- `LUA_COMPAT_5_2`  
  启用 Lua 5.2 兼容特性，适用于 Lua 5.3.4 及以上版本。

- `LUA_COMPAT_5_1`  
  启用 Lua 5.1 兼容特性，适用于 Lua 5.3.4 及以上版本。

### 3. 宏定义逻辑

- 若未定义上述宏，则自动进行定义，确保 Lua 集成时具备所需兼容性。

---

## 用法说明

- 只需在工程中包含本头文件，即可自动为 Lua 脚本集成配置好兼容性宏，无需手动干预。
- 推荐在所有 Lua 相关代码之前包含本文件，保证宏定义生效。

````cpp
#include <yggr/base/script_lua_cfg.hpp>
extern "C" {
    #include <lua.h>
    #include <lauxlib.h>
    #include <lualib.h>
}
````

---

## 注意事项

- 必须先包含 `<yggr/base/yggrdef.h>`，否则会编译报错。
- 这些宏会影响 Lua 源码的编译和行为，确保在包含 Lua 头文件前定义。
- 若工程中有特殊 Lua 版本需求，可根据实际情况调整宏定义。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 script_python_cfg.hpp 的文档说明：

---

# script_python_cfg.hpp 文档

## 文件简介

script_python_cfg.hpp 用于为 Yggdrasil 工程中的 Python 脚本集成预留配置入口。该文件目前主要用于头文件包含保护和依赖检测，便于后续扩展 Python 相关的兼容性宏或配置项。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`，否则编译报错。

---

## 主要内容

### 1. 头文件包含保护

- 防止重复包含，定义了 `__YGGR_BASE_SCRIP_TPYTHON_CFG_HPP__` 宏。

### 2. 依赖检测

- 若未先包含 `yggrdef.h`，则编译报错，确保类型和基础配置一致。

### 3. 预留扩展

- 当前未定义具体的 Python 兼容性宏或配置项，便于后续根据实际需求扩展。

---

## 用法说明

- 推荐在所有 Python 脚本集成相关代码之前包含本文件，便于后续统一管理 Python 相关配置。

````cpp
#include <yggr/base/script_python_cfg.hpp>
#include <Python.h>
````

---

## 注意事项

- 必须先包含 `<yggr/base/yggrdef.h>`，否则会编译报错。
- 该文件为扩展预留，后续可根据 Python 版本或集成需求添加宏定义。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 static_constant.hpp 的文档说明：

---

# static_constant.hpp 文档

## 文件简介

static_constant.hpp 为 Yggdrasil 工程提供了跨平台、跨编译器的静态常量宏 `YGGR_STATIC_CONSTANT`，用于在类或结构体中安全、统一地声明静态常量。该文件自动适配 GCC 和其他主流编译器，保证静态常量声明的兼容性和可移植性。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- `<yggr/base/yggrdef.h>`
- 依赖 Boost 的 `BOOST_STATIC_CONSTANT` 宏

---

## 主要内容

### 1. 宏定义

- **YGGR_STATIC_CONSTANT(type, assignment)**  
  用于在类、结构体或命名空间中声明静态常量。  
  - 在 GCC 下，宏展开为 `enum { assignment }`，避免 GCC 某些版本下的静态常量模板实例化问题。
  - 在其他编译器下，宏等价于 Boost 的 `BOOST_STATIC_CONSTANT`，即 `static const type assignment;`。

#### 示例

````cpp
struct Foo {
    YGGR_STATIC_CONSTANT(int, value = 42);
};
````

等价于（GCC 下）：
```cpp
struct Foo {
    enum { value = 42 };
};
```
或（其他编译器下）：
```cpp
struct Foo {
    static const int value = 42;
};
```

---

## 用法说明

- 推荐在模板类、结构体等需要静态常量的场景下统一使用该宏，保证跨平台兼容性。
- 可用于枚举值、模板参数、常量表达式等多种用途。

---

## 注意事项

- 宏会根据编译器自动适配，无需手动干预。
- 需先包含 `<yggr/base/yggrdef.h>`。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 third_party_issues_config.hpp 的文档说明：

---

# third_party_issues_config.hpp 文档

## 文件简介

third_party_issues_config.hpp 用于集中管理 Yggdrasil 工程中与第三方库（主要是 Boost）兼容性相关的问题修正和配置。该文件通过宏定义和条件编译，修复旧版本 Boost 在特定平台或 C++ 标准下的已知问题，并为后续扩展预留了接口。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`，否则编译报错。

---

## 主要内容

### 1. Boost 旧版本兼容性修正

- 定义宏 `YGGR_BOOST_OLD_VERSION_COMPATIBILITY_FIXED`，用于标记已修复 Boost 1.53 及以下版本在 `interprocess`、`win32_api.hpp`、`get_wmi_class_attribute`、`wchar_variant` 等模块中的兼容性问题。
- 该宏可用于条件编译，屏蔽或修正相关代码。

### 2. C++ 标准与 Boost 版本兼容性提示

- 根据当前 C++ 标准版本（C++98/03、C++11、C++14、C++17、C++20、C++23）进行条件分支，为后续不同标准下的第三方库兼容性修正预留扩展点。
- 对于 C++17，如果 Boost 版本小于 1.64.0，给出注释性警告（未启用强制报错），提示 Boost 1.64 及以下版本不支持 C++17 及以上标准，尤其是 `boost/functional/hash.hpp` 和 `std::unary_function` 相关问题。

---

## 用法说明

- 本文件会在工程编译初期自动定义兼容性修正宏，供后续代码条件编译使用。
- 推荐所有涉及 Boost 旧版本兼容性修正的代码均通过 `YGGR_BOOST_OLD_VERSION_COMPATIBILITY_FIXED` 宏进行条件编译。

````cpp
#ifdef YGGR_BOOST_OLD_VERSION_COMPATIBILITY_FIXED
// 兼容性修正代码
#endif
````

---

## 注意事项

- 必须先包含 `<yggr/base/yggrdef.h>`，否则会编译报错。
- 该文件为第三方库兼容性修正的集中入口，便于后续维护和扩展。
- 若需针对不同 C++ 标准或 Boost 版本做更多兼容性处理，可在对应分支内扩展。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 user_config.hpp 的文档说明：

---

# user_config.hpp 文档

## 文件简介

user_config.hpp 是 Yggdrasil 工程的用户自定义配置头文件。该文件用于集中管理和覆盖工程默认配置，允许开发者根据实际需求自定义类型支持、特性开关、第三方库适配等。所有用户级别的宏定义和兼容性调整建议在此文件中进行，便于后续升级和维护。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`，否则编译报错。

---

## 主要内容

### 1. 宽字符与宽字符串支持

- 若定义了 `YGGR_NO_CWCHAR`，则自动定义 `YGGR_NO_WSTRING`，禁用宽字符串支持。

### 2. MinGW 下字符类型支持（注释示例）

- 针对 MinGW 平台，建议禁用 `char8_t`、`char16_t`、`char32_t` 支持（已注释，按需启用）。

### 3. ICU 支持（注释示例）

- 可选启用 `BOOST_HAS_ICU`，用于 Boost 的 ICU 支持（已注释，按需启用）。

### 4. Boost 兼容性修正

- 定义 `YGGR_FIX_BOOST_UNORDERED_TRY_EMPLACE_HINT_NOT_MOVE_KEY`，修复 Boost `unordered_map` 的 `try_emplace` 在带 hint 时 key 未移动的问题。

### 5. 用户自定义配置区（建议在此添加自定义宏）

- 推荐将所有自定义特性开关、默认行为等宏定义放在此处，便于集中管理。
- 示例（已注释）：
  - `YGGR_USE_UTF8_EX_MODE`：启用 UTF8 扩展模式
  - `YGGR_HEX_CONV_DEFAULT_MODE`：设置十六进制转换默认模式
  - `YGGR_LUA_THREAD_SAFE`：启用 Lua 线程安全

---

## 用法说明

- 在需要自定义工程行为、兼容性或特性时，直接在本文件中添加或取消注释相关宏定义。
- 推荐不要直接修改工程其他配置头文件，所有用户级别的配置建议集中在本文件。

````cpp
// 启用 UTF8 扩展模式
#ifndef YGGR_USE_UTF8_EX_MODE
#   define YGGR_USE_UTF8_EX_MODE
#endif
````

---

## 注意事项

- 必须在包含本文件前先包含 `<yggr/base/yggrdef.h>`。
- 修改本文件后建议重新编译整个工程，确保配置生效。
- 注释部分为常用配置示例，按需取消注释即可生效。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 version.hpp 的文档说明：

---

# version.hpp 文档

## 文件简介

version.hpp 定义了 Yggdrasil 工程的版本号相关宏，提供主版本号、次版本号、修订号的统一管理，并支持多种格式的版本号生成（十六进制、点分十进制、字符串）。该文件还包含 Boost 版本兼容性检查，确保工程在受支持的 Boost 版本下编译。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`，否则编译报错。
- `<boost/version.hpp>`

---

## 主要内容

### 1. Boost 版本兼容性检查

- 若 Boost 版本低于 1.53.0，则编译报错：  
  `yggdrasil not support boost 1.52 and older`

### 2. 版本号宏定义

- `YGGR_MAJOR_VERSION`：主版本号（当前为 0）
- `YGGR_MINOR_VERSION`：次版本号（当前为 8）
- `YGGR_MICRO_VERSION`：修订号（当前为 1）

### 3. 版本号格式化宏

- `YGGR_MAKE_VERSION_HEX(__major__, __minor__, __micro__)`  
  生成 32 位十六进制版本号，格式为 `0xMMmmpp00`（M=主，m=次，p=修订）。

- `YGGR_MAKE_VERSION_DOT_DEC(__major__, __minor__, __micro__)`  
  生成点分十进制版本号（如 0.8.1）。

- `YGGR_MAKE_VERSION_DOT_DEC_STRING(__major__, __minor__, __micro__)`  
  生成点分十进制字符串版本号（如 "0.8.1"）。

### 4. 当前版本号宏

- `YGGR_VERSION`：当前点分十进制版本号（如 0.8.1）
- `YGGR_VERSION_S`：当前点分十进制字符串版本号（如 "0.8.1"）
- `YGGR_VERSION_HEX`：当前十六进制版本号（如 0x00080010）

---

## 用法示例

````cpp
#include <yggr/base/version.hpp>

int main() {
    std::cout << "Yggdrasil version: " << YGGR_VERSION_S << std::endl;
    std::cout << "Yggdrasil version (hex): " << std::hex << YGGR_VERSION_HEX << std::endl;
}
````

---

## 注意事项

- 必须先包含 `<yggr/base/yggrdef.h>`，否则会编译报错。
- 仅支持 Boost 1.53.0 及以上版本。
- 推荐所有涉及版本号判断、显示、条件编译等场景统一使用本文件中的宏。

---

 

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 yggr_cpp_ver_config.hpp 的文档说明：

---

# yggr_cpp_ver_config.hpp 文档

## 文件简介

yggr_cpp_ver_config.hpp 用于自动检测和定义当前编译环境的 C++ 标准版本，并为 Yggdrasil 工程提供统一的 C++ 版本号宏。该文件支持 C++98、03、11、14、17、20、23 等主流标准，便于后续代码根据标准版本进行条件编译和特性适配。

---

## 版权声明

版权所有 (c) 2010-2024 yggdrasil  
 <!-- 作者：xu yang  -->
本文件遵循 MIT 许可证。

---

## 依赖

- 必须先包含 `<yggr/base/yggrdef.h>`，否则编译报错。

---

## 主要内容

### 1. C++ 版本号宏定义

- `YGGR_CPP_VER_98`：98
- `YGGR_CPP_VER_03`：300
- `YGGR_CPP_VER_11`：1100
- `YGGR_CPP_VER_14`：1400
- `YGGR_CPP_VER_17`：1700
- `YGGR_CPP_VER_20`：2000
- `YGGR_CPP_VER_23`：2300

### 2. C++ 标准 __cplusplus 宏值定义

- `YGGR__CPLUSPLUS_ISO_98`：199711
- `YGGR__CPLUSPLUS_ISO_11`：201103
- `YGGR__CPLUSPLUS_ISO_14`：201402
- `YGGR__CPLUSPLUS_ISO_17`：201703
- `YGGR__CPLUSPLUS_ISO_20`：202002

### 3. 当前 C++ 标准检测

- 对于 MSVC，优先使用 `_MSVC_LANG`，否则假定为 200300（VS2010 支持 03）。
- 其他编译器使用 `__cplusplus`。

### 4. YGGR_CPP_VER 和 YGGR_CPP_VERSION 宏

- 根据 `YGGR__CPLUSPLUS` 的值自动推断当前 C++ 版本，并定义 `YGGR_CPP_VER` 和 `YGGR_CPP_VERSION`。
- 支持自动识别 C++98、03、11、14、17、20、23，若更高版本需手动扩展。

### 5. YGGR_USING_CXX?? 宏

- 自动定义当前使用的 C++ 标准宏，如 `YGGR_USING_CXX11`、`YGGR_USING_CXX17` 等。
- 若已手动定义 `YGGR_USING_CXX??`，则同步修正 `YGGR_CPP_VERSION`。

---

## 用法说明

- 通过检测 `YGGR_CPP_VERSION` 或 `YGGR_USING_CXX??` 宏，可在代码中安全判断当前 C++ 标准，进行条件编译或特性适配。

````cpp
#if defined(YGGR_USING_CXX17)
// C++17 特性代码
#endif

#if (YGGR_CPP_VERSION >= YGGR_CPP_VER_14)
// C++14 及以上特性代码
#endif
````

---

## 注意事项

- 必须先包含 `<yggr/base/yggrdef.h>`，否则会编译报错。
- 若需支持更高版本的 C++ 标准，请手动扩展相关宏定义。
- 推荐所有与 C++ 标准相关的条件编译均通过本文件中的宏进行判断。

---

 