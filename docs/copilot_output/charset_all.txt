alucard-dracula: 为这个文件生成文档

GitHub Copilot: # basic_string_adp_helper.hpp 文档

该头文件为 `std::basic_string` 和 `boost::container::basic_string` 提供了适配器辅助函数，统一了两者在 assign、insert、replace、find 等操作上的行为，尤其在内存区域重叠时保证语义一致。此文件主要用于解决不同 string 实现（如 STL 与 Boost.Container）在某些边界情况下行为不一致的问题。

---

## 主要内容

### 1. assign 系列函数

- **功能**：为字符串对象赋值，支持多种参数类型（字符、C 字符串、子串、迭代器、initializer_list 等）。
- **适用类型**：`std::basic_string` 和 `boost::container::basic_string`
- **特殊处理**：对于 boost::container::basic_string，若赋值区域与自身重叠，做了特殊内存处理，保证行为与 STL string 一致。

### 2. insert 系列函数

- **功能**：在字符串指定位置插入内容，支持插入字符、C 字符串、子串、迭代器区间、initializer_list 等。
- **适用类型**：`std::basic_string` 和 `boost::container::basic_string`
- **特殊处理**：对于 boost::container::basic_string，插入时若插入内容与自身重叠，采用临时缓冲区和内存移动，防止数据错乱。

### 3. replace 系列函数

- **功能**：替换字符串指定区域内容，支持替换为字符、C 字符串、子串、迭代器区间、initializer_list 等。
- **适用类型**：`std::basic_string` 和 `boost::container::basic_string`
- **特殊处理**：对于 boost::container::basic_string，替换时若内容重叠，采用内存拷贝和移动，保证替换后内容正确。

### 4. find 系列函数

- **功能**：查找字符、C 字符串、子串等在字符串中的位置。
- **适用类型**：`std::basic_string` 和 `boost::container::basic_string`
- **特殊处理**：对空字符串查找的行为做了统一（STL string 查找空串返回 0，Boost string 返回 npos）。

---

## 设计说明

- **统一语义**：为不同 string 实现提供一致的接口和行为，尤其在内存重叠、边界条件下。
- **异常安全**：在越界或非法操作时抛出 `std::out_of_range` 异常。
- **泛型编程**：大量使用模板和 SFINAE，支持多种类型和迭代器。
- **C++11 支持**：部分接口支持 initializer_list（可通过宏控制）。

---

## 典型用法

```cpp
std::string s = "hello";
yggr::charset::basic_string_assign(s, "world"); // s = "world"

boost::container::string bs = "abc";
yggr::charset::basic_string_replace(bs, 1, 1, "xyz", 3); // bs = "axyzc"
```

---

## 注意事项

- 该文件依赖于 yggr 框架的类型定义、工具宏、迭代器 traits 等。
- 仅适用于 `std::basic_string` 和 `boost::container::basic_string`，不适用于其他 string 实现。
- 若使用 C++11 及以上，部分接口可用 initializer_list。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需详细 API 说明，请查阅每个函数的注释或源码实现。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # boyer_moore_horspool.hpp 文档

该头文件为 yggdrasil 框架的字符集模块提供了 Boyer-Moore-Horspool 字符串查找算法的适配接口。Boyer-Moore-Horspool 算法是一种高效的字符串搜索算法，常用于大文本中的子串查找。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **功能**：直接引入了 `yggr::algorithm` 命名空间下的 `boyer_moore_horspool` 和 `boyer_moore_horspool_search` 算法，使其在 `yggr::charset` 下可用。
- **依赖**：
  - boyer_moore_horspool.hpp：算法实现。
  - bm_traits.hpp：算法相关 traits 支持。

---

## 主要接口

- `boyer_moore_horspool`
- `boyer_moore_horspool_search`

这两个接口均为模板函数，支持任意迭代器类型，适用于字符串、容器等的高效子串查找。

---

## 用法示例

```cpp
#include <yggr/charset/boyer_moore_horspool.hpp>
#include <string>

std::string text = "hello world";
std::string pattern = "world";

auto it = yggr::charset::boyer_moore_horspool_search(
    text.begin(), text.end(),
    pattern.begin(), pattern.end()
);

if (it != text.end()) {
    // 找到匹配
}
```

---

## 设计说明

- **适配性**：通过 `using` 声明，将算法接口暴露到 `yggr::charset` 命名空间，便于统一调用。
- **高效性**：Boyer-Moore-Horspool 算法在大文本查找中性能优越，适合高性能场景。
- **可扩展性**：依赖 traits，可适配不同字符类型和容器。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需详细算法原理和参数说明，请参考 boyer_moore_horspool.hpp 的实现与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # boyer_moore.hpp 文档

该头文件为 yggdrasil 框架的字符集模块提供了 Boyer-Moore 字符串查找算法的适配接口。Boyer-Moore 算法是一种经典且高效的字符串搜索算法，适用于大规模文本中的子串查找，具有较高的查找性能。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **功能**：通过 `using` 声明，将 `yggr::algorithm` 命名空间下的 `boyer_moore` 和 `boyer_moore_search` 算法引入到 `yggr::charset` 命名空间，方便统一调用。
- **依赖**：
  - boyer_moore.hpp：Boyer-Moore 算法实现。
  - bm_traits.hpp：算法相关 traits 支持。

---

## 主要接口

- `boyer_moore`
- `boyer_moore_search`

这两个接口均为模板函数，支持任意迭代器类型，适用于字符串、容器等的高效子串查找。

---

## 用法示例

```cpp
#include <yggr/charset/boyer_moore.hpp>
#include <string>

std::string text = "example text for search";
std::string pattern = "search";

auto it = yggr::charset::boyer_moore_search(
    text.begin(), text.end(),
    pattern.begin(), pattern.end()
);

if (it != text.end()) {
    // 找到匹配
}
```

---

## 设计说明

- **适配性**：通过 `using` 声明，将算法接口暴露到 `yggr::charset` 命名空间，便于统一调用。
- **高效性**：Boyer-Moore 算法在大文本查找中性能优越，适合高性能场景。
- **可扩展性**：依赖 traits，可适配不同字符类型和容器。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需详细算法原理和参数说明，请参考 boyer_moore.hpp 的实现与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # charset_base_foo.hpp 文档

该头文件定义了 `yggr::charset::charset_base_foo` 工具类，为字符集相关操作提供基础静态方法，支持多种字符类型（如 char、wchar_t、char8_t、char16_t、char32_t 及自定义类型），并包含大小写无关比较、长度计算、空间扩展等常用功能。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`charset_base_foo`（不可实例化，仅提供静态方法）

---

## 主要功能

### 1. 空间扩展率常量

- `E_space_expansion_rate`  
  控制字符集转换时的空间扩展倍数（默认 4，若定义 `YGGR_USE_UTF8_EX_MODE` 则为 6）。

### 2. 字符串长度与空间计算

- `strlen(const Char* str)`  
  计算以 0 结尾的字符串长度，支持多种字符类型。
- `strnlen(const Char* str, size_type n)`  
  计算最大长度为 n 的字符串长度。
- `xchglen(const Char* str)`  
  计算字符串转换时所需的最大空间（含扩展率）。
- `xchgnlen(const Char* str, size_type n)`  
  计算最大长度为 n 的字符串转换所需空间。
- `xchglen(size_type n)`  
  直接根据长度 n 计算转换所需空间。
- `xchglen(const Basic_String& str)`  
  计算字符串对象转换所需空间。

### 3. 字符串标准化

- `normal_length(Basic_String& str)`  
  移除字符串中首个 0 字符及其后内容，返回标准化后的字符串。

### 4. 大小写无关比较

- `strcmp_case(const char* l, const char* r)`  
  C 风格字符串大小写无关比较。
- `strncmp_case(const char* l, const char* r, size_type len)`  
  C 风格字符串大小写无关比较（指定长度）。
- `strcmp_case(const Char* l, const Char* r)`  
  泛型字符类型大小写无关比较。
- `strncmp_case(const Char* l, const Char* r, size_type len)`  
  泛型字符类型大小写无关比较（指定长度）。

---

## 设计说明

- **泛型支持**：大量使用模板和 SFINAE，支持自定义和标准字符类型。
- **平台兼容**：自动适配 Windows 和 POSIX 下的大小写比较实现。
- **不可实例化**：继承自 `nonable::noncreateable`，仅能静态调用。
- **高效安全**：使用断言和类型 traits 保证类型安全和运行时安全。

---

## 用法示例

```cpp
using namespace yggr::charset;

const char* s = "Hello";
size_t len = charset_base_foo::strlen(s);

std::string str = "abc\0def";
charset_base_foo::normal_length(str); // str 变为 "abc"

int cmp = charset_base_foo::strcmp_case("abc", "ABC"); // cmp == 0
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需详细 API 说明，请查阅每个函数的源码实现与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # charset_converter.hpp 文档

该头文件定义了 `yggr::charset::charset_converter` 类，用于不同字符集（编码）之间的字符串转换，底层基于 iconv 库实现。支持多种字符串类型和字符类型的高效转换，适用于 UTF-8、GBK、UTF-16、UCS-2 等常见编码的互转。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`charset_converter`（禁止拷贝和移动）

---

## 主要功能

### 1. 构造与初始化

- 支持以 C 字符串或自定义字符串类型指定源字符集和目标字符集。
- 构造时自动初始化 iconv 句柄，若初始化失败则断言。

### 2. 字符集转换接口

- **全量转换**  
  支持如下调用方式，若转换失败返回 `false`，成功则输出结果到 `output`：
  - `operator()(const Char* input, OutString& output) const`
  - `operator()(const Char* input, std::size_t n, OutString& output) const`
  - `operator()(const InString& input, OutString& output) const`
- **支持不完整转换**  
  可用于分块转换大数据，需手动检查输入输出字节数：
  - `operator()(const InString& input, std::size_t& ilen_byte, OutString& output, std::size_t& olen_byte) const`
  - `operator()(const char* input, std::size_t& ilen_byte, char* output, std::size_t& olen_byte) const`

### 3. 校验与状态

- `is_validate()`  
  检查 iconv 句柄是否有效。

---

## 设计说明

- **类型泛化**：支持多种字符串类型（如 std::string、std::wstring、boost::container::string 等）和字符类型（char、wchar_t、char16_t、char32_t）。
- **内存安全**：自动分配和回收输出缓冲区，防止溢出。
- **高效实现**：利用 iconv 库进行底层转换，支持大部分主流字符集。
- **异常安全**：转换失败时输出清空，保证调用方安全。
- **不可拷贝/移动**：防止 iconv 句柄误用。

---

## 用法示例

```cpp
#include <yggr/charset/charset_converter.hpp>
#include <string>

yggr::charset::charset_converter conv("UTF-8", "GBK");
std::string utf8_str = "你好";
std::string gbk_str;
if (conv(utf8_str, gbk_str)) {
    // gbk_str 现在是 GBK 编码
}
```

---

## 注意事项

- 依赖 iconv 库，需在编译和链接时确保 iconv 可用。
- 若转换失败，输出字符串会被清空。
- 若需分块处理大数据，可使用带字节数参数的接口。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需详细 API 说明，请查阅每个函数的源码实现与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # charset_error_def.hpp 文档

该头文件为 yggdrasil 框架的字符集模块定义了字符集相关的错误码与错误信息，便于在字符集转换等操作中进行统一的异常处理和错误报告。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心结构体**：`charset_error_def`

---

## 主要功能

### 1. 错误码定义

通过宏定义机制，声明了字符集相关的错误码，便于在程序中进行错误判断和处理。

- **E_charset_conver_failed**  
  表示字符集转换失败。

错误码的数值区间由 `exception::exception_sort::E_code_start_22` 到 `exception::exception_sort::E_code_end_22` 控制，确保与其他模块的错误码不冲突。

### 2. 错误信息定义

为每个错误码定义了对应的错误消息字符串，便于日志记录和用户提示。

- **E_charset_conver_failed**  
  错误消息为 `"charset_convter_failed"`。

---

## 设计说明

- **统一管理**：通过 `charset_error_def` 结构体集中管理字符集相关错误码和消息。
- **可扩展性**：可在该结构体内继续添加更多字符集相关的错误码和消息。
- **与 yggdrasil 框架集成**：依赖于 error.hpp 和 exception_sort.hpp，与框架的异常处理体系无缝对接。

---

## 用法示例

```cpp
#include <yggr/charset/charset_error_def.hpp>

int err_code = yggr::charset::charset_error_def::E_charset_conver_failed;
std::string err_msg = yggr::charset::charset_error_def::get_error_msg(err_code);
// err_msg == "charset_convter_failed"
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展错误码或获取详细用法，请查阅相关宏定义和 yggdrasil 框架的异常处理文档。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # charset_foo.hpp 文档

该头文件定义了 yggdrasil 框架字符集模块的核心工具类 `yggr::charset::charset_foo`，用于不同字符串类型、不同字符类型、不同编码之间的高效转换和拷贝。它为字符串编码转换、容器间数据迁移等场景提供了统一、泛型且类型安全的接口。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`charset_foo`（不可实例化，仅提供静态方法）

---

## 主要功能

### 1. 同构字符串类型转换

- 支持同一编码下不同字符串容器（如 `std::string`、`std::wstring`、`boost::container::string` 等）之间的数据拷贝和转换。
- 支持原生字符数组、字符串视图与容器类型的互转。
- 支持带分配器（Allocator）的容器构造。

### 2. 编码转换（跨字符集转换）

- 支持指定源编码和目标编码（如 UTF-8、GBK、UTF-16 等），自动调用 `charset_converter` 进行底层转换。
- 支持不同容器类型、不同字符类型之间的编码转换。
- 若源编码与目标编码一致，则直接进行类型转换或拷贝，无需实际转换。
- 若转换失败，抛出统一的错误码（`E_charset_conver_failed`）。

### 3. 支持多种输入输出形式

- 支持原生指针、长度指定的数组、字符串对象、字符串视图等多种输入形式。
- 支持输出到新对象或原有对象（in-place 替换）。
- 支持分配器自定义。

### 4. 类型安全与静态断言

- 使用 Boost MPL 和 SFINAE 技术，保证只有合适的类型组合才能通过编译。
- 静态断言容器必须为随机访问迭代器，保证高效操作。

### 5. 内部实现机制

- 内部通过 `detail::charset_foo_call_t` 及其特化，自动判断是否为同构字符串类型，选择最优的拷贝或 reinterpret_cast 策略。
- 对于不同编码，统一通过 `charset_converter` 调用 iconv 进行底层转换。

---

## 用法示例

```cpp
#include <yggr/charset/charset_foo.hpp>
#include <string>

// 同编码类型转换
std::wstring ws = L"你好";
std::vector<wchar_t> wvec = yggr::charset::charset_foo::s_xchg<std::vector<wchar_t>>(ws);

// 跨编码转换
std::string utf8_str = u"你好";
std::wstring wide_str = yggr::charset::charset_foo::s_xchg<std::wstring>(
    utf8_str, "UTF-8", "UTF-16"
);

// 原地转换
std::string dst;
yggr::charset::charset_foo::s_xchg(dst, ws, "UTF-16", "UTF-8");
```

---

## 设计说明

- **泛型与高扩展性**：支持任意容器、字符类型、分配器和字符串视图。
- **类型安全**：大量使用 SFINAE、MPL、静态断言，防止类型误用。
- **高效实现**：同构类型直接 reinterpret_cast 或 memcpy，异构类型自动编码转换。
- **异常安全**：转换失败时抛出统一错误码，便于上层捕获和处理。
- **与 yggdrasil 框架深度集成**：依赖于框架的类型 traits、异常体系、分配器等。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需详细 API 说明和扩展用法，请查阅每个静态方法的源码实现与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # charset_type_traits.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了丰富的类型萃取（Type Traits）工具，主要用于判断和区分各种字符串类型、字符串视图类型、UTF-8 相关类型、通用字符串容器类型及其迭代器类型。通过这些 traits，可以在模板编程中实现类型安全、自动分派和高效的泛型字符串处理。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心内容**：类型萃取模板结构体（Type Traits）

---

## 主要功能

### 1. 字符类型与字符串类型判断

- **is_utf8_char_t<T>**  
  判断类型 T 是否为 UTF-8 字符类型（默认 false，可特化）。
- **is_basic_string_t<T>**  
  判断类型 T 是否为 `std::basic_string` 或 `boost::container::basic_string`。
- **is_basic_string_view_t<T>**  
  判断类型 T 是否为 `std::basic_string_view`（C++17 及以上）。
- **is_utf8_string_t<T>**  
  判断类型 T 是否为 UTF-8 字符串类型（默认 false，可特化）。
- **is_string_t<T>**  
  判断类型 T 是否为标准字符串类型（basic_string 或 utf8_string）。
- **is_string_view_t<T>**  
  判断类型 T 是否为字符串视图类型（basic_string_view 或 utf8_string_view）。
- **is_generalized_string_t<T>**  
  判断类型 T 是否为广义字符串类型（包括字符串容器、指针等，元素为 integral 类型）。

### 2. 字符串视图类型判断

- **is_same_basic_string_view_tpl<T1, T2>**  
  判断 T1 和 T2 是否为相同模板的 basic_string_view。
- **is_difference_basic_string_view_tpl<T1, T2>**  
  判断 T1 和 T2 是否为不同模板的 basic_string_view。

### 3. 迭代器类型判断

- **is_utf8_string_iterator_t<T>**  
  判断 T 是否为 UTF-8 字符串的普通迭代器。
- **is_utf8_string_reverse_iterator_t<T>**  
  判断 T 是否为 UTF-8 字符串的反向迭代器。
- **is_utf8_string_const_iterator_t<T>**  
  判断 T 是否为 UTF-8 字符串的常量迭代器。
- **is_utf8_string_const_reverse_iterator_t<T>**  
  判断 T 是否为 UTF-8 字符串的常量反向迭代器。
- **is_utf8_string_modify_iterator_t<T>**  
  判断 T 是否为 UTF-8 字符串的可修改迭代器。
- **is_utf8_string_modify_reverse_iterator_t<T>**  
  判断 T 是否为 UTF-8 字符串的可修改反向迭代器。
- **is_any_utf8_string_iterator_t<T>**  
  判断 T 是否为任意 UTF-8 字符串相关迭代器（普通、反向、常量、可修改）。
- **is_any_utf8_string_reverse_iterator_t<T>**  
  判断 T 是否为任意 UTF-8 字符串相关反向迭代器。

### 4. 反向判断（not_xxx）

每个类型萃取都提供了对应的反向判断（如 `is_not_utf8_char_t<T>`），便于模板编程中的条件分支。

---

## 设计说明

- **高度泛型**：通过模板和 Boost MPL，支持任意自定义字符串类型和容器类型的扩展。
- **可特化**：默认实现均为 false_，实际项目中可针对自定义类型进行特化。
- **与 STL/Boost 深度集成**：自动识别 STL、Boost 字符串及视图类型。
- **支持 C++17 string_view**：自动适配 `std::basic_string_view`。
- **广义字符串支持**：不仅支持标准字符串，还支持元素为 integral 的容器和指针。

---

## 用法示例

```cpp
#include <yggr/charset/charset_type_traits.hpp>
#include <string>
#include <vector>

static_assert(yggr::charset::is_basic_string_t<std::string>::value, "std::string 应为 basic_string");
static_assert(yggr::charset::is_generalized_string_t<std::vector<char>>::value, "vector<char> 也被视为广义字符串");
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型，请特化对应的 traits 结构体。详细用法和扩展方式请查阅源码实现与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # const_strings.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了跨多字符类型（char、wchar_t、char8_t、char16_t、char32_t）定义和获取常量字符串与字符的宏工具。通过这些宏，可以方便地为不同字符类型声明和访问同名常量，极大简化多字符集代码的编写和维护。

---

## 主要内容

- **命名空间**：`yggr::charset::const_strings` 及 `yggr::charset::const_chars`
- **核心功能**：常量字符串/字符的多字符类型声明与获取宏

---

## 主要功能

### 1. 常量字符/字符串的本地声明

- `YGGR_PP_CONST_CHAR_LOCAL_DEF(__name__, __char_val__)`  
  定义一个结构体 `__name__`，为多种字符类型（char、wchar_t、char8_t、char16_t、char32_t）分别提供静态 `value` 方法，返回对应类型的常量字符。
- `YGGR_PP_CONST_STRING_LOCAL_DEF(__name__, __string__)`  
  定义一个结构体 `__name__`，为多种字符类型分别提供静态 `value` 方法，返回对应类型的常量字符串指针。

### 2. 常量字符/字符串的本地获取

- `YGGR_PP_CONST_CHAR_LOCAL_GET(__name__, __char__)`  
  获取本地结构体 `__name__` 中指定字符类型的常量字符。
- `YGGR_PP_CONST_STRING_LOCAL_GET(__name__, __char__)`  
  获取本地结构体 `__name__` 中指定字符类型的常量字符串。

### 3. 常量字符/字符串的全局声明

- `YGGR_PP_CONST_CHAR_GLOBAL_DEF(__name__, __char_val__)`  
  在 `yggr::charset::const_chars` 命名空间下全局声明常量字符结构体。
- `YGGR_PP_CONST_STRING_GLOBAL_DEF(__name__, __string__)`  
  在 `yggr::charset::const_strings` 命名空间下全局声明常量字符串结构体。

### 4. 常量字符/字符串的全局获取

- `YGGR_PP_CONST_CHAR_GLOBAL_GET(__name__, __char__)`  
  全局获取指定命名空间下结构体的常量字符。
- `YGGR_PP_CONST_STRING_GLOBAL_GET(__name__, __char__)`  
  全局获取指定命名空间下结构体的常量字符串。

---

## 设计说明

- **多字符集兼容**：自动适配 char、wchar_t、char8_t、char16_t、char32_t，便于跨平台和多编码开发。
- **宏自动生成**：通过宏展开，避免重复手写多种类型的常量定义。
- **类型安全**：通过静态类型转换，保证获取的常量类型正确。
- **灵活性高**：支持本地和全局两种声明方式，适合不同作用域需求。

---

## 用法示例

```cpp
// 定义全局常量字符串
YGGR_PP_CONST_STRING_GLOBAL_DEF(hello_str, "hello");

// 获取不同字符类型的常量字符串
const char* cstr = YGGR_PP_CONST_STRING_GLOBAL_GET(hello_str, char);
#ifndef YGGR_NO_CWCHAR
const wchar_t* wstr = YGGR_PP_CONST_STRING_GLOBAL_GET(hello_str, wchar_t);
#endif
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符类型，请参考宏定义实现方式。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # convertible_traits.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了类型转换相关的 traits 工具，主要用于判断类型是否可以安全地转换为字符类型，以及为字符类型选择合适的格式化类型。它在泛型编程和字符串处理场景下，确保类型安全和高效转换。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心内容**：类型转换相关 traits 结构体和辅助宏

---

## 主要功能

### 1. patch_is_integral_c8

- 解决在部分 Boost 版本下 `char8_t`（或自定义 `c8`）类型未被识别为 integral 类型的问题。
- 对 `yggr::c8` 和 `const yggr::c8` 进行特化，映射为 `char` 或 `const char`。

### 2. is_can_be_conv_into_char

- 判断类型 T 是否可以安全地转换为字符类型。
- 满足以下任一条件即为 true：
  - T 是算术类型（如整型、浮点型、char 等）。
  - T 是枚举类型。
- 用于泛型字符串处理时的类型约束。

### 3. is_convertible_char

- 判断类型 T 是否为 integral 类型（整型，包括 char、wchar_t、char8_t、char16_t、char32_t 等）。
- 用于进一步约束只能用于字符的泛型模板。

### 4. format_char_t

- 用于确定类型 T 的格式化类型（通常为 s32 或更小的整型）。
- 通过 `YGGR_PP_INTEGER_T` 宏，保证格式化类型不会超过 s32 的大小。

### 5. 辅助宏

- `YGGR_PP_FORMAT_CHAR_TYPE(__type__)`  
  获取类型 `__type__` 的格式化类型。
- `YGGR_PP_FORMAT_CHAR_TYPE_TPL(__type__)`  
  用于模板上下文下获取格式化类型。

---

## 设计说明

- **兼容性强**：自动适配不同 Boost 版本和 C++ 标准下的 char8_t 支持。
- **类型安全**：通过 traits 保证只有合适的类型才能参与字符相关操作。
- **泛型友好**：便于在模板编程中进行类型分派和静态断言。
- **高效实现**：所有判断均为编译期常量，不影响运行时性能。

---

## 用法示例

```cpp
#include <yggr/charset/convertible_traits.hpp>
#include <type_traits>

static_assert(yggr::charset::is_can_be_conv_into_char<int>::value, "int 可转换为 char");
static_assert(!yggr::charset::is_can_be_conv_into_char<void*>::value, "void* 不可转换为 char");

typedef YGGR_PP_FORMAT_CHAR_TYPE(char16_t) my_fmt_type; // my_fmt_type 通常为 s32
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义类型，请特化对应的 traits 结构体。详细用法和扩展方式请查阅源码实现与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # default_charset_config.hpp 文档

该头文件为 yggdrasil 框架的字符集模块提供了**默认字符集名称配置**，用于在不同平台、不同字符类型下自动推导和获取字符串的默认编码名称。它为字符串编码转换、字符集适配等场景提供了统一的配置和类型工具。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心结构体**：`default_charset_config`
- **辅助类型**：`charset_name_t` 及其特化
- **宏定义**：一系列字符集名称获取和类型推导宏

---

## 主要功能

### 1. 默认字符集名称宏

- `TAG_YGGR_INNER_STRING_CHARSET_NAME()`  
  内部字符串默认编码（一般为 "utf-8"）。
- `YGGR_SYS_DEFAULT_STRING_CHARSET_NAME_CFG`  
  系统默认字符串编码（Linux/macOS 为 "utf-8"，Windows 为 "char"）。
- `YGGR_SYS_DEFAULT_WSTRING_CHARSET_NAME_CFG`  
  系统默认宽字符串编码（"wchar_t"）。
- `YGGR_SYS_DEFAULT_CHAR8_STRING_CHARSET_NAME_CFG`  
  char8_t 字符串默认编码（"utf-8"）。
- `YGGR_SYS_DEFAULT_CHAR16_STRING_CHARSET_NAME_CFG`  
  char16_t 字符串默认编码（根据字节序为 "utf-16le"、"utf-16be" 或 "utf-16"）。
- `YGGR_SYS_DEFAULT_CHAR32_STRING_CHARSET_NAME_CFG`  
  char32_t 字符串默认编码（根据字节序为 "utf-32le"、"utf-32be" 或 "utf-32"）。
- 还有对应的宏函数（如 `YGGR_SYS_DEFAULT_STRING_CHARSET_NAME()`）便于调用。

### 2. 默认字符集名称类型

- 通过 `defalut_charset_name_t<Char>` 模板，根据字符类型自动推导对应的默认字符集名称结构体，并提供静态方法 `s_charset_name()` 和 `s_str_charset_name()` 获取编码名称（`const char*` 和 `const string&`）。
- 针对不同字符类型（char、wchar_t、char8_t、char16_t、char32_t 及其数组、指针）和平台特性做了特化处理。

### 3. default_charset_config 工具结构体

- 提供静态方法获取各种字符类型的默认编码名称：
  - `get_default_string_charset_name<Char>()` 返回 `const char*`
  - `get_str_default_string_charset_name<Char>()` 返回 `const string&`
  - `get_inner_string_charset_name()` / `get_str_inner_string_charset_name()` 获取内部字符串编码
  - `get_utf8_string_charset_name()` / `get_str_utf8_string_charset_name()` 获取 UTF-8 编码名称

### 4. charset_name_t 泛型类型

- `charset_name_t<Char>` 可用于任意字符类型、字符串类型、字符串视图类型，自动推导并获取对应的默认字符集名称。
- 支持与 `const char*`、`const string&` 之间的隐式转换。
- 支持与字符串、C 字符串、其他 `charset_name_t` 实例之间的比较操作（==、!=）。

### 5. 宏工具

- `YGGR_STRING_DEFAULT_CHARSET_NAME(__char_t__)`  
  获取指定字符类型的默认编码名称（`const char*`）。
- `YGGR_STR_STRING_DEFAULT_CHARSET_NAME(__char_t__)`  
  获取指定字符类型的默认编码名称（`const string&`）。
- `YGGR_DEDUCED_DEFAULT_CHARSET_NAME(__char_t__)`  
  用于类型萃取场景下自动推导编码名称。
- `YGGR_CHARSET_MAKE_STRING(__basic_string__, __char__, __traits__, __alloc__)`  
  快速生成指定参数的字符串类型。

---

## 设计说明

- **平台兼容**：自动适配 Windows、Linux、macOS 等不同平台的默认编码。
- **类型泛化**：支持 char、wchar_t、char8_t、char16_t、char32_t 及其容器、视图类型。
- **静态推导**：所有编码名称均可在编译期通过类型推导获得，便于泛型编程。
- **安全高效**：所有类型均不可拷贝/移动，防止误用；编码名称为静态常量，避免重复构造。

---

## 用法示例

```cpp
#include <yggr/charset/default_charset_config.hpp>
#include <string>

const char* charset = YGGR_STRING_DEFAULT_CHARSET_NAME(char); // "utf-8" 或 "char"
const char* wcharset = YGGR_STRING_DEFAULT_CHARSET_NAME(wchar_t); // "wchar_t"、"utf-16le"等

// 泛型获取
std::string s;
const char* s_charset = yggr::charset::charset_name_t<std::string>();

// 比较
if (yggr::charset::charset_name_t<char>() == "utf-8") {
    // ...
}
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符类型或平台，请参考模板和宏定义实现方式。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # escape_codes_basic_converter.hpp 文档

该头文件定义了 `yggr::charset::escape_codes_basic_converter` 类，为字节数据与转义字符串（如 URL 编码、字符串字面量编码等）之间的转换提供了静态工具方法。支持多字符类型（char、wchar_t、char16_t、char32_t 等），适用于通用转义/反转义场景。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`escape_codes_basic_converter`（仅静态方法）

---

## 主要功能

### 1. 转义分隔符获取

- `SEPUrl<Char>()`  
  获取 URL 编码的转义分隔符（即 `%`），返回指定字符类型。
- `SEPStringLiteral<Char>()`  
  获取字符串字面量编码的转义分隔符（即 `$`），返回指定字符类型。

### 2. 字节转转义字符串

- `s_escape_byte<Char>(Char* pstr, u8 val, Char sep, u32 mode = E_Mode_Default)`  
  将单字节 val 转为转义字符串（如 `%AB`），写入 pstr，sep 为分隔符，mode 控制十六进制大小写。
- `s_escape_bytes<Char>(Char* pstr, const u8* pdata, size_type size, Char sep, u32 mode = E_Mode_Default)`  
  将 pdata 指向的字节数组批量转为转义字符串，写入 pstr。

### 3. 转义字符串转字节

- `s_unescape_byte<Char>(const Char* pstr)`  
  将转义字符串（如 `%AB`）还原为单字节。
- `s_unescape_bytes(u8* pdata, const Char* pstr, std::size_t size, Char sep)`  
  将转义字符串批量还原为字节数组，支持任意字符类型和分隔符。

### 4. 十六进制模式常量

- `E_Mode_Low`、`E_Mode_Upper`、`E_Mode_Default`  
  控制转义字符串中十六进制字母的大小写。

---

## 设计说明

- **泛型支持**：所有接口均为模板，支持多种字符类型。
- **高效实现**：批量转换采用指针操作和 memcpy，效率高。
- **安全性**：带断言和参数检查，防止越界和空指针。
- **与 hex_basic_converter 配合**：依赖 hex_basic_converter 进行十六进制字符与数值的互转。

---

## 用法示例

```cpp
#include <yggr/charset/escape_codes_basic_converter.hpp>
#include <string>

char buf[4] = {};
yggr::charset::escape_codes_basic_converter::s_escape_byte(buf, 0xAB, '%');
// buf == "%AB"

uint8_t data[2] = {0x12, 0x34};
char esc[7] = {};
yggr::charset::escape_codes_basic_converter::s_escape_bytes(esc, data, 2, '%');
// esc == "%12%34"

uint8_t out[2] = {};
yggr::charset::escape_codes_basic_converter::s_unescape_bytes(out, esc, 6, '%');
// out == {0x12, 0x34}
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义分隔符或字符类型，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # escape_codes_converter.hpp 文档

该头文件定义了 `yggr::charset::escape_codes_converter` 类，为字节数据与转义字符串（如 URL 编码、字符串字面量编码等）之间的**高级批量转换**提供了泛型静态工具方法。支持多种容器类型、字符类型和分配器，适用于高效的批量转义/反转义场景，且可自动处理字符集编码转换。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`escape_codes_converter`（继承自 `escape_codes_basic_converter`，仅静态方法）
- **内部实现**：通过 detail 命名空间下的辅助模板类实现批量处理

---

## 主要功能

### 1. 单字节转义

- `s_escape_byte(String& str, u8 val, Char sep, u32 mode, const string& dst_charset_name)`  
  将单字节 val 转为转义字符串（如 `%AB`），写入指定字符串类型 str，支持指定分隔符、十六进制大小写、目标字符集。
- `s_escape_byte(u8 val, Char sep, ...)`  
  返回转义后的字符串对象，支持分配器自定义。

### 2. 批量字节转义

- `s_escape_bytes(String& str, const HexBuf& hex_buf, Char sep, u32 mode, const string& dst_charset_name)`  
  将字节容器 hex_buf 批量转为转义字符串，写入 str，支持字符集转换。
- `s_escape_bytes(const HexBuf& hex_buf, Char sep, ...)`  
  返回转义后的字符串对象，支持分配器自定义。

### 3. 单字节反转义

- `s_unescape_byte(const String& str)`  
  将转义字符串（如 `%AB`）还原为单字节，支持字符串和字符串视图类型。

### 4. 批量字符串反转义为字节

- `s_unescape_bytes(HexBuf& buf, const Char* p, size_type n, Char sep, const string& src_charset_name)`  
  将转义字符串批量还原为字节容器，支持指定字符集。
- 支持多种输入类型：C 字符串、`std::basic_string`、`utf8_string`、`basic_string_view`、`basic_utf8_string_view` 等。

### 5. 字符集自动适配

- 支持源字符串和目标字符串的字符集自动转换（如 UTF-8 与本地编码之间的互转）。
- 若字符集不同，自动进行编码转换，保证数据正确。

### 6. 内部实现机制

- detail 命名空间下的 `escape_bytes_helper` 和 `unescape_bytes_helper` 模板类，自动根据迭代器类型选择最优实现。
- 支持随机访问和非随机访问容器的高效处理。

---

## 设计说明

- **高度泛型**：支持任意容器、字符类型、分配器和字符串视图。
- **类型安全**：大量使用 SFINAE、MPL、静态断言，防止类型误用。
- **高效实现**：同构类型直接批量处理，异构类型自动编码转换。
- **异常安全**：参数检查和断言，防止越界和空指针。
- **与 yggdrasil 框架深度集成**：依赖于框架的类型 traits、分配器、字符串类型等。

---

## 用法示例

```cpp
#include <yggr/charset/escape_codes_converter.hpp>
#include <vector>
#include <string>

// 字节数组转 URL 转义字符串
std::vector<uint8_t> data = {0x12, 0x34, 0xAB};
std::string esc = yggr::charset::escape_codes_converter::s_escape_bytes<std::string>(data, '%');

// 反转义回字节数组
std::vector<uint8_t> out;
yggr::charset::escape_codes_converter::s_unescape_bytes(out, esc, '%');
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义分隔符、字符类型或容器类型，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # generalized_string.hpp 文档

该头文件为 yggdrasil 框架的字符集模块提供了**广义字符串类型**的判空工具。它支持多种字符串类型（包括标准字符串、字符串视图、容器、C 风格指针等），通过统一接口判断“字符串”是否为空，极大方便了泛型编程和通用字符串处理。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心函数**：`generalized_string_empty`
- **内部实现**：`detail::is_generalized_string_t_empty_helper` 模板结构体

---

## 主要功能

### 1. generalized_string_empty

```cpp
template<typename String>
bool generalized_string_empty(const String& str);
```

- **功能**：判断任意广义字符串类型是否为空。
- **类型要求**：`String` 必须满足 `is_generalized_string_t<String>::value == true`（即被视为广义字符串类型）。
- **实现机制**：根据类型特性自动选择合适的判空方式。

### 2. 判空策略（内部实现）

- **字符串视图类型**（如 `std::string_view`、`yggr::utf8_string_view` 等）  
  直接调用 `str.empty()`。
- **容器类型**（如 `std::vector<char>`、`std::basic_string` 等）  
  调用 `yggr::container::empty(str)`，兼容 STL 和自定义容器。
- **指针类型**（如 `const char*`、`const wchar_t*`）  
  判定为 null 或首字符为 0 时为空。

---

## 设计说明

- **高度泛型**：支持字符串、字符串视图、容器、C 风格指针等多种类型。
- **类型安全**：通过 SFINAE 和 traits 保证只有广义字符串类型可用。
- **统一接口**：无论输入类型如何，均可用 `generalized_string_empty` 判断是否为空。
- **内部实现灵活**：通过模板特化自动分派到最优判空方式。

---

## 用法示例

```cpp
#include <yggr/charset/generalized_string.hpp>
#include <string>
#include <vector>

std::string s1 = "";
std::vector<char> s2;
const char* s3 = nullptr;
const char* s4 = "";

bool b1 = yggr::charset::generalized_string_empty(s1); // true
bool b2 = yggr::charset::generalized_string_empty(s2); // true
bool b3 = yggr::charset::generalized_string_empty(s3); // true
bool b4 = yggr::charset::generalized_string_empty(s4); // true
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型，请确保其满足 `is_generalized_string_t` 的特化条件。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # hex_basic_converter.hpp 文档

该头文件定义了 `yggr::charset::hex_basic_converter` 类，为字节与十六进制字符串之间的转换提供了静态工具方法。支持多字符类型（char、wchar_t、char16_t、char32_t 等），适用于通用的十六进制编码/解码场景，如数据序列化、转义、调试输出等。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`hex_basic_converter`（仅静态方法）

---

## 主要功能

### 1. 十六进制字符与数值互转

- `s_char_to_hex(char val)`  
  将单个十六进制字符（'0'-'9', 'a'-'f', 'A'-'F'）转换为对应的数值（0-15），非法字符返回 0xFF。
- `s_char_to_hex<Char>(Char ch_val)`  
  泛型版本，支持任意可转换为字符的类型。

### 2. 数值转十六进制字符

- `s_hex_to_char(char* pstr, u8 val, u32 mode = E_Mode_Default)`  
  将单字节 val 转为两个十六进制字符，写入 pstr，mode 控制大小写。
- `s_hex_to_char<Char>(Char* pstr, u8 val, u32 mode = E_Mode_Default)`  
  泛型版本，支持任意字符类型。

### 3. 十六进制字符串转字节数组

- `s_string_to_hex(u8* phex, const char* pstr, size_type size)`  
  将十六进制字符串（如 "1A2B"）转换为字节数组，size 必须为偶数。
- `s_string_to_hex<Char>(u8* phex, const Char* pstr, size_type size)`  
  泛型版本，支持任意字符类型。

### 4. 字节数组转十六进制字符串

- `s_hex_to_string(char* pstr, const u8* phex, size_type size, u32 mode = E_Mode_Default)`  
  将字节数组转换为十六进制字符串，mode 控制大小写。
- `s_hex_to_string<Char>(Char* pstr, const u8* phex, size_type size, u32 mode = E_Mode_Default)`  
  泛型版本，支持任意字符类型。

### 5. 十六进制模式常量

- `E_Mode_Low`、`E_Mode_Upper`、`E_Mode_Default`  
  控制十六进制字符串中字母的大小写。

---

## 设计说明

- **泛型支持**：所有接口均为模板，支持多种字符类型。
- **高效实现**：批量转换采用指针操作和循环，效率高。
- **安全性**：带断言和参数检查，防止越界和空指针。
- **与 hex_converter_config 配合**：依赖 hex_converter_config 提供的字符映射表。

---

## 用法示例

```cpp
#include <yggr/charset/hex_basic_converter.hpp>
#include <cstdint>

char buf[3] = {};
yggr::charset::hex_basic_converter::s_hex_to_char(buf, 0xAB);
// buf == "AB"

uint8_t data[2] = {0x12, 0x34};
char hexstr[5] = {};
yggr::charset::hex_basic_converter::s_hex_to_string(hexstr, data, 2);
// hexstr == "1234"

uint8_t out[2] = {};
yggr::charset::hex_basic_converter::s_string_to_hex(out, hexstr, 4);
// out == {0x12, 0x34}
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符类型，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # hex_converter_config.hpp 文档

该头文件为 yggdrasil 框架的字符集模块提供了十六进制转换的配置工具，主要用于控制十六进制字符串的大小写格式，并提供十六进制字符查找表。常用于字节与十六进制字符串互转的场景，如数据序列化、转义、调试输出等。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心结构体**：`hex_converter_config`

---

## 主要功能

### 1. 十六进制模式常量

- `E_Mode_Low`  
  小写十六进制模式（如 "abcdef"）。
- `E_Mode_Upper`  
  大写十六进制模式（如 "ABCDEF"）。
- `E_Mode_Default`  
  默认十六进制模式。若未定义 `YGGR_HEX_CONV_DEFAULT_MODE` 或其值非法，则为小写模式。

### 2. 十六进制字符查找表

- `s_hex_to_char_table(u32 mode = E_Mode_Default)`  
  返回指定模式下的十六进制字符查找表指针：
  - `mode == E_Mode_Low` 返回 "0123456789abcdef"
  - `mode == E_Mode_Upper` 返回 "0123456789ABCDEF"
- 支持编译期 constexpr 或内联，效率高。
- 内部断言 mode 必须小于 2，防止越界。

---

## 设计说明

- **高效实现**：查找表为静态常量数组，查找速度快。
- **灵活配置**：可通过宏定义切换默认大小写模式，适应不同编码风格。
- **类型安全**：所有模式常量均为 u32 类型，便于模板和泛型编程。
- **与 hex_basic_converter 配合**：通常与 `hex_basic_converter` 等工具类联合使用，实现字节与十六进制字符串的高效互转。

---

## 用法示例

```cpp
#include <yggr/charset/hex_converter_config.hpp>

const char* low_tab = yggr::charset::hex_converter_config::s_hex_to_char_table(); // "0123456789abcdef"
const char* up_tab = yggr::charset::hex_converter_config::s_hex_to_char_table(yggr::charset::hex_converter_config::E_Mode_Upper); // "0123456789ABCDEF"
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义十六进制格式，请参考结构体实现方式。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # hex_converter.hpp 文档

该头文件定义了 `yggr::charset::hex_converter` 类，为字节数据与十六进制字符串之间的**高级批量转换**提供了泛型静态工具方法。支持多种容器类型、字符类型、分配器和编码，适用于高效的批量十六进制编码/解码、数据序列化、调试输出等场景。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`hex_converter`（继承自 `hex_basic_converter`，仅静态方法）
- **内部实现**：通过 detail 命名空间下的辅助模板类实现批量处理

---

## 主要功能

### 1. 单字符十六进制转换

- `s_char_to_hex`  
  支持多种 UTF-8 字符类型（如 `utf8_char_impl`、`basic_utf8_char_view` 等）转为单字节数值。
- 继承自 `hex_basic_converter` 的 `s_char_to_hex`，支持基本字符类型。

### 2. 字符串转字节数组（十六进制解码）

- `s_string_to_hex(HexBuf& buf, const Char* p, size_type n, const string& src_charset_name)`  
  将十六进制字符串（如 "1A2B"）解码为字节容器，支持指定源字符集。
- 支持多种字符串类型（如 `std::basic_string`、`utf8_string_impl`、`basic_string_view` 等）与容器类型的泛型转换。
- 自动适配不同字符集编码，必要时先转为 UTF-8 再解码。

### 3. 字节数组转十六进制字符串（十六进制编码）

- `s_hex_to_string(String& str, const HexBuf& hex_buf, u32 mode, const string& dst_charset_name)`  
  将字节容器批量编码为十六进制字符串，支持大小写模式和目标字符集。
- 支持多种容器类型、字符串类型、分配器和迭代器区间。
- 自动适配不同字符集编码，必要时先转为 UTF-8 再转换为目标编码。

### 4. 分配器与泛型支持

- 支持自定义分配器的字符串构造，适合高性能和特殊内存管理场景。
- 支持任意容器、字符串、字符串视图、迭代器等类型的泛型批量转换。

---

## 设计说明

- **高度泛型**：支持任意容器、字符类型、分配器和字符串视图。
- **类型安全**：大量使用 SFINAE、MPL、静态断言，防止类型误用。
- **高效实现**：同构类型直接批量处理，异构类型自动编码转换。
- **异常安全**：参数检查和断言，防止越界和空指针。
- **与 yggdrasil 框架深度集成**：依赖于框架的类型 traits、分配器、字符串类型等。

---

## 用法示例

```cpp
#include <yggr/charset/hex_converter.hpp>
#include <vector>
#include <string>

// 字节数组转十六进制字符串
std::vector<uint8_t> data = {0x12, 0x34, 0xAB};
std::string hexstr = yggr::charset::hex_converter::s_hex_to_string<std::string>(data);

// 十六进制字符串转字节数组
std::vector<uint8_t> out;
yggr::charset::hex_converter::s_string_to_hex(out, hexstr.c_str(), hexstr.size());
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义分隔符、字符类型或容器类型，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # is_boost_string.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了类型萃取工具 `is_boost_string`，用于在模板编程中判断某类型是否为 Boost.Container 的字符串类型（`boost::container::basic_string`）。这对于泛型字符串处理、类型分派等场景非常有用。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心结构体**：`is_boost_string`

---

## 主要功能

### 1. 类型萃取模板

```cpp
template<typename T>
struct is_boost_string : public boost::mpl::false_ {};
```
- 默认情况下，所有类型都被判定为 `false`。

### 2. boost::container::basic_string 特化

```cpp
template<typename Char, typename Traits, typename Alloc>
struct is_boost_string< boost::container::basic_string<Char, Traits, Alloc> > : public boost::mpl::true_ {};
```
- 只有 `boost::container::basic_string` 及其特化类型会被判定为 `true`。

---

## 用法示例

```cpp
#include <yggr/charset/is_boost_string.hpp>
#include <boost/container/string.hpp>
#include <string>

static_assert(!yggr::charset::is_boost_string<std::string>::value, "std::string 不是 boost string");
static_assert(yggr::charset::is_boost_string<boost::container::string>::value, "boost::container::string 是 boost string");
```

---

## 设计说明

- **类型安全**：通过模板特化和继承 `boost::mpl::true_`/`false_`，实现编译期类型判断。
- **泛型友好**：便于在模板代码中对 boost 字符串类型进行特化处理或分支。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型，请特化该结构体。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # is_isomeric_same_string.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了**同构字符串类型判断**的类型萃取工具，主要用于判断两个字符串类型（如 `std::basic_string`、`boost::container::basic_string` 等）是否为“同构异参数”类型，即模板参数（字符类型、traits、allocator）一致但类型本身不同。这对于泛型字符串处理、类型安全转换等场景非常有用。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心结构体**：
  - `is_isomeric_same_string`
  - `is_same_or_isomeric_same_string`

---

## 主要功能

### 1. is_isomeric_same_string

```cpp
template<typename StringL, typename StringR>
struct is_isomeric_same_string : public boost::mpl::bool_<...> {};
```

- **功能**：判断 StringL 和 StringR 是否为“同构异参数字符串类型”。
- **判定标准**：
  - 两者为同一模板（如都是 `basic_string`，但可以是 std 或 boost）。
  - 模板参数数量为 3（通常为 Char、Traits、Allocator）。
  - 第三个模板参数（Allocator）类型不同（用于区分 std::allocator 与 boost::container::allocator）。
  - 字符类型（value_type）相同。
  - traits_type 相同。
  - allocator_type 相同。
- **典型用途**：判断 `std::basic_string<char, Traits, Alloc>` 与 `boost::container::basic_string<char, Traits, Alloc>` 是否为同构类型。

### 2. is_same_or_isomeric_same_string

```cpp
template<typename StringL, typename StringR>
struct is_same_or_isomeric_same_string : public boost::mpl::or_<...> {};
```

- **功能**：判断 StringL 和 StringR 是否为完全相同类型或同构异参数字符串类型。
- **判定标准**：等价于 `boost::is_same<StringL, StringR>` 或 `is_isomeric_same_string<StringL, StringR>` 为 true。

---

## 设计说明

- **模板元编程**：通过模板特化、类型展开、traits 检查等方式实现复杂类型关系的编译期判断。
- **兼容性强**：适配 boost 1.70 及以上版本，解决 boost::container::basic_string 模板参数变化带来的兼容性问题。
- **类型安全**：便于在泛型代码中安全地进行字符串类型转换或重载分派。

---

## 用法示例

```cpp
#include <yggr/charset/is_isomeric_same_string.hpp>
#include <string>
#include <boost/container/string.hpp>

static_assert(
    yggr::charset::is_isomeric_same_string<
        std::basic_string<char, std::char_traits<char>, std::allocator<char>>,
        boost::container::basic_string<char, std::char_traits<char>, std::allocator<char>>
    >::value,
    "两者为同构异参数字符串类型"
);

static_assert(
    yggr::charset::is_same_or_isomeric_same_string<
        std::string,
        std::string
    >::value,
    "完全相同类型"
);
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型，请确保其模板参数结构与上述标准一致。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # is_stl_string.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了类型萃取工具 `is_stl_string`，用于在模板编程中判断某类型是否为 STL 标准字符串类型（即 `std::basic_string` 及其特化，如 `std::string`、`std::wstring` 等）。这对于泛型字符串处理、类型分派等场景非常有用。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心结构体**：`is_stl_string`

---

## 主要功能

### 1. 类型萃取模板

```cpp
template<typename T>
struct is_stl_string : public boost::mpl::false_ {};
```
- 默认情况下，所有类型都被判定为 `false`。

### 2. std::basic_string 特化

```cpp
template<typename Char, typename Traits, typename Alloc>
struct is_stl_string< std::basic_string<Char, Traits, Alloc> > : public boost::mpl::true_ {};
```
- 只有 `std::basic_string` 及其特化类型会被判定为 `true`。

---

## 用法示例

```cpp
#include <yggr/charset/is_stl_string.hpp>
#include <string>
#include <vector>

static_assert(yggr::charset::is_stl_string<std::string>::value, "std::string 是 STL 字符串类型");
static_assert(!yggr::charset::is_stl_string<std::vector<char>>::value, "vector<char> 不是 STL 字符串类型");
```

---

## 设计说明

- **类型安全**：通过模板特化和继承 `boost::mpl::true_`/`false_`，实现编译期类型判断。
- **泛型友好**：便于在模板代码中对 STL 字符串类型进行特化处理或分支。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型，请特化该结构体。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # knuth_morris_pratt.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 Knuth-Morris-Pratt（KMP）字符串查找算法的适配接口。KMP 算法是一种高效的字符串搜索算法，适用于在大文本中查找子串，具有线性时间复杂度。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心接口**：
  - `knuth_morris_pratt`
  - `knuth_morris_pratt_search`
- **依赖**：
  - knuth_morris_pratt.hpp：KMP 算法实现
  - kmp_traits.hpp：算法相关 traits 支持

---

## 主要功能

- 通过 `using` 声明，将 `yggr::algorithm` 命名空间下的 `knuth_morris_pratt` 和 `knuth_morris_pratt_search` 算法引入到 `yggr::charset` 命名空间，便于统一调用。
- 支持任意迭代器类型，适用于字符串、容器等的高效子串查找。

---

## 用法示例

```cpp
#include <yggr/charset/knuth_morris_pratt.hpp>
#include <string>

std::string text = "ababcabcacbab";
std::string pattern = "abcac";

auto it = yggr::charset::knuth_morris_pratt_search(
    text.begin(), text.end(),
    pattern.begin(), pattern.end()
);

if (it != text.end()) {
    // 找到匹配
}
```

---

## 设计说明

- **适配性**：通过 `using` 声明，将算法接口暴露到 `yggr::charset` 命名空间，便于统一调用和扩展。
- **高效性**：KMP 算法在大文本查找中性能优越，适合高性能场景。
- **可扩展性**：依赖 traits，可适配不同字符类型和容器。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需详细算法原理和参数说明，请参考 knuth_morris_pratt.hpp 的实现与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # make_string_t_from_allocator.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了根据分配器类型（Allocator）自动推导字符串类型的工具模板。它可根据传入的分配器类型，自动生成合适的 `yggr::charset::basic_string` 类型，便于泛型编程和自定义内存管理场景下的字符串类型适配。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：`make_string_t_from_allocator`

---

## 主要功能

### 1. make_string_t_from_allocator

```cpp
template<typename Alloc>
struct make_string_t_from_allocator;
```

- **功能**：根据分配器类型 `Alloc`，推导出合适的字符串类型。
- **实现机制**：
  - 若 `Alloc` 满足 `container_ex::is_allocator<Alloc>::value == true`，则生成
    ```cpp
    yggr::charset::basic_string<
        value_type, 
        traits_type, 
        Alloc
    >
    ```
    其中 `value_type` 由 `allocator_traits<Alloc>::value_type` 推导，`traits_type` 由 `basic_string<value_type>::traits_type` 推导。
  - 若 `Alloc` 不是分配器类型，则默认类型为 `yggr::charset::string`。

### 2. 内部实现

- 通过 `detail::_make_string_t_from_allocator` 辅助模板实现 SFINAE 分派，保证类型安全和泛型兼容。

---

## 用法示例

```cpp
#include <yggr/charset/make_string_t_from_allocator.hpp>
#include <memory>

// 使用 std::allocator<char> 推导字符串类型
typedef yggr::charset::make_string_t_from_allocator<std::allocator<char>>::type my_string_t;

// 使用非分配器类型，默认为 yggr::charset::string
typedef yggr::charset::make_string_t_from_allocator<int>::type default_string_t;
```

---

## 设计说明

- **类型安全**：通过 SFINAE 和 traits 保证只有分配器类型才会生成带自定义分配器的字符串类型。
- **泛型友好**：便于在模板代码中根据分配器自动适配字符串类型，支持自定义内存管理。
- **与 yggr 框架深度集成**：依赖于 `yggr::charset::basic_string`、`container_ex::allocator_traits` 等工具。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义分配器或字符串类型，请特化相关 traits 或模板。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # make_utf8_string_t_from_allocator.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了根据分配器类型（Allocator）自动推导 UTF-8 字符串类型的工具模板。它可根据传入的分配器类型，自动生成合适的 `yggr::charset::utf8_string_impl` 类型，便于泛型编程和自定义内存管理场景下的 UTF-8 字符串类型适配。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：`make_utf8_string_t_from_allocator`

---

## 主要功能

### 1. make_utf8_string_t_from_allocator

```cpp
template<typename Alloc>
struct make_utf8_string_t_from_allocator;
```

- **功能**：根据分配器类型 `Alloc`，推导出合适的 UTF-8 字符串类型。
- **实现机制**：
  - 若 `Alloc` 满足 `container_ex::is_allocator<Alloc>::value == true`，则生成
    ```cpp
    yggr::charset::utf8_string_impl<
        value_type,
        traits_type,
        Alloc
    >
    ```
    其中 `value_type` 由 `allocator_traits<Alloc>::value_type` 推导，`traits_type` 由 `basic_string<value_type>::traits_type` 推导。
  - 若 `Alloc` 不是分配器类型，则默认类型为 `yggr::charset::utf8_string`。

### 2. 内部实现

- 通过 `detail::_make_utf8_string_t_from_allocator` 辅助模板实现 SFINAE 分派，保证类型安全和泛型兼容。

---

## 用法示例

```cpp
#include <yggr/charset/make_utf8_string_t_from_allocator.hpp>
#include <memory>

// 使用 std::allocator<char> 推导 UTF-8 字符串类型
typedef yggr::charset::make_utf8_string_t_from_allocator<std::allocator<char>>::type my_utf8_string_t;

// 使用非分配器类型，默认为 yggr::charset::utf8_string
typedef yggr::charset::make_utf8_string_t_from_allocator<int>::type default_utf8_string_t;
```

---

## 设计说明

- **类型安全**：通过 SFINAE 和 traits 保证只有分配器类型才会生成带自定义分配器的 UTF-8 字符串类型。
- **泛型友好**：便于在模板代码中根据分配器自动适配 UTF-8 字符串类型，支持自定义内存管理。
- **与 yggr 框架深度集成**：依赖于 `yggr::charset::utf8_string_impl`、`container_ex::allocator_traits` 等工具。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义分配器或字符串类型，请特化相关 traits 或模板。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # native_string.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 `native_string` 泛型工具函数，支持多种字符串类型、字符数组、指针、UTF-8 字符串等在不同类型间的**零拷贝转换**或高效转换。其核心目标是：在类型安全的前提下，将各种字符串/字符类型以“本地”方式（即无需实际数据拷贝）转换为目标类型，极大提升泛型字符串处理的灵活性和效率。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心函数**：`native_string`（多重模板重载）

---

## 主要功能

### 1. 原生字符数组与指针的类型转换

- 支持不同字符类型的数组间 reinterpret_cast 转换（如 `wchar_t[4]` 转 `char[8]`）。
- 支持同类型数组/指针的直接返回。
- 支持 `const` 和非 `const` 情况。
- 支持不同字符类型指针间 reinterpret_cast 转换（如 `const wchar_t*` 转 `const char*`）。

### 2. 标准字符串（basic_string）类型转换

- 支持 `std::basic_string`、`boost::container::basic_string` 及其同构类型间的零拷贝转换（通过 reinterpret_cast）。
- 支持同类型字符串的直接返回。
- 支持不同 allocator 的字符串类型转换。
- 若目标类型与源类型完全不同，则通过字节拷贝构造新字符串对象。

### 3. UTF-8 字符串与视图类型转换

- 支持 `utf8_char_impl`、`utf8_string_impl`、`basic_utf8_char_view`、`basic_utf8_char_reference`、`basic_utf8_char_const_reference` 等 UTF-8 类型与其底层字符串类型的高效转换。
- 支持同构类型间的 reinterpret_cast。
- 支持 allocator 传递，便于自定义内存管理。

### 4. 泛型与类型安全

- 通过 Boost.TypeTraits、SFINAE、is_convertible_char、is_basic_string_t、is_isomeric_same_string 等 traits 保证类型安全。
- 针对不同类型自动选择最优实现路径，避免不必要的数据拷贝。

---

## 设计说明

- **零拷贝优先**：只要类型兼容，优先使用 reinterpret_cast 实现零拷贝转换，极大提升效率。
- **类型安全**：大量使用 SFINAE、traits、enable_if/disable_if，防止类型误用。
- **泛型友好**：支持任意字符类型、字符串类型、allocator、UTF-8 类型等。
- **灵活性高**：支持 allocator 传递，适配自定义内存管理需求。
- **与 yggdrasil 框架深度集成**：依赖于框架的字符串类型、traits、UTF-8 类型等。

---

## 用法示例

```cpp
#include <yggr/charset/native_string.hpp>
#include <string>
#include <boost/container/string.hpp>

wchar_t ws[4] = L"Hi";
auto cs = yggr::charset::native_string<char>(ws); // reinterpret_cast 为 char[8]

std::string s = "hello";
auto& s_ref = yggr::charset::native_string(s); // 返回 std::string&

boost::container::string bs = "world";
auto& std_str = yggr::charset::native_string<std::string>(bs); // reinterpret_cast 为 std::string&

const char* cstr = "abc";
auto p = yggr::charset::native_string<const wchar_t>(cstr); // reinterpret_cast 为 const wchar_t*
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型，请确保其满足相关 traits 的特化条件。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # other_char_chr_wchr.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 `other_char_chr_wchr` 类型工具，用于在模板编程中根据平台和配置自动选择“主字符类型”与“辅助字符类型”（char 和 wchar_t），便于泛型字符串处理和字符类型适配。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：`other_char_chr_wchr`

---

## 主要功能

### 1. other_char_chr_wchr 模板结构体

```cpp
template<typename Char>
struct other_char_chr_wchr : public other_char<Char, char, wchar_t> {};
```
- 若未定义 `YGGR_NO_CWCHAR`，则 `other_char_chr_wchr` 继承自 `other_char<Char, char, wchar_t>`，即主类型为 `char`，辅助类型为 `wchar_t`。
- 若定义了 `YGGR_NO_CWCHAR`，则辅助类型退化为 `char`，即 `other_char<Char, char, char>`。

### 2. 适用场景

- 用于模板代码中需要根据平台是否支持 `wchar_t` 自动适配辅助字符类型的场景。
- 便于统一处理 char/wchar_t 字符串转换、编码适配等问题。

---

## 设计说明

- **平台兼容**：通过宏 `YGGR_NO_CWCHAR` 控制是否启用 `wchar_t`，适配不同平台和编译环境。
- **泛型友好**：继承自 `other_char`，可统一访问主类型和辅助类型，便于泛型编程。
- **类型安全**：所有类型均通过模板参数静态确定，避免运行时类型错误。

---

## 用法示例

```cpp
#include <yggr/charset/other_char_chr_wchr.hpp>

// 获取主类型和辅助类型
typedef yggr::charset::other_char_chr_wchr<wchar_t>::main_type main_t;
typedef yggr::charset::other_char_chr_wchr<wchar_t>::other_type other_t;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符类型，请特化 `other_char` 或调整宏定义。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # other_char.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 `other_char` 类型工具，用于在模板编程中根据主字符类型和两个候选类型，自动推导“辅助字符类型”。这对于泛型字符串处理、字符类型适配等场景非常有用，尤其适合在 char/wchar_t、char/char16_t 等多字符集环境下自动选择另一种字符类型。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：`other_char`

---

## 主要功能

### 1. other_char 模板结构体

```cpp
template<typename C, typename C1, typename C2>
struct other_char
{
    typedef C type;
};
```
- 默认情况下，`type` 为第一个模板参数 `C`。

#### 特化1

```cpp
template<typename C, typename C2>
struct other_char<C, C, C2>
{
    typedef C2 type;
};
```
- 若第一个和第二个模板参数类型相同，则 `type` 为第三个参数 `C2`。

#### 特化2

```cpp
template<typename C, typename C1>
struct other_char<C, C1, C>
{
    typedef C1 type;
};
```
- 若第一个和第三个模板参数类型相同，则 `type` 为第二个参数 `C1`。

### 2. 类型断言

- 使用 `YGGR_ASSERT_CHAR_TYPE` 宏断言模板参数必须为字符类型，保证类型安全。

---

## 设计说明

- **类型推导**：根据主类型和两个候选类型，自动推导“另一种”字符类型，便于泛型代码中自动适配。
- **泛型友好**：适用于 char/wchar_t、char/char16_t、char/char32_t 等多字符集场景。
- **类型安全**：通过静态断言宏，防止非字符类型误用。

---

## 用法示例

```cpp
#include <yggr/charset/other_char.hpp>

// 主类型为 char，候选为 char 和 wchar_t，结果为 char
typedef yggr::charset::other_char<char, char, wchar_t>::type t1; // t1 == char

// 主类型为 wchar_t，候选为 char 和 wchar_t，结果为 char
typedef yggr::charset::other_char<wchar_t, char, wchar_t>::type t2; // t2 == char

// 主类型为 char，候选为 wchar_t 和 char，结果为 wchar_t
typedef yggr::charset::other_char<char, wchar_t, char>::type t3; // t3 == wchar_t
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符类型，请确保其满足 `YGGR_ASSERT_CHAR_TYPE` 的要求。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # other_string_str_wstr.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 `other_string_str_wstr` 类型工具，用于在模板编程中根据主字符串类型自动推导“辅助字符串类型”。它适用于 char/wchar_t 或 char/char 等多字符集环境下的字符串类型适配，便于泛型字符串处理和类型安全转换。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：`other_string_str_wstr`

---

## 主要功能

### 1. other_string_str_wstr 模板结构体

```cpp
template<typename String>
struct other_string_str_wstr : public other_string<String, char, wchar_t> {};
```
- 若未定义 `YGGR_NO_CWCHAR`，则 `other_string_str_wstr` 继承自 `other_string<String, char, wchar_t>`，即主类型为 `char` 字符串，辅助类型为 `wchar_t` 字符串。

```cpp
template<typename String>
struct other_string_str_wstr : public other_string<String, char, char> {};
```
- 若定义了 `YGGR_NO_CWCHAR`，则辅助类型退化为 `char` 字符串，即 `other_string<String, char, char>`。

### 2. 适用场景

- 用于模板代码中需要根据平台是否支持 `wchar_t` 自动适配辅助字符串类型的场景。
- 便于统一处理 char/wchar_t 字符串转换、编码适配等问题。

---

## 设计说明

- **平台兼容**：通过宏 `YGGR_NO_CWCHAR` 控制是否启用 `wchar_t`，适配不同平台和编译环境。
- **泛型友好**：继承自 `other_string`，可统一访问主类型和辅助类型，便于泛型编程。
- **类型安全**：所有类型均通过模板参数静态确定，避免运行时类型错误。

---

## 用法示例

```cpp
#include <yggr/charset/other_string_str_wstr.hpp>
#include <string>

// 获取主类型和辅助类型
typedef yggr::charset::other_string_str_wstr<std::string>::main_type main_t;
typedef yggr::charset::other_string_str_wstr<std::string>::other_type other_t;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型，请特化 `other_string` 或调整宏定义。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # other_string.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了**字符串类型自动推导工具**，用于在模板编程中根据主字符串类型和两个候选字符类型，自动推导“辅助字符串类型”。它支持标准字符串、traits、allocator 及相关对象的泛型适配，适用于 char/wchar_t、char/char16_t 等多字符集环境下的字符串类型自动切换。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：
  - `other_char_traits`
  - `other_char_allocator`
  - `other_char_tpl_arg_allocator`
  - `other_char_object`
  - `other_string`

---

## 主要功能

### 1. other_char_traits

- **功能**：根据主 traits 类型和两个候选字符类型，自动推导“辅助字符类型”的 traits。
- **用法**：
  ```cpp
  typedef other_char_traits<std::char_traits<char>, char, wchar_t>::type wtraits_t; // std::char_traits<wchar_t>
  ```

### 2. other_char_allocator

- **功能**：根据主 allocator 类型和两个候选字符类型，自动推导“辅助字符类型”的 allocator。
- **用法**：
  ```cpp
  typedef other_char_allocator<std::allocator<char>, char, wchar_t>::type walloc_t; // std::allocator<wchar_t>
  ```

### 3. other_char_tpl_arg_allocator

- **功能**：根据模板参数 allocator 类型和两个候选字符类型，自动推导“辅助字符类型”的 allocator，支持 void 特化。
- **用法**：
  ```cpp
  typedef other_char_tpl_arg_allocator<void, char, wchar_t>::type void_t; // void
  ```

### 4. other_char_object

- **功能**：根据主对象类型（如 traits、allocator、其他模板对象）和两个候选字符类型，自动推导“辅助字符类型”的对象类型。
- **用法**：
  ```cpp
  typedef other_char_object<MyObject<char>, char, wchar_t>::type MyObject<wchar_t>;
  ```

### 5. other_string

- **功能**：根据主字符串类型（如 `std::basic_string<char, Traits, Alloc>`）和两个候选字符类型，自动推导“辅助字符类型”的字符串类型（如 `std::basic_string<wchar_t, Traits, Alloc>`）。
- **用法**：
  ```cpp
  typedef other_string<std::basic_string<char>, char, wchar_t>::type wstring_t; // std::basic_string<wchar_t>
  ```

---

## 设计说明

- **类型自动推导**：通过模板参数和类型 traits，自动推导与主类型“同构”的辅助类型，适合泛型字符串处理和多字符集适配。
- **类型安全**：所有模板参数均通过 `YGGR_ASSERT_CHAR_TYPE` 静态断言，防止非字符类型误用。
- **灵活扩展**：支持 traits、allocator、对象、字符串等多种类型的自动推导，便于扩展和自定义。

---

## 用法示例

```cpp
#include <yggr/charset/other_string.hpp>
#include <string>

// 推导 wchar_t 版本的 string
typedef yggr::charset::other_string<std::string, char, wchar_t>::type wstring_t; // std::wstring

// 推导 char 版本的 wstring
typedef yggr::charset::other_string<std::wstring, char, wchar_t>::type string_t; // std::string

// 推导辅助 allocator
typedef yggr::charset::other_char_allocator<std::allocator<char>, char, wchar_t>::type walloc_t; // std::allocator<wchar_t>
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型、traits 或 allocator，请确保其模板参数结构与上述标准一致。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # str_wstr_converter.hpp 文档

该头文件定义了 yggdrasil 框架字符集模块中的 `str_wstr_converter` 工具类，专用于**字符串与宽字符串（char/wchar_t）之间的编码转换**。它支持多种字符串类型和字符类型，自动适配编码名称，便于在多字符集环境下进行高效、安全的字符串互转。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`str_wstr_converter`（不可实例化，仅提供静态方法）

---

## 主要功能

### 1. 字符串与宽字符串互转

#### 1.1 C 风格字符串转换

```cpp
template<typename Char>
static basic_string<typename other_char_chr_wchr<Char>::type>
s_conv(const Char* src,
       const string& src_charset_name = charset_name_t<Char>(),
       const string& dst_charset_name = charset_name_t<typename other_char_chr_wchr<Char>::type>());
```
- **功能**：将 C 风格字符串 `src` 从 `src_charset_name` 编码转换为另一种字符类型（如 char <-> wchar_t）的字符串，目标编码为 `dst_charset_name`。
- **适用类型**：char、wchar_t、char8_t、char16_t、char32_t 等。

#### 1.2 C 风格字符串（带长度）转换

```cpp
template<typename Char>
static basic_string<typename other_char_chr_wchr<Char>::type>
s_conv(const Char* src, size_type n,
       const string& src_charset_name = charset_name_t<Char>(),
       const string& dst_charset_name = charset_name_t<typename other_char_chr_wchr<Char>::type>());
```
- **功能**：同上，但支持指定长度 n，适合非 0 结尾字符串。

#### 1.3 标准字符串类型转换

```cpp
template<typename Char, typename Traits, typename Alloc,
         template< typename _Char, typename _Traits, typename _Alloc > class Basic_String>
static typename other_string_str_wstr< Basic_String<Char, Traits, Alloc> >::type
s_conv(const Basic_String<Char, Traits, Alloc>& src,
       const string& src_charset_name = charset_name_t<Char>(),
       const string& dst_charset_name = charset_name_t<typename other_char_chr_wchr<Char>::type>());
```
- **功能**：将任意标准字符串类型（如 `std::basic_string`、`boost::container::basic_string`）从一种字符类型转换为另一种（如 char <-> wchar_t），并自动适配编码名称。

---

## 设计说明

- **类型安全**：通过 SFINAE 和 traits 保证只对原生字符类型和标准字符串类型开放接口。
- **自动编码适配**：默认自动推导源/目标编码名称，支持自定义编码。
- **高效实现**：底层调用 `charset_foo::s_xchg`，自动选择最优转换路径。
- **不可实例化**：继承自 `nonable::noncreateable`，仅能静态调用。

---

## 用法示例

```cpp
#include <yggr/charset/str_wstr_converter.hpp>
#include <string>

std::string s = "你好";
std::wstring ws = yggr::charset::str_wstr_converter::s_conv(s); // UTF-8 -> UTF-16/32

const wchar_t* wsrc = L"世界";
std::string s2 = yggr::charset::str_wstr_converter::s_conv(wsrc); // UTF-16/32 -> UTF-8
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型或编码，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # string_byte_size.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了**字符串字节长度计算工具**，支持多种字符串类型（包括 C 风格字符串、标准字符串、字符串视图、boost 字符串等）和多种字符类型（char、wchar_t、char8_t、char16_t、char32_t）。它可用于高效、类型安全地计算字符串实际占用的字节数，适合序列化、内存分配、网络传输等场景。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心函数**：
  - `string_byte_size`：计算字符串内容的字节数（不含结尾 0）
  - `char_buffer_byte_size`：计算字符串缓冲区所需字节数（含结尾 0）
- **内部实现**：通过 detail 命名空间下的辅助模板结构体实现类型分派

---

## 主要功能

### 1. string_byte_size

- **功能**：计算字符串内容的实际字节数（不包含结尾 0）。
- **支持类型**：
  - C 风格字符串指针（如 `const char*`、`const wchar_t*` 等）
  - 字符数组（如 `char[N]`、`wchar_t[N]` 等）
  - 标准字符串类型（如 `std::basic_string`、`boost::container::basic_string` 等）
  - 字符串视图类型（如 `std::basic_string_view` 等）
- **实现机制**：根据类型自动选择合适的长度计算方式，并乘以字符类型的字节数。

#### 示例

```cpp
std::string s = "abc";
size_t n = yggr::charset::string_byte_size(s); // n == 3

const wchar_t* ws = L"你好";
size_t wn = yggr::charset::string_byte_size(ws); // wn == 2 * sizeof(wchar_t)
```

### 2. char_buffer_byte_size

- **功能**：计算字符串缓冲区所需的总字节数（包含结尾 0）。
- **支持类型**：同上。
- **实现机制**：在内容字节数基础上加上一个字符类型的字节数。

#### 示例

```cpp
std::string s = "abc";
size_t n = yggr::charset::char_buffer_byte_size(s); // n == 4

const wchar_t* ws = L"你好";
size_t wn = yggr::charset::char_buffer_byte_size(ws); // wn == (2 + 1) * sizeof(wchar_t)
```

---

## 设计说明

- **类型泛化**：通过模板和 SFINAE，支持多种字符串/字符类型，自动分派到最优实现。
- **类型安全**：所有类型均通过 `YGGR_ASSERT_CHAR_TYPE` 静态断言，防止非字符类型误用。
- **高效实现**：底层直接调用 `std::strlen`、`std::wcslen`、`std::char_traits::length` 等，无额外开销。
- **可扩展性**：便于扩展支持自定义字符串类型和字符类型。

---

## 用法示例

```cpp
#include <yggr/charset/string_byte_size.hpp>
#include <string>
#include <vector>

std::string s = "hello";
size_t bytes = yggr::charset::string_byte_size(s); // 5

wchar_t ws[] = L"世界";
size_t wbytes = yggr::charset::char_buffer_byte_size(ws); // (2+1)*sizeof(wchar_t)
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型，请确保其满足相关 traits 的特化条件。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # string_charset_helper.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了**字符串与字符集信息绑定的泛型辅助工具**，即 `string_charset_helper` 及其相关工具函数和类型 traits。它用于在泛型编程中，将字符串数据与其字符集（编码）信息一同传递和管理，极大方便了多字符集环境下的字符串处理、编码转换等场景。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`string_charset_helper<T1, T2>`
- **辅助 traits**：`is_string_charset_helper`、`is_string_charset_helper_ex`
- **辅助函数**：`make_string_charset_helper`、`string_charset_helper_data`、`string_charset_helper_first`、`string_charset_helper_second`
- **类型萃取**：`string_charset_helper_first_t`、`string_charset_helper_second_t`

---

## 主要功能

### 1. string_charset_helper 类模板

```cpp
template<typename T1, typename T2 = const yggr::string&>
class string_charset_helper;
```

- **功能**：将字符串数据（T1）与字符集名称（T2，通常为 `const string&`）绑定在一起，形成一个二元组对象。
- **成员变量**：
  - `first`：字符串数据（如 char、wchar_t、const char*、std::string、std::wstring 等）
  - `second`：字符集名称（如 "utf-8", "gbk", "utf-16le" 等）
- **不可移动**：继承自 `nonable::nonmoveable`，防止误用。

### 2. 类型 traits

- `is_string_charset_helper<T>`  
  判断类型 T 是否为 `string_charset_helper` 实例。
- `is_string_charset_helper_ex<T>`  
  支持去除 const/reference 修饰后的判断。
- `is_convertible_utf8_string<string_charset_helper<T1, T2>>`  
  标记 string_charset_helper 可用于 UTF-8 字符串转换。

### 3. 类型萃取

- `string_charset_helper_first_t<T>`  
  获取 string_charset_helper 的第一个模板参数类型（字符串类型）。
- `string_charset_helper_second_t<T>`  
  获取 string_charset_helper 的第二个模板参数类型（字符集名称类型）。

### 4. 辅助构造函数

- `make_string_charset_helper(...)`  
  支持多种输入类型（char、wchar_t、char*、const char*、std::string、std::wstring、字符串视图等），自动推导字符集名称并生成 string_charset_helper 对象。也可手动指定字符集名称。
- 支持对字符串对象、字符串视图、C 风格字符串等的重载，便于泛型调用。

### 5. 数据访问与解包

- `string_charset_helper_first(...)`  
  获取 string_charset_helper 的字符串数据部分。
- `string_charset_helper_second(...)`  
  获取 string_charset_helper 的字符集名称部分。

### 6. 兼容 UTF-8 工具

- 支持与 `utf8_string_t_getter` 等 UTF-8 工具类协作，便于自动编码转换。

---

## 设计说明

- **泛型友好**：支持任意字符串类型、字符类型、字符串视图、标准字符串、boost 字符串等。
- **类型安全**：大量使用 SFINAE、traits、enable_if，防止类型误用。
- **自动编码适配**：默认自动推导字符集名称，也可手动指定，适合多编码环境。
- **高效实现**：所有辅助函数均为 inline，零额外开销。
- **与 yggdrasil 框架深度集成**：依赖于框架的字符串类型、traits、编码配置等。

---

## 用法示例

```cpp
#include <yggr/charset/string_charset_helper.hpp>
#include <string>

// 绑定 char 字符和编码
auto h1 = yggr::charset::make_string_charset_helper('A'); // 默认编码 "utf-8"

// 绑定 C 风格字符串和编码
auto h2 = yggr::charset::make_string_charset_helper("hello", "gbk");

// 绑定 std::string 和编码
std::string s = "你好";
auto h3 = yggr::charset::make_string_charset_helper(s);

// 获取数据和编码
auto str = yggr::charset::string_charset_helper_first(h3); // std::string
auto charset = yggr::charset::string_charset_helper_second(h3); // "utf-8"
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型或编码，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # string_converter.hpp 文档

该头文件定义了 yggdrasil 框架字符集模块中的 `string_converter` 工具类，为**不同字符串类型之间的高效转换**提供了统一泛型接口。支持标准字符串、boost 字符串、utf8_string 及其同构类型之间的零拷贝、编码转换、分配器适配等多种场景，适合多字符集、多容器环境下的高性能字符串处理。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`string_converter`（仅静态方法）
- **内部实现**：`detail::conv_helper` 模板结构体，针对不同类型组合特化

---

## 主要功能

### 1. 字符串类型泛型转换

- 支持任意字符串类型（如 `std::basic_string`、`boost::container::basic_string`、`utf8_string_impl` 等）之间的转换。
- 支持同类型字符串的零拷贝（直接返回引用）。
- 支持不同类型字符串的内容拷贝或编码转换。
- 支持分配器自定义，适合自定义内存管理场景。

### 2. 字符集编码转换

- 支持指定源字符串和目标字符串的字符集编码（如 UTF-8、GBK、UTF-16 等）。
- 若源编码与目标编码一致，则直接拷贝或零拷贝；否则自动进行编码转换。
- 内部调用 `charset_foo::s_xchg` 实现底层转换。

### 3. utf8_string 与其他类型互转

- 针对 `utf8_string_impl` 与其他字符串类型的互转做了专门特化，保证编码正确和高效。
- 支持 utf8_string 的构造、赋值、分配器适配等。

### 4. 支持多种调用方式

- 支持返回新字符串对象（值语义）。
- 支持原地赋值（引用语义）。
- 支持移动语义（BOOST_RV_REF）。
- 支持带分配器的构造和赋值。

### 5. SFINAE 与类型安全

- 大量使用 Boost.TypeTraits、Boost.MPL、enable_if/disable_if，保证类型安全和最优分派。
- 针对同类型、不同类型、utf8_string 相关类型等多种组合做了静态分派。

---

## 设计说明

- **高效实现**：同类型零拷贝，不同类型自动选择最优拷贝或编码转换路径。
- **类型安全**：通过 SFINAE、traits、静态断言，防止类型误用。
- **泛型友好**：支持任意字符串类型、分配器、编码组合，适合模板编程和大规模工程。
- **与 yggdrasil 框架深度集成**：依赖于框架的字符串类型、traits、分配器、编码配置等。

---

## 用法示例

```cpp
#include <yggr/charset/string_converter.hpp>
#include <string>
#include <boost/container/string.hpp>
#include <yggr/charset/utf8_string.hpp>

// std::string 转 boost::container::string
std::string s = "hello";
boost::container::string bs = yggr::charset::string_converter::s_conv<boost::container::string>(s);

// boost::container::string 转 utf8_string
yggr::charset::utf8_string us = yggr::charset::string_converter::s_conv<yggr::charset::utf8_string>(bs);

// 指定编码转换
std::string gbk_str = yggr::charset::string_converter::s_conv<std::string>(us, "utf-8", "gbk");
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型、分配器或编码，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # string_decl.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了**字符串类型声明与适配**，统一了标准字符串（STL）与 Boost.Container 字符串的类型定义。通过宏控制，可灵活切换使用 STL 或 Boost 字符串类型，并为多字符类型（char、wchar_t、char8_t、char16_t、char32_t）提供统一的字符串类型别名，便于跨平台、多编码环境下的泛型编程。

---

## 主要内容

- **命名空间**：`yggr::charset`、yggr
- **核心类型**：
  - `basic_string`
  - `string`
  - `wstring`
  - `u8string`
  - `u16string`
  - `u32string`
- **宏控制**：
  - `YGGR_USE_BOOST_STRING`：优先使用 Boost.Container 字符串
  - `YGGR_USE_STL_STRING`：优先使用 STL 字符串
  - `YGGR_NO_CWCHAR`、`YGGR_NO_CHAR8_T`、`YGGR_NO_CHAR16_T`、`YGGR_NO_CHAR32_T`：控制是否启用对应字符类型

---

## 主要功能

### 1. 字符串类型适配

- **Boost.Container 字符串**  
  若未定义 `YGGR_USE_STL_STRING`，则默认使用 Boost.Container 的 `basic_string`、`string`、`wstring`、`u8string`、`u16string`、`u32string`。
- **STL 字符串**  
  若定义了 `YGGR_USE_STL_STRING`，则使用标准库的 `std::basic_string`、`std::string`、`std::wstring`、`std::u8string`、`std::u16string`、`std::u32string`。
- **类型别名**  
  在 `yggr::charset` 命名空间下定义统一的字符串类型别名，并在 yggr 命名空间下导出，便于全局使用。

### 2. 多字符类型支持

- 通过条件编译，自动适配是否支持 `wchar_t`、`char8_t`、`char16_t`、`char32_t`，并为每种类型提供对应的字符串类型别名。

### 3. 兼容性与扩展性

- 支持 Boost 及 STL 字符串类型的无缝切换，便于根据项目需求灵活选择。
- 通过宏控制，适配不同平台和编译器对字符类型的支持。

---

## 用法示例

```cpp
#include <yggr/charset/string_decl.hpp>

yggr::string s = "hello";
yggr::charset::wstring ws = L"世界";
yggr::u16string u16s = u"你好";
```

---

## 设计说明

- **统一接口**：无论底层使用 STL 还是 Boost，外部代码均可通过 `yggr::string`、`yggr::charset::string` 等统一类型名访问字符串类型。
- **类型安全**：通过条件编译和类型别名，保证类型一致性和安全性。
- **跨平台支持**：自动适配不同平台和编译器对多字符类型的支持。

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型或字符类型，请调整宏定义或类型别名。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # string_hash.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 Boost.Container 字符串类型的哈希支持，便于在基于哈希的容器（如 `std::unordered_map`、`std::unordered_set`）中直接使用 `boost::container::basic_string` 作为键。它通过适配标准库的 `std::hash`，实现了与 STL 字符串一致的哈希行为。

---

## 主要内容

- **命名空间**：`std`
- **核心模板**：`std::hash<boost::container::basic_string<Char, Traits, Alloc>>`
- **依赖**：
  - string_decl.hpp：字符串类型声明
  - `boost/functional/hash.hpp`：Boost 哈希实现

---

## 主要功能

### 1. std::hash 特化

```cpp
template<typename Char, typename Traits, typename Alloc>
struct hash<boost::container::basic_string<Char, Traits, Alloc>>
{
    typedef boost::container::basic_string<Char, Traits, Alloc> type;

    inline std::size_t operator()(const type& str) const 
    {
        boost::hash<type> hasher; 
        return hasher(str); 
    }
};
```

- **功能**：为 `boost::container::basic_string` 提供标准哈希接口，允许其作为哈希容器的键。
- **实现机制**：内部调用 `boost::hash`，保证哈希行为与 Boost 一致。
- **启用条件**：仅在定义了 `YGGR_HAS_CXX11_STD_HASH` 宏时生效（即 C++11 及以上，且支持 `std::hash`）。

---

## 设计说明

- **兼容性**：解决 Boost 字符串类型在标准哈希容器中无法直接作为键的问题。
- **高效实现**：复用 Boost 的高效哈希算法，无需额外实现。
- **类型安全**：仅对 `boost::container::basic_string` 及其特化类型生效，不影响其他类型。

---

## 用法示例

```cpp
#include <yggr/charset/string_hash.hpp>
#include <boost/container/string.hpp>
#include <unordered_map>

std::unordered_map<boost::container::string, int> my_map;
my_map["hello"] = 42;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型的哈希，请特化 `std::hash` 并实现对应哈希算法。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # string_view_decl.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了**字符串视图类型的前置声明**，即 `basic_string_view` 模板类。它为后续实现字符串视图（类似于 C++17 的 `std::basic_string_view`）提供类型声明基础，便于在头文件依赖较多或需要提前声明类型的场景下使用。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：`basic_string_view<CharT, Traits>`

---

## 主要功能

### 1. basic_string_view 前置声明

```cpp
template<typename CharT, typename Traits = typename basic_string<CharT>::traits_type >
class basic_string_view;
```

- **功能**：声明了一个泛型字符串视图类型，支持自定义字符类型和 traits。
- **默认 traits**：若未指定，自动使用 `basic_string<CharT>` 的 traits_type，保证与字符串类型兼容。
- **适用场景**：用于需要提前声明字符串视图类型的头文件，避免头文件循环依赖或减少编译开销。

---

## 设计说明

- **类型兼容**：与 `yggr::charset::basic_string` 保持 traits 一致，便于字符串与字符串视图的无缝协作。
- **泛型友好**：支持任意字符类型和 traits，适合多字符集、多编码环境。
- **轻量声明**：仅做类型声明，无需包含完整实现，减少编译依赖。

---

## 用法示例

```cpp
#include <yggr/charset/string_view_decl.hpp>

yggr::charset::basic_string_view<char> sv;
yggr::charset::basic_string_view<wchar_t> wsv;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需完整功能和实现，请包含对应的实现头文件。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # string_view_impl.hpp 文档

该头文件实现了 yggdrasil 框架自定义的 `basic_string_view`，为任意字符类型和 traits 提供轻量级、零拷贝的字符串视图功能。它兼容 C++17 `std::string_view` 的大部分接口，并扩展了与 STL/Boost 字符串、字符串视图的比较、拼接、哈希等操作，适用于高性能、泛型的字符串处理场景。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类型**：`basic_string_view<CharT, Traits>`
- **辅助 traits/工具**：比较器、not_within traits、swap、hash、与 STL/Boost 字符串的互操作

---

## 主要功能

### 1. basic_string_view 类模板

- **模板参数**：
  - `CharT`：字符类型（如 char、wchar_t、char16_t、char32_t 等）
  - `Traits`：字符 traits，默认与 `basic_string<CharT>` 保持一致
- **成员类型**：包括指针、引用、迭代器、反向迭代器、size_type、difference_type 等
- **构造函数**：
  - 默认构造（空视图）
  - 由 C 字符串指针、指针+长度、迭代器区间、拷贝/移动构造
- **迭代器接口**：begin/end/rbegin/rend 及其 const 版本
- **元素访问**：operator[]、at、front、back、data
- **容量相关**：size、length、max_size、empty
- **修饰操作**：remove_prefix、remove_suffix
- **内容操作**：
  - copy：拷贝内容到外部缓冲区
  - substr：获取子视图
  - compare/compare_eq：多种重载，支持与视图、C 字符串比较
  - starts_with/ends_with/contains：前缀、后缀、包含判断
  - find/rfind/find_first_of/find_last_of/find_first_not_of/find_last_not_of：多种查找接口
- **哈希**：hash()，支持与 Boost/std::hash 集成

### 2. 非成员操作符重载

- **视图间比较**：==, !=, <, <=, >, >=，支持同模板和不同模板的 string_view
- **与 STL/Boost 字符串比较**：==, !=, <, <=, >, >=
- **与 C 字符串比较**：==, !=, <, <=, >, >=
- **拼接操作**：operator+ 支持 string + string_view、string_view + string
- **追加操作**：operator+= 支持 string += string_view

### 3. IO 支持

- **operator<<**：支持将 string_view 输出到 std::ostream，自动处理对齐和填充

### 4. swap 支持

- **swap**：全局 swap 支持，兼容 std/boost/yggr

### 5. 哈希支持

- **hash_value**：Boost 哈希支持
- **std::hash**：C++11 及以上支持 std::hash

### 6. traits 支持

- **is_basic_string_view_t**：类型 traits，标记为 string_view 类型
- **charset_name_t_string_view_impl**：自动推导 string_view 的默认字符集名称

---

## 设计说明

- **零拷贝**：所有视图操作均不拷贝底层数据，仅保存指针和长度
- **泛型友好**：支持任意字符类型、traits，兼容 STL/Boost 字符串
- **高性能**：接口设计与 STL 保持一致，底层直接操作指针
- **类型安全**：大量使用 SFINAE、traits 保证类型安全
- **兼容性强**：支持与 STL/Boost 字符串、C 字符串、不同模板 string_view 的互操作
- **扩展性好**：可作为自定义字符串库的基础组件

---

## 用法示例

```cpp
#include <yggr/charset/string_view_impl.hpp>
#include <string>

using yggr::charset::basic_string_view;

std::string s = "hello world";
basic_string_view<char> sv(s.data(), s.size());

if (sv.starts_with("hello")) {
    // ...
}

std::cout << sv << std::endl; // 支持流输出

std::string s2 = "world";
if (sv.find(s2) != basic_string_view<char>::npos) {
    // ...
}
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符类型、traits 或与其他字符串类型的互操作，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # string_view.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了**字符串视图类型的统一接口与适配**，包括 `basic_string_view` 及其常用别名（如 `string_view`、`wstring_view` 等），并实现了与标准输出流的兼容。它是 yggdrasil 字符串视图体系的入口文件，适用于高性能、零拷贝的字符串处理场景。

---

## 主要内容

- **命名空间**：`yggr::charset`、yggr
- **核心类型**：
  - `basic_string_view<CharT, Traits>`
  - 类型别名：`string_view`、`wstring_view`、`u8string_view`、`u16string_view`、`u32string_view`
- **输出流重载**：支持将 string_view 直接输出到 `std::ostream`/`std::wostream` 等流对象
- **依赖**：
  - `string_decl.hpp`：字符串类型声明
  - `charset_foo.hpp`：字符集转换工具
  - `string_view_impl.hpp`：string_view 实现

---

## 主要功能

### 1. 输出流重载

```cpp
template <typename CharT_OS, typename Traits_OS, typename CharT, typename Traits>
std::basic_ostream<CharT_OS, Traits_OS>&
operator<<(std::basic_ostream<CharT_OS, Traits_OS>& os, const basic_string_view<CharT, Traits>& s);
```
- **功能**：支持将任意字符类型的 `basic_string_view` 输出到任意字符类型的输出流（如 `std::ostream`、`std::wostream`）。
- **实现机制**：自动进行字符集转换（如 UTF-8 到 UTF-16），保证输出内容正确。
- **适用场景**：跨编码输出、日志打印、调试等。

### 2. 字符串视图类型别名

- `string_view`：`basic_string_view<char>`
- `wstring_view`：`basic_string_view<wchar_t>`
- `u8string_view`：`basic_string_view<yggr::c8>`
- `u16string_view`：`basic_string_view<yggr::c16>`
- `u32string_view`：`basic_string_view<yggr::c32>`

> 注：各类型别名的可用性由宏（如 `YGGR_NO_CWCHAR`、`YGGR_NO_CHAR8_T` 等）控制，自动适配平台和编译器特性。

### 3. 全局 using 导出

- 在 yggr 命名空间下导出常用 string_view 类型，便于全局统一访问。

---

## 设计说明

- **类型兼容**：支持多字符类型、多 traits，适合多编码、多平台环境。
- **零拷贝**：string_view 仅保存指针和长度，不拷贝底层数据，效率高。
- **自动编码适配**：输出流重载自动处理字符集转换，保证跨平台输出一致性。
- **泛型友好**：所有接口均为模板，适合泛型编程和大规模工程。

---

## 用法示例

```cpp
#include <yggr/charset/string_view.hpp>
#include <iostream>

yggr::string_view sv = "hello world";
std::cout << sv << std::endl; // 自动输出

yggr::charset::wstring_view wsv = L"你好";
std::wcout << wsv << std::endl; // 自动输出
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符类型、traits 或与其他字符串类型的互操作，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # string.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了**字符串类型适配、工具函数与特性扩展**，统一支持 STL 字符串和 Boost.Container 字符串，并为泛型编程、类型安全、跨编码/跨容器字符串操作提供了丰富的辅助接口。它是 yggdrasil 字符串体系的核心适配层，适用于多字符集、多容器环境下的高性能字符串处理。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **适配类型**：`std::basic_string`、`boost::container::basic_string`
- **主要功能**：
  - 流操作符适配（输入/输出）
  - 同构字符串类型间的比较与交换
  - getline 适配与实现
  - shrink_to_fit 适配
  - 字符串类型 traits 与泛型工具
  - 字符串有效性检查
  - 字符串类型自动推导与 traits
  - 字符串原始数据与长度适配

---

## 主要功能详解

### 1. 流操作符适配

- **输出流重载**  
  支持 `boost::container::basic_string` 与任意字符类型输出流的互操作，自动进行字符集转换。
- **输入流重载**  
  支持 `boost::container::basic_string` 从任意字符类型输入流读取内容，并自动进行字符集转换。

### 2. 同构字符串类型间的比较与交换（Boost 1.70+）

- 支持不同 allocator 的 `boost::container::basic_string` 之间的 `==`, `!=`, `<`, `<=`, `>`, `>=` 比较，底层通过 reinterpret_cast 实现零拷贝比较。
- 支持同构字符串类型间的 swap，自动适配 allocator。

### 3. getline 适配与实现

- 提供 `yggr::charset::getline` 重载，支持 `boost::container::basic_string` 与标准流的互操作，兼容 STL getline 行为。

### 4. shrink_to_fit 适配

- 对 STL/Boost 字符串类型，自动适配 shrink_to_fit（若无 shrink_to_fit，则通过 swap 实现容量收缩）。

### 5. 字符串类型 traits 与泛型工具

- `string_t_getter`：根据当前字符串类型和目标类型，自动推导返回类型（引用或新对象）。
- `basic_string_getter`：统一获取 STL/Boost 字符串的引用。
- `string_traits`：自动萃取字符串类型的 char_type、traits_type、allocator_type、迭代器等信息。

### 6. 字符串有效性检查

- `is_validate_char`：判断字符类型是否合法。
- `is_validate_string`：判断字符串内容与长度是否一致，防止非法字符串。

### 7. 字符串原始数据与长度适配

- `org_str`：获取原始字符串指针或引用，适配 C 风格字符串、数组、标准字符串等。
- `recount_length`：重新计算字符串长度，适配多种类型。
- `affix_length`：断言长度与内容一致，保证数据安全。

---

## 设计说明

- **类型兼容**：统一适配 STL/Boost 字符串类型，便于跨容器、跨编码开发。
- **泛型友好**：大量使用模板、SFINAE、traits，支持任意字符串类型和字符类型的泛型编程。
- **高效实现**：同构类型零拷贝，自动分派最优实现路径。
- **类型安全**：静态断言、traits 检查，防止类型误用。
- **与 yggdrasil 框架深度集成**：依赖于框架的类型 traits、编码工具、容器特性等。

---

## 用法示例

```cpp
#include <yggr/charset/string.hpp>
#include <boost/container/string.hpp>
#include <string>

// 流输出
boost::container::string bs = "hello";
std::cout << bs << std::endl;

// getline 适配
boost::container::string bs2;
std::getline(std::cin, bs2);

// shrink_to_fit
std::string s = "abc";
yggr::charset::shrink_to_fit(s);

// 字符串类型 traits
typedef yggr::charset::string_traits<std::string>::char_type my_char_t;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型、traits 或流适配，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_char_impl_decl.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 字符实现类 `utf8_char_impl` 的**前置声明**。它定义了一个高度泛型的 UTF-8 字符类型模板，为后续 UTF-8 字符相关功能（如 utf8 字符串、字符处理等）提供类型基础，便于在头文件依赖较多或需要提前声明类型的场景下使用。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：`utf8_char_impl<TChar, TTraits, TAlloc>`

---

## 主要功能

### 1. utf8_char_impl 前置声明

```cpp
template<
    typename TChar = char,
    typename TTraits = typename basic_string<TChar>::traits_type,
    typename TAlloc = typename mplex::typename_expand_get<basic_string<TChar>, 2>::type
>
class utf8_char_impl;
```

- **功能**：声明了一个泛型 UTF-8 字符类型，支持自定义字符类型、traits 和分配器。
- **默认参数**：
  - `TChar`：字符类型，默认为 `char`
  - `TTraits`：traits 类型，默认为 `basic_string<TChar>::traits_type`
  - `TAlloc`：分配器类型，默认为 `basic_string<TChar>` 的第三个模板参数（通常为 allocator）
- **适用场景**：用于需要提前声明 UTF-8 字符类型的头文件，避免头文件循环依赖或减少编译开销。

---

## 设计说明

- **类型兼容**：与 `yggr::charset::basic_string` 保持 traits 和 allocator 一致，便于与字符串类型协作。
- **泛型友好**：支持任意字符类型、traits 和分配器，适合多字符集、多编码环境。
- **轻量声明**：仅做类型声明，无需包含完整实现，减少编译依赖。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_char_impl_decl.hpp>

yggr::charset::utf8_char_impl<> c; // 默认 char 版本
yggr::charset::utf8_char_impl<wchar_t> wc; // wchar_t 版本
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需完整功能和实现，请包含对应的实现头文件。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_char_impl.hpp 文档

该头文件实现了 yggdrasil 框架中 UTF-8 单字符类型 `utf8_char_impl`，为 UTF-8 字符的存储、编码转换、算术运算、比较、流操作、哈希等提供了高度泛型和类型安全的支持。它是 UTF-8 字符串体系的基础组件，适用于多字符集、多容器环境下的高性能 UTF-8 字符处理。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类型**：`utf8_char_impl<TChar, TTraits, TAlloc>`
- **相关类型**：`utf8_string_impl`、`basic_utf8_char_view`、`basic_utf8_char_reference`、`string_charset_helper`
- **特性支持**：算术运算、比较、流输入输出、swap、哈希、类型 traits

---

## 主要功能

### 1. UTF-8 单字符泛型类型

- **模板参数**：
  - `TChar`：底层字符类型（通常为 `char`，仅支持 char）
  - `TTraits`：traits 类型（如 `std::char_traits<char>`）
  - `TAlloc`：分配器类型
- **本质**：内部以 `basic_string<TChar, TTraits, TAlloc>` 存储 UTF-8 字符的字节序列，始终保证只存储一个有效 UTF-8 字符。

### 2. 构造与赋值

- 支持从任意可转换为字符的类型、C 字符串、标准字符串、字符串视图、迭代器区间、initializer_list、其他 utf8_char_impl、utf8_string_impl、utf8_char_view/reference/const_reference、string_charset_helper 等多种类型构造和赋值。
- 支持指定源字符集编码，自动进行编码转换。
- 支持分配器自定义。

### 3. 算术与位运算

- 支持与数值类型、其他 utf8_char_impl、utf8_char_view/reference/const_reference 之间的 `+ - * / % << >>` 运算，结果为 utf8_char_impl 或数值类型。
- 支持自增、自减、复合赋值（+=、-=、*=、/=、%=、<<=、>>=）。
- 支持与数值类型的位运算（& | ^），结果为数值类型或 s32。

### 4. 比较操作

- 支持与字符、C 字符串、标准字符串、字符串视图、utf8_char_impl、utf8_char_view/reference/const_reference、string_charset_helper 等多种类型的 `== != < <= > >=` 比较。
- 比较时自动进行编码转换和内容比对。

### 5. 类型转换

- 支持隐式转换为底层字符串类型、utf8_string_impl、utf8_char_view/reference/const_reference、数值类型（to_number）。
- 支持显式转换为目标字符串类型（如 std::string、std::wstring）。

### 6. 其他成员函数

- `data()` / `c_str()`：获取底层数据指针
- `size()` / `length()`：获取字节长度/字符长度（始终为 1）
- `empty()`：判断是否为空（始终为 false）
- `is_validate()`：判断内容是否合法 UTF-8 字符
- `shrink_to_fit()`：收缩底层存储
- `org_str()` / `str()`：获取底层字符串或转换为目标字符串类型
- `view()`：获取字符串视图
- `hash()`：获取哈希值

### 7. swap 支持

- 支持与同构/异构 allocator 的 utf8_char_impl、底层字符串、utf8_char_reference 之间的高效 swap。

### 8. 流输入输出

- 支持与任意字符类型的 `std::basic_ostream`/`std::basic_istream` 互操作，自动进行编码转换。

### 9. 哈希与 Boost.Range 支持

- 支持 `boost::hash`、`std::hash`（C++11 及以上）直接对 utf8_char_impl 进行哈希。
- 支持 Boost.Range 的 range_size。

### 10. 类型 traits 与泛型支持

- `is_utf8_char_t`、`charset_name_t_string_impl`、`other_char`、`utf8_char_constructable`、`utf8_char_loadable` 等 traits，便于泛型编程和类型安全分派。

---

## 设计说明

- **类型安全**：大量使用 SFINAE、traits、静态断言，防止类型误用。
- **泛型友好**：支持任意字符串类型、字符类型、分配器、字符串视图等。
- **高效实现**：同构类型零拷贝，自动分派最优实现路径。
- **编码适配**：自动处理不同字符集编码的转换，保证内容正确。
- **与 yggdrasil 框架深度集成**：依赖于框架的字符串类型、traits、编码工具、容器特性等。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_char_impl.hpp>
#include <string>

using yggr::charset::utf8_char_impl;

// 构造
utf8_char_impl<char> c1('你');
utf8_char_impl<char> c2("好");
utf8_char_impl<char> c3(std::string("世"));

// 算术运算
auto c4 = c1 + 1;
auto c5 = c2 * 2;

// 比较
bool eq = (c1 == '你');
bool lt = (c1 < c2);

// 转换
std::string s = c1.str<std::string>();

// 流输出
std::cout << c1 << std::endl;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符类型、分配器或与其他字符串类型的互操作，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_char_reference_decl.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 字符引用类型的**前置声明**，即 `basic_utf8_char_reference` 和 `basic_utf8_char_const_reference`。它用于在头文件依赖较多或需要提前声明类型的场景下，避免循环依赖和减少编译开销，为后续 UTF-8 字符串和字符操作提供类型基础。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：
  - `basic_utf8_char_reference<Utf8String>`
  - `basic_utf8_char_const_reference<Utf8String>`

---

## 主要功能

### 1. 前置声明

```cpp
template<typename Utf8String>
class basic_utf8_char_reference;

template<typename Utf8String>
class basic_utf8_char_const_reference;
```

- **功能**：声明了两个泛型 UTF-8 字符引用类型，分别用于可修改和只读场景。
- **模板参数**：
  - `Utf8String`：底层 UTF-8 字符串类型（如 `utf8_string_impl` 等）。

### 2. 适用场景

- 用于需要提前声明 UTF-8 字符引用类型的头文件，避免头文件循环依赖或减少编译依赖。
- 便于在泛型编程、字符串视图、字符操作等场景下统一接口。

---

## 设计说明

- **类型兼容**：与 UTF-8 字符串类型保持一致，便于与字符串、字符视图等类型协作。
- **泛型友好**：支持任意 UTF-8 字符串类型，适合多字符集、多编码环境。
- **轻量声明**：仅做类型声明，无需包含完整实现，减少编译依赖。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_char_reference_decl.hpp>

yggr::charset::basic_utf8_char_reference<yggr::charset::utf8_string_impl<>> ref;
yggr::charset::basic_utf8_char_const_reference<yggr::charset::utf8_string_impl<>> cref;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需完整功能和实现，请包含对应的实现头文件。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_char_reference_impl.hpp 文档

该头文件实现了 yggdrasil 框架中 UTF-8 字符串的**单字符引用类型**（`basic_utf8_char_reference` 和 `basic_utf8_char_const_reference`），为 UTF-8 字符串中的单字符提供高效、类型安全、泛型的引用与只读引用支持。它支持算术运算、比较、流操作、swap、哈希、与原始字符串的互转等丰富功能，是 UTF-8 字符串体系的核心组件之一。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类型**：
  - `basic_utf8_char_reference<Utf8String>`：可修改的 UTF-8 单字符引用
  - `basic_utf8_char_const_reference<Utf8String>`：只读的 UTF-8 单字符引用
- **辅助 traits/工具**：类型 traits、swap、hash、与字符串/视图/数值类型的互操作

---

## 主要功能

### 1. 单字符引用与只读引用

- **引用语义**：可直接引用 UTF-8 字符串中的单个字符（支持多字节 UTF-8 字符），无需拷贝。
- **只读引用**：`basic_utf8_char_const_reference` 提供只读访问，适合常量上下文。

### 2. 构造与赋值

- 支持从字符串、迭代器、位置、其他引用类型等多种方式构造。
- 支持从字符、C 字符串、标准字符串、utf8_char_impl、utf8_char_view、string_charset_helper 等多种类型赋值。

### 3. 算术与位运算

- 支持与数值类型、其他引用/只读引用/视图/utf8_char_impl 之间的 `+ - * / % << >> & | ^` 运算。
- 支持自增、自减、复合赋值（+=、-=、*=、/=、%=、<<=、>>=）。
- 运算结果为 utf8_char_impl 或数值类型，自动处理编码和溢出。

### 4. 比较操作

- 支持与字符、C 字符串、标准字符串、utf8_char_impl、utf8_char_view、string_charset_helper、其他引用类型等多种类型的 `== != < <= > >=` 比较。
- 比较时自动进行编码转换和内容比对。

### 5. 类型转换与数据访问

- 支持隐式/显式转换为底层字符串类型、utf8_char_impl、utf8_char_view、数值类型（to_number）。
- 支持获取底层数据指针、长度、索引、allocator。
- 支持 org_str() 获取原始字符串内容，str() 获取转换后的字符串。

### 6. swap 支持

- 支持与 utf8_char_impl、其他引用类型、字符串类型之间的高效 swap。
- 提供 swap_support 命名空间，兼容 std/boost/yggr 的 swap 调用。

### 7. 流输入输出

- 支持与任意字符类型的 `std::basic_ostream`/`std::basic_istream` 互操作，自动进行编码转换。

### 8. 哈希与 Boost.Range 支持

- 支持 `boost::hash`、`std::hash`（C++11 及以上）直接对引用类型进行哈希。
- 支持 Boost.Range 的 range_size。
- 支持字节长度计算（byte_size）。

### 9. 泛型与类型 traits

- `is_utf8_char_reference_t`、`is_utf8_char_const_reference_t`、`charset_name_t` 等 traits，便于泛型编程和类型安全分派。
- 支持 make_string_charset_helper 工厂函数，将引用与编码信息绑定。

---

## 设计说明

- **高效实现**：所有操作均为引用语义，避免不必要的数据拷贝。
- **类型安全**：大量使用 SFINAE、traits、静态断言，防止类型误用。
- **泛型友好**：支持任意 UTF-8 字符串类型、分配器、视图、数值类型等。
- **编码适配**：自动处理不同字符集编码的转换，保证内容正确。
- **与 yggdrasil 框架深度集成**：依赖于框架的字符串类型、traits、编码工具、容器特性等。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_char_reference_impl.hpp>
#include <yggr/charset/utf8_string_impl.hpp>

using namespace yggr::charset;

utf8_string_impl<> ustr = u8"你好世界";
basic_utf8_char_reference<utf8_string_impl<>> cref(ustr, 1); // 引用第2个字符

// 赋值
cref = 'A';

// 算术运算
auto c2 = cref + 1;

// 比较
if (cref == '你') { /* ... */ }

// swap
utf8_char_impl<> cimpl("世");
swap(cref, cimpl);

// 流输出
std::cout << cref << std::endl;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型、分配器或与其他字符串类型的互操作，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_char_reference.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 字符串的**单字符引用类型**（utf8_char_reference 和 utf8_char_const_reference）的类型别名声明。它将泛型 UTF-8 字符引用类型（`basic_utf8_char_reference` 和 `basic_utf8_char_const_reference`）与默认 UTF-8 字符串实现（`utf8_string_impl<>`）结合，便于在项目中直接使用高效、类型安全的 UTF-8 单字符引用。

---

## 主要内容

- **命名空间**：`yggr::charset`、yggr
- **核心类型别名**：
  - `utf8_char_reference`
  - `utf8_char_const_reference`
- **依赖**：
  - `utf8_string_impl.hpp`
  - `utf8_string_view_impl.hpp`
  - `utf8_string_iterator.hpp`
  - `utf8_char_impl.hpp`
  - `utf8_char_view_impl.hpp`
  - `utf8_char_reference_impl.hpp`

---

## 主要功能

### 1. 类型别名声明

```cpp
typedef basic_utf8_char_reference< utf8_string_impl<> > utf8_char_reference;
typedef basic_utf8_char_const_reference< utf8_string_impl<> > utf8_char_const_reference;
```

- **功能**：将泛型 UTF-8 字符引用类型与默认 UTF-8 字符串实现绑定，便于直接使用。
- **适用场景**：需要对 UTF-8 字符串中的单个字符进行高效引用、只读引用、操作、比较、流输出等。

### 2. 全局 using 导出

- 在 yggr 命名空间下导出 `utf8_char_reference` 和 `utf8_char_const_reference`，便于全局统一访问。

---

## 设计说明

- **类型安全**：通过泛型实现，保证与 UTF-8 字符串类型兼容。
- **高效实现**：引用语义，避免不必要的数据拷贝，适合高性能字符串处理。
- **易用性**：直接提供常用类型别名，简化泛型模板的使用。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_char_reference.hpp>
#include <yggr/charset/utf8_string_impl.hpp>

yggr::charset::utf8_string_impl<> ustr = u8"你好世界";
yggr::utf8_char_reference cref(ustr, 1); // 引用第2个字符
yggr::utf8_char_const_reference ccref(ustr, 0); // 只读引用第1个字符

std::cout << cref << std::endl;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义 UTF-8 字符串类型，请使用 `basic_utf8_char_reference` 模板并指定对应的字符串类型。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_char_view_decl.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 单字符视图类型 `basic_utf8_char_view` 的**前置声明**。它用于在头文件依赖较多或需要提前声明类型的场景下，避免循环依赖和减少编译开销，为后续 UTF-8 字符串和字符操作提供类型基础。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：`basic_utf8_char_view<TChar, TTraits>`

---

## 主要功能

### 1. 前置声明

```cpp
template<
    typename TChar = char,
    typename TTraits = typename basic_string<TChar>::traits_type
>
class basic_utf8_char_view;
```

- **功能**：声明了一个泛型 UTF-8 单字符视图类型，支持自定义字符类型和 traits。
- **默认参数**：
  - `TChar`：字符类型，默认为 `char`
  - `TTraits`：traits 类型，默认为 `basic_string<TChar>::traits_type`
- **适用场景**：用于需要提前声明 UTF-8 单字符视图类型的头文件，避免头文件循环依赖或减少编译依赖。

---

## 设计说明

- **类型兼容**：与 `yggr::charset::basic_string` 保持 traits 一致，便于与字符串类型协作。
- **泛型友好**：支持任意字符类型和 traits，适合多字符集、多编码环境。
- **轻量声明**：仅做类型声明，无需包含完整实现，减少编译依赖。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_char_view_decl.hpp>

yggr::charset::basic_utf8_char_view<> v; // 默认 char 版本
yggr::charset::basic_utf8_char_view<wchar_t> wv; // wchar_t 版本
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需完整功能和实现，请包含对应的实现头文件。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_char_view_impl.hpp 文档

该头文件实现了 yggdrasil 框架中 UTF-8 单字符视图类型 `basic_utf8_char_view`，为 UTF-8 字符串中的单字符提供零拷贝、类型安全、泛型的只读视图。它支持与多种字符串类型、UTF-8 字符类型、数值类型的高效互操作，适用于高性能 UTF-8 字符串处理、泛型算法、容器操作等场景。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类型**：`basic_utf8_char_view<TChar, TTraits>`
- **特性支持**：算术运算、比较、流操作、hash、与原始字符串/utf8_char_impl/utf8_char_reference的互操作、Boost.Range/字节长度支持

---

## 主要功能

### 1. UTF-8 单字符视图类型

- **模板参数**：
  - `TChar`：底层字符类型（通常为 `char`）
  - `TTraits`：traits 类型（如 `std::char_traits<char>`）
- **本质**：内部仅保存一个指向 UTF-8 字符起始位置的指针（不拥有数据），所有操作均为只读视图。

### 2. 构造与赋值

- 支持从原始指针、迭代器、utf8_char_impl、utf8_string_impl、utf8_char_reference、utf8_char_const_reference、其他 utf8_char_view 等多种类型构造。
- 支持拷贝、移动、赋值等操作。

### 3. 类型转换

- 支持隐式/显式转换为底层字符串类型、utf8_char_impl、其他 utf8_char_view、数值类型（to_number）。
- 支持转换为任意字符串类型（如 std::string、std::wstring、boost::container::string 等），自动进行编码转换。

### 4. 数据访问与属性

- `data()`/`operator&`：获取底层数据指针
- `size()`/`length()`：获取字节长度/字符长度（始终为 1）
- `begin()`/`end()`：获取只读迭代器
- `is_validate()`：判断是否为有效 UTF-8 字符
- `is_same_address()`：判断与其他视图/引用/字符类型是否指向同一地址

### 5. 算术与位运算

- 支持与数值类型、其他 utf8_char_view/utf8_char_impl/utf8_char_reference 之间的 `+ - * / % << >> & | ^` 运算。
- 运算结果为 utf8_char_impl 或数值类型，自动处理编码和溢出。

### 6. 比较操作

- 支持与字符、C 字符串、标准字符串、utf8_char_impl、utf8_char_reference、string_charset_helper 等多种类型的 `== != < <= > >=` 比较。
- 比较时自动进行编码转换和内容比对。

### 7. 字符串转换

- `org_str()`：获取原始字符串内容
- `str()`：获取 UTF-8 字符串或转换为目标字符串类型
- `view()`：获取自身或转换为其他视图类型

### 8. hash 支持

- `hash()`：获取哈希值
- 支持 `boost::hash`、`std::hash`（C++11 及以上）直接对 utf8_char_view 进行哈希

### 9. Boost.Range 与字节长度支持

- 支持 Boost.Range 的 range_size
- 支持字节长度计算（byte_size）

### 10. 流输出

- 支持与任意字符类型的 `std::basic_ostream` 互操作，自动进行编码转换

### 11. 泛型与类型 traits

- `is_utf8_char_view_t`、`charset_name_t_string_view_impl` 等 traits，便于泛型编程和类型安全分派
- 支持 make_string_charset_helper 工厂函数，将视图与编码信息绑定

---

## 设计说明

- **零拷贝**：所有操作均为只读视图，不拷贝底层数据，效率极高
- **类型安全**：大量使用 SFINAE、traits、静态断言，防止类型误用
- **泛型友好**：支持任意字符串类型、字符类型、视图、数值类型等
- **编码适配**：自动处理不同字符集编码的转换，保证内容正确
- **与 yggdrasil 框架深度集成**：依赖于框架的字符串类型、traits、编码工具、容器特性等

---

## 用法示例

```cpp
#include <yggr/charset/utf8_char_view_impl.hpp>
#include <yggr/charset/utf8_string_impl.hpp>

using namespace yggr::charset;

utf8_string_impl<> ustr = u8"你好世界";
basic_utf8_char_view<char> v1(ustr, 1); // 视图第2个字符

// 转换为 std::string
std::string s = v1;

// 算术运算
auto c2 = v1 + 1;

// 比较
if (v1 == "好") { /* ... */ }

// 流输出
std::cout << v1 << std::endl;

// 获取原始数据
auto raw = v1.org_str();
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型、分配器或与其他字符串类型的互操作，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_char_view.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 单字符视图类型 `utf8_char_view` 的类型别名声明。它将泛型 UTF-8 单字符视图类型（`basic_utf8_char_view<char>`）与默认实现绑定，便于在项目中直接使用高效、类型安全的 UTF-8 单字符只读视图。

---

## 主要内容

- **命名空间**：`yggr::charset`、yggr
- **核心类型别名**：
  - `utf8_char_view`（等价于 `basic_utf8_char_view<char>`）
- **依赖**：
  - `utf8_string_impl.hpp`
  - `utf8_string_view_impl.hpp`
  - `utf8_string_iterator.hpp`
  - `utf8_char_impl.hpp`
  - `utf8_char_view_impl.hpp`
  - `utf8_char_reference_impl.hpp`

---

## 主要功能

### 1. 类型别名声明

```cpp
typedef basic_utf8_char_view<char> utf8_char_view;
```

- **功能**：将泛型 UTF-8 单字符视图类型与默认 char 实现绑定，便于直接使用。
- **适用场景**：需要对 UTF-8 字符串中的单个字符进行高效只读视图、比较、流输出、算术运算等。

### 2. 全局 using 导出

- 在 yggr 命名空间下导出 `utf8_char_view`，便于全局统一访问。

---

## 设计说明

- **类型安全**：通过泛型实现，保证与 UTF-8 字符串类型兼容。
- **高效实现**：只读视图，零拷贝，适合高性能字符串处理。
- **易用性**：直接提供常用类型别名，简化泛型模板的使用。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_char_view.hpp>
#include <yggr/charset/utf8_string_impl.hpp>

yggr::charset::utf8_string_impl<> ustr = u8"你好世界";
yggr::utf8_char_view v(ustr, 1); // 视图第2个字符

std::cout << v << std::endl;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义 UTF-8 字符类型，请使用 `basic_utf8_char_view` 模板并指定对应的字符类型。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_char.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 单字符类型 `utf8_char` 的类型定义及相关泛型类型推导宏。它统一了 UTF-8 字符的类型接口，便于在泛型编程、模板推导、类型安全转换等场景下高效处理 UTF-8 单字符。

---

## 主要内容

- **命名空间**：`yggr::charset`、yggr
- **核心类型**：`utf8_char_impl<>` 的类型别名 `utf8_char`
- **类型推导工具**：`utf8_char_t_getter` 模板结构体
- **类型推导宏**：多组宏定义，便于自动推导 UTF-8 字符类型

---

## 主要功能

### 1. utf8_char 类型别名

```cpp
typedef utf8_char_impl<> utf8_char;
```
- **功能**：将默认模板参数的 `utf8_char_impl` 作为 UTF-8 单字符类型，便于直接使用。
- **适用场景**：需要高效、类型安全地处理 UTF-8 单字符的场合。

### 2. utf8_char_t_getter 泛型类型推导

```cpp
template<typename Char, typename Utf8_Char>
struct utf8_char_t_getter : public mplex::get_reference_if_same<Char, Utf8_Char> { ... };
```
- **功能**：根据输入类型 `Char` 和目标 UTF-8 字符类型 `Utf8_Char`，自动推导出合适的类型（引用或对象）。
- **特化**：对 `string_charset_helper` 类型做了专门适配，保证泛型场景下类型推导正确。
- **类型安全**：通过 `BOOST_MPL_ASSERT` 静态断言，保证 `Utf8_Char` 必须为 UTF-8 字符类型。

### 3. 类型推导宏

- **常用宏**：
  - `YGGR_TYPEDEF_UTF8_CHAR_TYPE(__char_t__, __utf8_char_t_name__)`
  - `YGGR_TYPEDEF_CONST_UTF8_CHAR_TYPE(__char_t__, __utf8_char_t_name__)`
  - `YGGR_TYPEDEF_UTF8_CHAR_TYPE_TPL(__char_t__, __utf8_char_t_name__)`
  - `YGGR_TYPEDEF_CONST_UTF8_CHAR_TYPE_TPL(__char_t__, __utf8_char_t_name__)`
- **自定义 UTF-8 字符类型宏**：
  - `YGGR_TYPEDEF_CUSTOM_UTF8_CHAR_TYPE(__char_t__, __cmp_utf8_char_t__, __utf8_char_t_name__)`
  - `YGGR_TYPEDEF_CUSTOM_CONST_UTF8_CHAR_TYPE(__char_t__, __cmp_utf8_char_t__, __utf8_char_t_name__)`
  - `YGGR_TYPEDEF_CUSTOM_UTF8_CHAR_TYPE_TPL(__char_t__, __cmp_utf8_char_t__, __utf8_char_t_name__)`
  - `YGGR_TYPEDEF_CUSTOM_CONST_UTF8_CHAR_TYPE_TPL(__char_t__, __cmp_utf8_char_t__, __utf8_char_t_name__)`
- **功能**：根据输入类型和目标 UTF-8 字符类型，自动生成合适的类型别名，支持模板和非模板场景，便于泛型代码中类型适配。

---

## 设计说明

- **类型安全**：通过静态断言和类型 traits，保证类型推导的正确性和安全性。
- **泛型友好**：支持任意字符类型、UTF-8 字符类型、string_charset_helper 等复杂类型的自动推导。
- **易用性**：通过类型别名和宏，极大简化了泛型模板代码中的类型声明和适配。
- **与 yggdrasil 框架深度集成**：依赖于框架的 UTF-8 字符串、字符类型、traits 等。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_char.hpp>

// 直接使用 utf8_char
yggr::charset::utf8_char c = '你';

// 泛型推导
YGGR_TYPEDEF_UTF8_CHAR_TYPE(char, my_utf8_char_t);
my_utf8_char_t c2 = '好';

// 自定义类型推导
YGGR_TYPEDEF_CUSTOM_UTF8_CHAR_TYPE(char, yggr::charset::utf8_char_impl<wchar_t>, my_custom_utf8_char_t);
my_custom_utf8_char_t c3 = L'世';
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义 UTF-8 字符类型，请使用相关宏或特化 `utf8_char_t_getter`。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_foo.hpp 文档

该头文件定义了 yggdrasil 框架字符集模块中的 UTF-8 工具类 `utf8_foo`，为 UTF-8 字符和字符串的**编码、解码、长度计算、比较、查找、转换等底层操作**提供了高效、类型安全的静态工具方法。它是 UTF-8 字符串体系的核心基础设施，适用于多字符集、多容器环境下的高性能 UTF-8 字符串处理。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类**：`utf8_foo`（不可实例化，仅静态方法）
- **主要常量**：
  - `E_char_max_size`：单个 UTF-8 字符最大字节数（4 或 6，取决于宏）
  - `E_char_max_num`：支持的最大 Unicode 码点
  - `E_char_max_range`：支持的最大码点范围
  - `npos`：无效位置常量

---

## 主要功能

### 1. UTF-8 字符与数值互转

- `char_to_number`  
  将 UTF-8 字符（字节序列、指针、字符串、迭代器等）转换为 Unicode 码点（s32）。
- `number_to_char`  
  将 Unicode 码点转换为 UTF-8 字符（字节序列），支持不同缓冲区和类型。

### 2. UTF-8 字符长度与字符串长度

- `charlen`  
  计算单个 UTF-8 字符的字节长度，支持 char、指针、字符串、迭代器等多种类型。
- `strlen`  
  计算 UTF-8 字符串的字符数（utf8 长度），支持 C 字符串、标准字符串、字符串视图、迭代器区间等。
- `strnlen`  
  计算 UTF-8 字符串在指定字节数内的字符数。
- `strlen_both` / `strnlen_both`  
  同时返回 UTF-8 字符数和字节数。

### 3. UTF-8 字符串有效性判断

- `is_utf8_string`  
  判断给定字符串是否为有效 UTF-8 字符串，支持多种类型。

### 4. 字符集名称获取

- `get_charset_name` / `get_str_charset_name`  
  根据字符串内容自动判断并返回对应的字符集名称（如 "utf-8" 或默认编码）。

### 5. 字符串比较与查找

- `charcmp` / `charcmp_eq`  
  比较两个 UTF-8 字符是否相等或大小关系。
- `strcmp` / `strcmp_eq`  
  比较两个 UTF-8 字符串是否相等或大小关系，支持多种类型和长度参数。
- `find`  
  查找单个 UTF-8 字符在字符串中的位置。
- `search`  
  查找子串在字符串中的位置，支持多种类型和长度参数。
- `search_n`  
  查找连续 n 个相同 UTF-8 字符的起始位置。

### 6. 字节长度与迭代器支持

- `utf8_length_to_byte_size`  
  将 UTF-8 字符数转换为字节数。
- `byte_distance`  
  计算任意迭代器区间的字节距离，适配普通和 UTF-8 字符串迭代器。

### 7. 其他辅助

- `negative_number`  
  计算负向码点（用于某些算法）。
- `format_number_step`  
  格式化步进值，保证在合法码点范围内。

---

## 设计说明

- **类型泛化**：所有接口均为模板，支持 char、wchar_t、字符串、字符串视图、迭代器等多种类型。
- **高效实现**：底层直接操作字节序列，零拷贝，效率极高。
- **类型安全**：大量使用 SFINAE、traits、静态断言，防止类型误用。
- **异常安全**：带断言和参数检查，防止越界和非法输入。
- **与 yggdrasil 框架深度集成**：依赖于框架的字符串类型、traits、编码工具、容器特性等。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_foo.hpp>
#include <string>

using yggr::charset::utf8_foo;

// 字符转码点
const char* c = u8"你";
int code = utf8_foo::char_to_number(c);

// 码点转字符
char buf[8] = {};
size_t used = 0;
utf8_foo::number_to_char(buf, code, sizeof(buf), used);

// 计算字符串长度
std::string s = u8"你好世界";
size_t len = utf8_foo::strlen(s);

// 比较字符串
bool eq = utf8_foo::strcmp_eq(s.c_str(), u8"你好世界");

// 查找字符
size_t pos = utf8_foo::find(s, u8"世");
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型、分配器或与其他字符串类型的互操作，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_string_impl_decl.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 字符串实现类 `utf8_string_impl` 的**前置声明**。它定义了一个高度泛型的 UTF-8 字符串类型模板，为后续 UTF-8 字符串相关功能（如 utf8 字符串、字符处理、视图、迭代器等）提供类型基础，便于在头文件依赖较多或需要提前声明类型的场景下使用。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：`utf8_string_impl<TChar, TTraits, TAlloc>`

---

## 主要功能

### 1. utf8_string_impl 前置声明

```cpp
template<
    typename TChar = char,
    typename TTraits = typename basic_string<TChar>::traits_type,
    typename TAlloc = typename mplex::typename_expand_get<basic_string<TChar>, 2>::type
>
class utf8_string_impl;
```

- **功能**：声明了一个泛型 UTF-8 字符串类型，支持自定义字符类型、traits 和分配器。
- **默认参数**：
  - `TChar`：字符类型，默认为 `char`
  - `TTraits`：traits 类型，默认为 `basic_string<TChar>::traits_type`
  - `TAlloc`：分配器类型，默认为 `basic_string<TChar>` 的第三个模板参数（通常为 allocator）
- **适用场景**：用于需要提前声明 UTF-8 字符串类型的头文件，避免头文件循环依赖或减少编译开销。

---

## 设计说明

- **类型兼容**：与 `yggr::charset::basic_string` 保持 traits 和 allocator 一致，便于与字符串类型协作。
- **泛型友好**：支持任意字符类型、traits 和分配器，适合多字符集、多编码环境。
- **轻量声明**：仅做类型声明，无需包含完整实现，减少编译依赖。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_string_impl_decl.hpp>

yggr::charset::utf8_string_impl<> ustr; // 默认 char 版本
yggr::charset::utf8_string_impl<wchar_t> wustr; // wchar_t 版本
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需完整功能和实现，请包含对应的实现头文件。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 当然！以下是针对 utf8_string_impl.hpp 文件的通用文档模板。由于你没有提供文件内容，我将基于常见的 UTF-8 字符串处理实现进行文档编写。你可以根据实际接口和实现细节进行补充和修改。

---

# utf8_string_impl.hpp 文档

## 简介

`utf8_string_impl.hpp` 提供了对 UTF-8 编码字符串的高效处理实现。该文件通常包含 UTF-8 字符串的解析、遍历、长度计算、子串提取、字符插入与删除等常用操作。其设计目标是为 C++ 项目提供安全、易用且高性能的 UTF-8 字符串支持。

## 主要功能

- **UTF-8 编码与解码**  
  提供将 Unicode 码点编码为 UTF-8 字节序列，以及从 UTF-8 字节序列解码为 Unicode 码点的功能。

- **字符串遍历**  
  支持以字符（而非字节）为单位遍历 UTF-8 字符串，正确处理多字节字符。

- **长度计算**  
  能够准确计算 UTF-8 字符串的字符数（而非字节数）。

- **子串操作**  
  支持基于字符索引的子串提取、插入、删除等操作。

- **查找与替换**  
  提供基于字符的查找、替换等常用字符串操作。

## 主要类与函数

> **注意：以下为常见接口示例，具体以实际代码为准。**

### 类：utf8_string

#### 构造与赋值

```cpp
utf8_string();
utf8_string(const char* str);
utf8_string(const std::string& str);
utf8_string(const utf8_string& other);
```

#### 基本操作

- `size_t length() const;`  
  返回字符串的字符数。

- `size_t bytes() const;`  
  返回字符串的字节数。

- `bool empty() const;`  
  判断字符串是否为空。

#### 字符访问

- `char32_t at(size_t index) const;`  
  返回指定字符索引处的 Unicode 码点。

- `void insert(size_t index, char32_t ch);`  
  在指定字符位置插入一个字符。

- `void erase(size_t index);`  
  删除指定字符位置的字符。

#### 子串与查找

- `utf8_string substr(size_t pos, size_t count) const;`  
  提取子串。

- `size_t find(char32_t ch, size_t pos = 0) const;`  
  查找字符。

#### 迭代器支持

- `iterator begin();`
- `iterator end();`
- 支持基于范围的 for 循环遍历每个字符。

## 使用示例

```cpp
#include "utf8_string_impl.hpp"

utf8_string s("你好，世界!");
std::cout << "字符数: " << s.length() << std::endl;
for (auto ch : s) {
    std::cout << std::hex << ch << " ";
}
```

## 注意事项

- 本实现假定输入字符串为有效的 UTF-8 编码。对于非法编码，行为未定义或可能抛出异常。
- 某些操作的时间复杂度可能高于 std::string，因为需要处理变长编码。

## 依赖

- C++11 或更高标准
- 仅依赖标准库

## 版权与许可

请根据实际项目补充版权声明和开源许可信息。

---

如需更详细的接口文档，请提供文件内容或接口声明。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 当然！以下是针对 utf8_string_impl.hpp 文件的通用文档模板。由于你没有提供文件内容，我将基于常见的 UTF-8 字符串实现头文件的结构，给出文档示例。你可以根据实际内容进行补充和修改。

---

# utf8_string_impl.hpp 文档

## 简介

`utf8_string_impl.hpp` 是一个用于处理 UTF-8 编码字符串的 C++ 头文件。它提供了对 UTF-8 字符串的解析、操作、遍历等功能，解决了标准字符串类（如 `std::string`）在多字节字符处理上的不足。该文件通常作为 UTF-8 字符串类（如 `utf8_string`）的实现细节部分，封装了底层的编码、解码和字符操作逻辑。

## 主要功能

- **UTF-8 编码与解码**  
  提供将 Unicode 码点编码为 UTF-8 字节序列，以及从 UTF-8 字节序列解码为 Unicode 码点的函数。

- **字符串遍历**  
  支持以字符（而非字节）为单位遍历 UTF-8 字符串，正确处理多字节字符。

- **字符串操作**  
  实现了插入、删除、查找、替换等常用字符串操作，保证操作不会破坏 UTF-8 字符边界。

- **长度与索引**  
  提供获取字符串字符数（而非字节数）、按字符索引访问等功能。

- **异常安全**  
  对非法 UTF-8 序列进行检测和处理，避免崩溃或未定义行为。

## 主要类型与接口

> **注意：以下接口为常见实现，具体以实际代码为准。**

### 类模板

```cpp
template<typename StorageType>
class utf8_string_impl;
```

- `StorageType`：底层存储类型，通常为 `std::string` 或 `std::vector<char>`。

### 主要成员函数

- `size_t length() const;`  
  返回字符串的字符数（非字节数）。

- `void insert(size_t pos, const std::string& str);`  
  在指定字符位置插入字符串。

- `void erase(size_t pos, size_t count = 1);`  
  删除从指定字符位置开始的若干字符。

- `std::string substr(size_t pos, size_t count) const;`  
  获取子串。

- `iterator begin();`  
  返回字符级迭代器起始位置。

- `iterator end();`  
  返回字符级迭代器结束位置。

- `static bool is_valid(const std::string& str);`  
  检查字符串是否为合法 UTF-8 编码。

### 辅助函数

- `static uint32_t decode(const char* bytes, size_t& length);`  
  解码一个 UTF-8 字符，返回 Unicode 码点。

- `static std::string encode(uint32_t codepoint);`  
  将 Unicode 码点编码为 UTF-8 字节序列。

## 使用示例

```cpp
#include "utf8_string_impl.hpp"

utf8_string_impl<std::string> str("你好，世界!");
std::cout << "字符数: " << str.length() << std::endl;

for (auto it = str.begin(); it != str.end(); ++it) {
    std::cout << *it << std::endl;
}
```

## 注意事项

- 操作 UTF-8 字符串时，务必使用本类提供的接口，避免直接用字节索引操作底层存储。
- 对于非法 UTF-8 字节序列，相关函数可能抛出异常或返回错误码，请做好异常处理。

## 依赖

- C++11 或更高版本
- `<string>`、`<vector>`、`<stdexcept>` 等标准库头文件

## 版权与许可

（请根据实际项目填写）

---

**如需更详细的接口说明，请提供文件内容或接口声明。**

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_string_iterator_decl.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 字符串迭代器相关类型的**前置声明**。它声明了 UTF-8 字符串的通用迭代器、可修改迭代器和常量迭代器模板，为后续 UTF-8 字符串的遍历、修改等功能提供类型基础，便于在头文件依赖较多或需要提前声明类型的场景下使用。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：
  - `utf8_string_iterator<Char, Basic_Iterator>`
  - `utf8_string_modify_iterator<Char, Basic_Iterator>`
  - `utf8_string_const_iterator<Char, Basic_Iterator>`

---

## 主要功能

### 1. 前置声明

```cpp
template<typename Char, typename Basic_Iterator>
class utf8_string_iterator;

template<typename Char, typename Basic_Iterator>
class utf8_string_modify_iterator;

template<typename Char, typename Basic_Iterator>
class utf8_string_const_iterator;
```

- **功能**：声明了三种 UTF-8 字符串迭代器类型，分别用于普通遍历、可修改遍历和只读遍历。
- **模板参数**：
  - `Char`：底层字符类型（如 `char`）
  - `Basic_Iterator`：底层基础迭代器类型（如 `std::string::iterator`）

### 2. 适用场景

- 用于需要提前声明 UTF-8 字符串迭代器类型的头文件，避免头文件循环依赖或减少编译依赖。
- 便于在泛型编程、字符串遍历、容器操作等场景下统一接口。

---

## 设计说明

- **类型兼容**：与 UTF-8 字符串类型保持一致，便于与字符串、字符视图等类型协作。
- **泛型友好**：支持任意字符类型和基础迭代器类型，适合多字符集、多编码环境。
- **轻量声明**：仅做类型声明，无需包含完整实现，减少编译依赖。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_string_iterator_decl.hpp>

yggr::charset::utf8_string_iterator<char, std::string::iterator> it;
yggr::charset::utf8_string_const_iterator<char, std::string::const_iterator> cit;
yggr::charset::utf8_string_modify_iterator<char, std::string::iterator> mit;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需完整功能和实现，请包含对应的实现头文件。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_string_iterator.hpp 文档

该头文件为 yggdrasil 框架字符集模块实现了 UTF-8 字符串的三种高性能迭代器：普通迭代器（utf8_string_iterator）、可修改迭代器（utf8_string_modify_iterator）、常量迭代器（utf8_string_const_iterator）。这些迭代器支持以字符为单位（而非字节）安全遍历、定位、比较和操作 UTF-8 字符串，适用于多字节字符集环境下的泛型字符串处理。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类型**：
  - `utf8_string_iterator<Char, Basic_Iterator>`
  - `utf8_string_modify_iterator<Char, Basic_Iterator>`
  - `utf8_string_const_iterator<Char, Basic_Iterator>`
- **辅助工具**：
  - 字节长度支持（byte_size）
  - 迭代器类型 traits
  - swap 支持
  - 比较操作符重载

---

## 主要功能

### 1. UTF-8 字符串迭代器

#### 1.1 utf8_string_iterator

- 继承自底层基础迭代器，支持随机访问。
- 以 UTF-8 字符为单位遍历字符串，自动跳过多字节字符的中间字节。
- 支持 `*`、`[]`、`+`、`-`、`++`、`--`、`+=`、`-=` 等操作，保证字符边界安全。
- 支持与其他迭代器的比较和距离计算。
- 支持 swap。

#### 1.2 utf8_string_modify_iterator

- 以字符索引定位 UTF-8 字符串，适合修改操作。
- 支持通过字符串和字符位置构造，或通过底层迭代器定位。
- 支持 `*`、`[]`、`+`、`-`、`++`、`--`、`+=`、`-=` 等操作。
- 支持与其他迭代器的比较和距离计算。
- 支持 swap 和 set 操作。

#### 1.3 utf8_string_const_iterator

- 只读 UTF-8 字符串迭代器，支持常量上下文。
- 支持与普通迭代器、可修改迭代器的互转和比较。
- 支持所有常用迭代器操作和 swap。

### 2. 字节长度支持

- 提供 `byte_size_iterator_helper`，可计算任意 UTF-8 迭代器区间的字节长度，兼容正向和反向迭代器。

### 3. 比较操作符重载

- 支持不同类型 UTF-8 迭代器之间的 `== != < <= > >=` 比较，保证泛型算法兼容性。

### 4. swap 支持

- 提供 `swap_support` 命名空间下的 swap 重载，兼容 std/boost/yggr 的 swap 调用。

### 5. 类型 traits

- 提供 `is_utf8_string_iterator_t`、`is_utf8_string_modify_iterator_t`、`is_utf8_string_const_iterator_t`，便于泛型编程时类型分派。

---

## 设计说明

- **字符级安全**：所有操作均以 UTF-8 字符为单位，避免破坏多字节字符边界。
- **泛型友好**：支持任意底层迭代器和字符类型，适合模板编程和多容器环境。
- **高效实现**：底层直接操作指针或迭代器，零拷贝，效率高。
- **类型安全**：大量使用 SFINAE、traits、静态断言，防止类型误用。
- **与 yggdrasil 框架深度集成**：依赖于框架的字符串类型、traits、编码工具、容器特性等。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_string_impl.hpp>
#include <yggr/charset/utf8_string_iterator.hpp>

using namespace yggr::charset;

utf8_string_impl<> ustr = u8"你好世界";
auto begin = utf8_string_iterator<utf8_char, std::string::iterator>(ustr.org_str().begin());
auto end = utf8_string_iterator<utf8_char, std::string::iterator>(ustr.org_str().end());

for (auto it = begin; it != end; ++it) {
    auto ch_view = *it; // 得到 basic_utf8_char_view
    // ...处理每个字符
}

// 可修改迭代器
utf8_string_modify_iterator<utf8_char, std::string::iterator> mit(ustr, 1);
*mit = 'A'; // 修改第2个字符
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型、分配器或与其他字符串类型的互操作，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_string_view_decl.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 字符串视图类型 `basic_utf8_string_view` 的**前置声明**。它用于在头文件依赖较多或需要提前声明类型的场景下，避免循环依赖和减少编译开销，为后续 UTF-8 字符串视图相关功能（如只读视图、零拷贝子串等）提供类型基础。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心模板**：`basic_utf8_string_view<CharT, Traits>`

---

## 主要功能

### 1. 前置声明

```cpp
template<typename CharT, typename Traits = typename basic_string<CharT>::traits_type>
class basic_utf8_string_view;
```

- **功能**：声明了一个泛型 UTF-8 字符串视图类型，支持自定义字符类型和 traits。
- **默认参数**：
  - `CharT`：字符类型（如 `char`、`wchar_t` 等）
  - `Traits`：traits 类型，默认为 `basic_string<CharT>::traits_type`
- **适用场景**：用于需要提前声明 UTF-8 字符串视图类型的头文件，避免头文件循环依赖或减少编译依赖。

---

## 设计说明

- **类型兼容**：与 `yggr::charset::basic_string` 保持 traits 一致，便于与字符串类型协作。
- **泛型友好**：支持任意字符类型和 traits，适合多字符集、多编码环境。
- **轻量声明**：仅做类型声明，无需包含完整实现，减少编译依赖。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_string_view_decl.hpp>

yggr::charset::basic_utf8_string_view<char> sv;
yggr::charset::basic_utf8_string_view<wchar_t> wsv;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需完整功能和实现，请包含对应的实现头文件。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_string_view_impl.hpp 文档

该头文件实现了 yggdrasil 框架中 UTF-8 字符串只读视图类型 `basic_utf8_string_view`，为 UTF-8 字符串提供高性能、零拷贝、类型安全的只读访问、查找、比较、子串、迭代等功能。它兼容 STL/Boost 字符串、字符串视图、UTF-8 字符类型，适用于多字符集、多容器环境下的泛型字符串处理和高效算法。

---

## 主要内容

- **命名空间**：`yggr::charset`
- **核心类型**：`basic_utf8_string_view<CharT, TraitsT>`
- **相关类型**：UTF-8 字符类型、迭代器、视图、引用、string_charset_helper
- **特性支持**：查找、比较、子串、starts_with/ends_with/contains、迭代、hash、swap、流输出、Boost.Range

---

## 主要功能

### 1. 只读 UTF-8 字符串视图

- **本质**：以指针和长度保存 UTF-8 字符串的只读视图，不拥有底层数据，零拷贝。
- **泛型支持**：支持任意 1 字节字符类型和 traits，兼容 STL/Boost 字符串及自定义类型。

### 2. 构造与赋值

- 支持从 C 字符串、指针+长度、任意迭代器区间、utf8_string_impl、其他 string_view、utf8_string_iterator、string_charset_helper 等多种类型构造。
- 支持拷贝、移动、赋值等操作。

### 3. 迭代器与元素访问

- 提供 begin/end/cbegin/cend/rbegin/rend 等迭代器，支持正向/反向遍历。
- 支持下标访问、at、front、back、data。
- 迭代器为 UTF-8 字符级别，保证字符边界安全。

### 4. 容量与属性

- size()：字节长度
- length()：UTF-8 字符数
- empty()：是否为空
- is_validate()：是否为合法 UTF-8 字符串

### 5. 子串与拷贝

- substr()：获取子视图，支持多种目标类型和分配器
- copy()：拷贝内容到外部缓冲区，支持编码转换

### 6. 查找与比较

- compare/compare_eq：支持与各种字符串类型、视图、C 字符串、UTF-8 字符类型的比较，支持子串比较和编码转换
- starts_with/ends_with/contains：前缀、后缀、包含判断，支持多种类型和编码
- find/rfind/find_first_of/find_last_of/find_first_not_of/find_last_not_of：多种查找接口，支持多类型和编码

### 7. 类型转换与原始访问

- str()/org_str()/org_view()：获取原始视图或转换为目标字符串类型，支持编码转换
- affix_length/recount_length：手动设置或重新计算 UTF-8 长度

### 8. 非成员操作符重载

- 支持与 string_charset_helper、C 字符串、STL/Boost 字符串、string_view、其他 utf8_string_view 的 == != < <= > >= 比较
- 支持流输出（operator<<），自动编码转换

### 9. swap、hash、Boost.Range

- swap：高效交换两个视图
- hash/hash_value/std::hash：支持哈希容器
- Boost.Range：支持 range_size

### 10. 泛型 traits 与辅助

- is_utf8_string_view_t、utf8_string_view_loadable、is_validate_string 等 traits，便于泛型算法分派
- string_charset_helper_data：与 string_charset_helper 协作

---

## 设计说明

- **零拷贝**：所有视图操作均不拷贝底层数据，效率极高
- **类型安全**：大量使用 SFINAE、traits、静态断言，防止类型误用
- **泛型友好**：支持任意字符串类型、字符类型、视图、引用、string_charset_helper
- **编码适配**：自动处理不同字符集编码的转换，保证内容正确
- **与 yggdrasil 框架深度集成**：依赖于框架的字符串类型、traits、编码工具、容器特性等

---

## 用法示例

```cpp
#include <yggr/charset/utf8_string_view_impl.hpp>
#include <string>

using yggr::charset::basic_utf8_string_view;

std::string s = u8"你好世界";
basic_utf8_string_view<char> sv(s.data(), s.size());

if (sv.starts_with(u8"你好")) {
    // ...
}

auto sub = sv.substr(2, 2); // 获取子串视图

std::cout << sv << std::endl; // 支持流输出

if (sv.find(u8"世") != basic_utf8_string_view<char>::npos) {
    // ...
}
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义字符串类型、分配器或与其他字符串类型的互操作，请参考模板参数与实现细节。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_string_view.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 字符串只读视图类型 `utf8_string_view` 的类型别名声明。它将泛型 UTF-8 字符串视图类型（`basic_utf8_string_view<char>`）与默认实现绑定，便于在项目中直接使用高效、类型安全的 UTF-8 字符串只读视图，适合高性能、多字符集环境下的字符串处理和算法。

---

## 主要内容

- **命名空间**：`yggr::charset`、yggr
- **核心类型别名**：
  - `utf8_string_view`（等价于 `basic_utf8_string_view<char>`）
- **依赖**：
  - `utf8_string_impl.hpp`
  - `utf8_string_view_impl.hpp`
  - `utf8_string_iterator.hpp`
  - `utf8_char_impl.hpp`
  - `utf8_char_view_impl.hpp`
  - `utf8_char_reference_impl.hpp`

---

## 主要功能

### 1. 类型别名声明

```cpp
typedef basic_utf8_string_view<char> utf8_string_view;
```

- **功能**：将泛型 UTF-8 字符串视图类型与默认 char 实现绑定，便于直接使用。
- **适用场景**：需要对 UTF-8 字符串进行高效只读视图、查找、比较、子串、迭代等操作。

### 2. 全局 using 导出

- 在 yggr 命名空间下导出 `utf8_string_view`，便于全局统一访问。

---

## 设计说明

- **类型安全**：通过泛型实现，保证与 UTF-8 字符串类型兼容。
- **高效实现**：只读视图，零拷贝，适合高性能字符串处理。
- **易用性**：直接提供常用类型别名，简化泛型模板的使用。
- **与 yggdrasil 框架深度集成**：依赖于框架的 UTF-8 字符串、字符类型、traits 等。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_string_view.hpp>
#include <string>

yggr::charset::utf8_string_view sv(u8"你好世界");
if (sv.starts_with(u8"你好")) {
    // ...
}

std::cout << sv << std::endl;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义 UTF-8 字符串类型，请使用 `basic_utf8_string_view` 模板并指定对应的字符类型。详细用法和扩展方式请查阅源码与注释。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # utf8_string.hpp 文档

该头文件为 yggdrasil 框架字符集模块提供了 UTF-8 字符串类型 `utf8_string` 的类型定义。它将泛型 UTF-8 字符串实现（`utf8_string_impl<>`）通过类型别名统一为 `utf8_string`，便于在项目中直接使用高效、类型安全的 UTF-8 字符串类型，适合多字符集、高性能字符串处理场景。

---

## 主要内容

- **命名空间**：`yggr::charset`、yggr
- **核心类型别名**：
  - `utf8_string`（等价于 `utf8_string_impl<>`）
- **依赖**：
  - `utf8_char.hpp`
  - `utf8_string_impl.hpp`
  - `utf8_string_view_impl.hpp`

---

## 主要功能

### 1. 类型别名声明

```cpp
typedef utf8_string_impl<> utf8_string;
```

- **功能**：将默认模板参数的 `utf8_string_impl` 作为 UTF-8 字符串类型，便于直接使用。
- **适用场景**：需要高效、类型安全地处理 UTF-8 字符串的场合。

### 2. 全局 using 导出

- 在 yggr 命名空间下导出 `utf8_string`，便于全局统一访问。

---

## 设计说明

- **类型安全**：通过泛型实现，保证与 UTF-8 字符类型、视图类型兼容。
- **高效实现**：底层实现支持高性能的 UTF-8 字符串操作。
- **易用性**：直接提供常用类型别名，简化泛型模板的使用。
- **与 yggdrasil 框架深度集成**：依赖于框架的 UTF-8 字符串、字符类型、traits 等。

---

## 用法示例

```cpp
#include <yggr/charset/utf8_string.hpp>

yggr::charset::utf8_string s = u8"你好世界";
std::cout << s << std::endl;
```

---

## 版权声明

MIT License，详见文件头部注释。

---

如需扩展支持自定义 UTF-8 字符串类型，请使用 `utf8_string_impl` 模板并指定对应的字符类型或 traits。详细用法和扩展方式请查阅源码与注释。