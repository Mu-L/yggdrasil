alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `allocator_t.hpp` 的文档说明：

---

# 文件：allocator_t.hpp

## 简介

`allocator_t.hpp` 是 yggdrasil 项目中用于类型萃取（type traits）的一个头文件，主要用于从类型 T 中提取其分配器类型（allocator_type），以便在泛型编程中自动适配带有或不带有分配器的类型。

## 主要内容

- **命名空间**：所有内容均位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/base/yggrdef.h>`：基础定义。
  - `<yggr/mplex/null_t.hpp>`：空类型定义。
  - `<yggr/container_ex/has_allocator_t.hpp>`：判断类型是否有 allocator_type。
  - `<memory>`：标准库内存分配相关。
- **核心结构体**：
  - `allocator_t_detail<T, has_allocator>`：模板特化结构体，根据类型 T 是否有 `allocator_type` 进行不同处理。
    - `has_allocator = true` 时，`type` 为 `T::allocator_type`。
    - `has_allocator = false` 时，继承自 `mplex::null_type`，表示无分配器。
  - `allocator_t<T>`：对外统一接口，继承自 `allocator_t_detail<T, has_allocator_t<T>::value>`，自动判断并提取分配器类型。
- **别名**：
  - `using container_ex::allocator_t;` 便于外部直接使用 `allocator_t`。

## 用法示例

```cpp
#include <yggr/container_ex/allocator_t.hpp>

struct MyTypeWithAllocator {
    using allocator_type = std::allocator<int>;
};

struct MyTypeWithoutAllocator {};

// 提取分配器类型
using Alloc1 = yggr::allocator_t<MyTypeWithAllocator>::type; // std::allocator<int>
using Alloc2 = yggr::allocator_t<MyTypeWithoutAllocator>::type; // mplex::null_type
```

## 适用场景

- 泛型容器或算法中，需要自动适配带有或不带有分配器的类型。
- 需要类型萃取和 SFINAE 技术的高级 C++ 模板编程。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中文/英文双语文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `allocator_traits.hpp` 的文档说明：

---

# 文件：allocator_traits.hpp

## 简介

`allocator_traits.hpp` 是 yggdrasil 项目中用于分配器特性适配的头文件，主要作用是将 Boost 的 `allocator_traits` 引入到 `yggr::container_ex` 命名空间下，便于统一管理和使用分配器相关的 trait 功能。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/base/yggrdef.h>`：基础定义。
  - `<boost/container/allocator_traits.hpp>`：Boost 分配器特性实现。
- **核心定义**：
  - `using boost::container::allocator_traits;`  
    直接将 Boost 的 `allocator_traits` 类型引入 `yggr::container_ex` 命名空间，方便后续代码统一使用。

## 用法示例

```cpp
#include <yggr/container_ex/allocator_traits.hpp>
#include <vector>

typedef std::allocator<int> my_allocator;
typedef yggr::container_ex::allocator_traits<my_allocator> my_traits;

// 现在可以通过 my_traits 访问 allocator_traits 的所有静态方法和类型定义
```

## 适用场景

- 需要对自定义或标准分配器进行 trait 操作时，统一使用 `yggr::container_ex::allocator_traits`。
- 便于后续切换或扩展分配器特性实现（如从 Boost 切换到标准库实现）。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `array_t_maker.hpp` 的文档说明：

---

# 文件：array_t_maker.hpp

## 简介

`array_t_maker.hpp` 是 yggdrasil 项目中用于数组类型萃取和类型生成的工具头文件。它通过一组模板结构体，方便地为任意类型 T 和长度 N 生成数组、数组引用、数组指针等类型，简化泛型编程中对数组类型的处理。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/base/yggrdef.h>`：基础定义。
  - `<boost/type_traits/remove_reference.hpp>`：类型萃取辅助（虽然本文件未直接用到）。
- **核心结构体**：
  - `array_reference_t_maker<T, N>`：生成类型 `T(&)[N]`，即长度为 N 的 T 类型数组的引用类型。
  - `array_const_reference_t_maker<T, N>`：生成类型 `const T(&)[N]`，即长度为 N 的 const T 类型数组的引用类型。
  - `array_pointer_t_maker<T, N>`：生成类型 `T(*)[N]`，即长度为 N 的 T 类型数组的指针类型。
  - `array_const_pointer_t_maker<T, N>`：生成类型 `const T(*)[N]`，即长度为 N 的 const T 类型数组的指针类型。
  - `array_t_maker<T, N>`：生成类型 `T[N]`，即长度为 N 的 T 类型数组。
- **别名**：
  - 通过 `using` 语句将上述结构体提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/array_t_maker.hpp>

typedef yggr::array_reference_t_maker<int, 5>::type      int_array_ref;   // int (&)[5]
typedef yggr::array_const_reference_t_maker<int, 5>::type const_int_array_ref; // const int (&)[5]
typedef yggr::array_pointer_t_maker<int, 5>::type        int_array_ptr;   // int (*)[5]
typedef yggr::array_const_pointer_t_maker<int, 5>::type  const_int_array_ptr; // const int (*)[5]
typedef yggr::array_t_maker<int, 5>::type                int_array;       // int[5]
```

## 适用场景

- 泛型编程中需要根据类型和长度自动生成数组相关类型。
- 需要对数组进行引用、指针等操作时，统一类型定义，提升代码可读性和可维护性。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `array.hpp` 的文档说明：

---

# 文件：array.hpp

## 简介

`array.hpp` 是 yggdrasil 项目中用于增强原生数组和自定义数组类型操作的头文件。它为 C++ 原生数组、`std::array`、`boost::array` 及自定义数组类型提供了统一的引用包装、比较、转换、填充、元素访问等高级功能，极大提升了数组在泛型编程中的灵活性和可用性。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：依赖于 Boost、yggr 基础设施、类型萃取、元编程等多种库。
- **核心功能**：
  1. **native_array_ref / native_array_cref**  
     - 为原生数组类型 `T[N]` 提供引用包装类，支持隐式转换、指针转换、比较（==, !=, <, <=, >, >=）等操作。
     - 支持与原生数组、其他包装类之间的比较。
  2. **make_array_ref / make_array_cref**  
     - 工厂函数，快速生成数组引用包装对象，支持原生数组、`std::array`、`boost::array`。
  3. **get**  
     - 泛型元素访问函数，支持通过索引值或类型安全索引类型访问原生数组、`std::array`、`boost::array`、自定义数组类型的元素。
     - 支持常量、非常量、右值引用等多种访问方式。
  4. **to_array**  
     - 将原生数组或其他数组类型转换为 `yggr::array` 或自定义数组类型，支持拷贝和移动语义。
  5. **fill**  
     - 填充原生数组或自定义数组类型的所有元素为指定值。
  6. **tuple_size / tuple_element**  
     - 为原生数组和自定义数组类型提供元组大小和元素类型的类型萃取，便于与元组相关的泛型编程。

## 用法示例

```cpp
#include <yggr/container_ex/array.hpp>

int arr[3] = {1, 2, 3};
auto ref = yggr::container_ex::make_array_ref(arr);
auto cref = yggr::container_ex::make_array_cref(arr);

// 比较
bool eq = (ref == arr);

// 元素访问
int v = yggr::container_ex::get<1>(arr);

// 填充
yggr::container_ex::fill(arr, 0);

// 转换为 yggr::array
auto yarr = yggr::container_ex::to_array(arr);
```

## 适用场景

- 需要对原生数组、`std::array`、`boost::array` 及自定义数组类型进行统一操作时。
- 泛型编程中需要数组的引用包装、比较、转换、填充等高级功能。
- 需要与元组相关的类型萃取和元素访问。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `container_category_check.hpp` 的文档说明：

---

# 文件：container_category_check.hpp

## 简介

`container_category_check.hpp` 是 yggdrasil 项目中用于容器类型迭代器类别检测的元编程工具头文件。它通过类型萃取和模板继承，自动判断任意类型 T 是否为容器，并进一步判断其迭代器类别（如随机访问、双向、前向），为泛型算法和容器适配提供类型支持。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/container_ex/is_container.hpp>`：判断类型是否为容器。
  - `<yggr/iterator_ex/iterator_category_check.hpp>`：迭代器类别检测基础。
  - Boost MPL、类型萃取相关。
- **核心结构体与功能**：
  1. **container_category_ex_detail<T, is_container>**
     - 若 T 不是容器，继承自 `mplex::null_type`。
     - 若 T 是容器，继承自 `boost::iterator_category`，自动获取其迭代器类别。
  2. **container_category_ex<T>**
     - 对外统一接口，继承自 `container_category_ex_detail<T>`，自动判断并提取容器的迭代器类别。
  3. **containter_category_check_result**
     - 继承自 `iterator_category_check_result`，用于类型检测结果的统一封装。
  4. **is_random_access_container<T>**
     - 判断 T 是否为随机访问容器（如 `std::vector`），结果为 `boost::mpl::bool_`。
  5. **is_bidirectional_container<T>**
     - 判断 T 是否为双向容器（如 `std::list`），结果为 `boost::mpl::bool_`。
  6. **is_forward_container<T>**
     - 判断 T 是否为前向容器，结果为 `boost::mpl::bool_`。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/container_category_check.hpp>
#include <vector>

static_assert(yggr::is_random_access_container<std::vector<int>>::value, "vector 应为随机访问容器");
static_assert(!yggr::is_bidirectional_container<std::vector<int>>::value, "vector 不是双向容器");
```

## 适用场景

- 泛型算法中需要根据容器类型自动适配不同的迭代器操作。
- 需要在编译期判断容器的迭代器类别，实现类型安全的容器适配和优化。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `container_compare_t.hpp` 的文档说明：

---

# 文件：container_compare_t.hpp

## 简介

`container_compare_t.hpp` 是 yggdrasil 项目中用于容器比较器类型萃取的元编程工具头文件。它通过类型萃取技术，自动从容器类型中提取 `key_compare` 和 `value_compare` 类型，便于泛型编程中对容器比较器的统一访问和适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/container_ex/has_compare_t.hpp>`：判断容器是否有 `key_compare` 或 `value_compare` 类型。
  - `<utility>`：标准库工具。
- **核心结构体与功能**：
  1. **container_key_compare_t_detail<T, has_key_compare>**
     - 若 T 有 `key_compare`，则 `type` 为 `T::key_compare`。
     - 否则，继承自 `mplex::null_type`。
  2. **container_value_compare_t_detail<T, has_value_compare>**
     - 若 T 有 `value_compare`，则 `type` 为 `T::value_compare`。
     - 否则，继承自 `mplex::null_type`。
  3. **container_key_compare_t<Container>**
     - 对外统一接口，继承自 `container_key_compare_t_detail<Container>`，自动提取容器的 `key_compare` 类型。
  4. **container_value_compare_t<Container>**
     - 对外统一接口，继承自 `container_value_compare_t_detail<Container>`，自动提取容器的 `value_compare` 类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/container_compare_t.hpp>
#include <set>

typedef yggr::container_key_compare_t<std::set<int>>::type key_cmp; // std::set<int>::key_compare
typedef yggr::container_value_compare_t<std::set<int>>::type value_cmp; // std::set<int>::value_compare
```

## 适用场景

- 泛型编程中需要自动获取容器的比较器类型（如 `std::set`、`std::map` 等）。
- 需要对不同容器的比较器进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `container_key_t.hpp` 的文档说明：

---

# 文件：container_key_t.hpp

## 简介

`container_key_t.hpp` 是 yggdrasil 项目中用于容器键类型（key_type）萃取的元编程工具头文件。它通过类型萃取技术，自动从容器类型中提取 `key_type`，并在没有 `key_type` 的情况下回退到映射值类型，便于泛型编程中对容器键类型的统一访问和适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/container_ex/has_key_t.hpp>`：判断容器是否有 `key_type`。
  - `<yggr/container_ex/container_mapped_value_t.hpp>`：获取映射容器的 key 类型。
- **核心结构体与功能**：
  1. **container_key_t_detail<Container, b_has_key_t>**
     - 若容器有 `key_type`，则 `type` 为 `Container::key_type`。
     - 否则，继承自 `container_mapped_key_t<Container>`，用于映射容器（如 `std::map`）。
  2. **container_key_t<Container>**
     - 对外统一接口，继承自 `container_key_t_detail<Container>`，自动提取容器的键类型。
     - 同时定义 `value_type`，为容器的元素类型（`boost::range_value<Container>::type`）。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/container_key_t.hpp>
#include <map>
#include <vector>

typedef yggr::container_key_t<std::map<int, double>>::type map_key; // int
typedef yggr::container_key_t<std::vector<int>>::type vec_key; // int（回退到映射值类型或其他逻辑）
```

## 适用场景

- 泛型编程中需要自动获取容器的键类型（如 `std::map`、`std::set` 等）。
- 需要对不同容器的键类型进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `container_mapped_value_t.hpp` 的文档说明：

---

# 文件：container_mapped_value_t.hpp

## 简介

`container_mapped_value_t.hpp` 是 yggdrasil 项目中用于容器映射值类型和键类型萃取的元编程工具头文件。它通过类型萃取技术，自动从容器类型中提取映射容器的 value（如 `std::map` 的 mapped_type）和 key（如 `std::map` 的 key_type），便于泛型编程中对容器键值类型的统一访问和适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/container_ex/has_mapped_t.hpp>`：判断容器是否有 mapped_type。
  - `<boost/range/value_type.hpp>`：获取容器的元素类型。
- **核心结构体与功能**：
  1. **detail::get_mapped_value_t<T> / get_mapped_key_t<T>**
     - 默认 `type` 为 T 本身。
     - 若 T 为 Pair（如 `std::pair<F, S>`），则 `get_mapped_value_t` 的 `type` 为 S，`get_mapped_key_t` 的 `type` 为 F。
  2. **container_mapped_value_t<Container>**
     - 若容器有 mapped_type，则 `type` 为元素类型的 mapped value，否则为元素类型本身。
     - 同时定义 `value_type`，为容器的元素类型。
  3. **container_mapped_key_t<Container>**
     - 若容器有 mapped_type，则 `type` 为元素类型的 key，否则为元素类型本身。
     - 同时定义 `value_type`，为容器的元素类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/container_mapped_value_t.hpp>
#include <map>
#include <vector>

typedef yggr::container_mapped_value_t<std::map<int, double>>::type map_mapped; // double
typedef yggr::container_mapped_key_t<std::map<int, double>>::type map_key;      // int
typedef yggr::container_mapped_value_t<std::vector<int>>::type vec_val;         // int
typedef yggr::container_mapped_key_t<std::vector<int>>::type vec_key;           // int
```

## 适用场景

- 泛型编程中需要自动获取容器的 value_type、mapped_type 或 key_type（如 `std::map`、`std::vector` 等）。
- 需要对不同容器的键值类型进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `container_param_traits.hpp` 的文档说明：

---

# 文件：container_param_traits.hpp

## 简介

`container_param_traits.hpp` 是 yggdrasil 项目中用于容器参数类型萃取的元编程工具头文件。它通过模板特化，为不同类型的容器参数（尤其是原生数组）提供统一的类型包装，便于泛型编程中安全、简洁地传递和处理容器参数。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/container_ex/array.hpp>`：提供 `native_array_cref` 等数组包装类型。
- **核心结构体与功能**：
  1. **container_param_traits<Container>**
     - 默认情况下，`type` 为原始类型本身。
  2. **container_param_traits<T[N]>**
     - 针对原生数组类型 `T[N]`，`type` 为 `native_array_cref<T[N]>`，即数组常量引用包装类型。
  3. **container_param_traits<native_array_cref<T[N]>>**
     - 针对已包装的数组常量引用，`type` 仍为 `native_array_cref<T[N]>`，保证类型一致性。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/container_param_traits.hpp>

typedef yggr::container_param_traits<std::vector<int>>::type vec_param; // std::vector<int>
typedef yggr::container_param_traits<int[5]>::type arr_param;           // native_array_cref<int[5]>
```

## 适用场景

- 泛型编程中需要统一处理容器参数类型，尤其是原生数组与自定义容器混用时。
- 需要保证数组参数以安全的引用方式传递，避免退化为指针。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `deque_options_t.hpp` 的文档说明：

---

# 文件：deque_options_t.hpp

## 简介

`deque_options_t.hpp` 是 yggdrasil 项目中用于从类型 T 中萃取 deque 容器选项的元编程工具头文件。它通过类型展开和模板特化，自动获取带有特定模板参数数量（如 3 个参数）的类型的 deque 选项类型，便于泛型编程中对 deque 容器参数的统一访问和适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/base/yggrdef.h>`：基础定义。
  - `<yggr/mplex/null_t.hpp>`、`<yggr/mplex/typename_expand.hpp>`：类型展开与空类型工具。
  - `<yggr/container/get_deque_options.hpp>`：获取 deque 选项的工具。
- **核心结构体与功能**：
  1. **detail::deque_options_t_detail<T, tpl_arg_size>**
     - 默认继承自 `mplex::null_type`，表示无法获取选项。
     - 当类型 T 的模板参数数量为 3 时，`type` 为 `container::get_deque_options<...>::type`，即通过类型展开获取第 3 个模板参数作为 deque 选项类型。
  2. **deque_options_t<T>**
     - 对外统一接口，继承自 `deque_options_t_detail<T>`，自动提取类型 T 的 deque 选项类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/deque_options_t.hpp>

// 假设 MyDeque<T, Alloc, Options> 是一个有3个模板参数的类型
typedef yggr::deque_options_t<MyDeque<int, MyAlloc, MyOptions>>::type options_type; // MyOptions
```

## 适用场景

- 泛型编程中需要自动获取自定义 deque 容器的选项类型（如第三个模板参数）。
- 需要对不同 deque 容器的选项参数进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `deque_regularisation.hpp` 的文档说明：

---

# 文件：deque_regularisation.hpp

## 简介

`deque_regularisation.hpp` 是 yggdrasil 项目中用于标准化（正规化）deque 容器类型的元编程工具头文件。它通过类型萃取和模板特化，自动生成“正规化”的 deque 类型，确保类型参数（元素类型、分配器、选项等）都为标准形式，便于泛型编程和容器适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/range_ex/range_value_ex.hpp>`：获取容器的元素类型。
  - `<yggr/container_ex/allocator_t.hpp>`：获取容器的分配器类型。
  - `<yggr/container_ex/deque_options_t.hpp>`：获取容器的选项类型。
- **核心结构体与功能**：
  1. **detail::deque_regularisation_detail<T>**
     - 默认继承自 `mplex::null_type`，表示无法正规化。
     - 针对 `Dq<T, A>` 形式的模板类型，正规化为 `Dq<元素类型, 分配器类型>`。
     - 针对 `Dq<T, A, O>` 形式的模板类型，正规化为 `Dq<元素类型, 分配器类型, 选项类型>`。
     - 其中元素类型、分配器类型、选项类型均通过相关萃取工具自动获取。
  2. **deque_regularisation<T>**
     - 对外统一接口，继承自 `deque_regularisation_detail<T>`，自动生成正规化的 deque 类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/deque_regularisation.hpp>

// 假设 MyDeque<T, Alloc> 或 MyDeque<T, Alloc, Options> 是自定义 deque 类型
typedef yggr::deque_regularisation<MyDeque<int, MyAlloc>>::type norm_type1; // MyDeque<元素类型, 分配器类型>
typedef yggr::deque_regularisation<MyDeque<int, MyAlloc, MyOptions>>::type norm_type2; // MyDeque<元素类型, 分配器类型, 选项类型>
```

## 适用场景

- 泛型编程中需要自动生成标准化的 deque 容器类型，确保类型参数一致性。
- 需要对不同参数形式的 deque 容器进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `get_element.hpp` 的文档说明：

---

# 文件：get_element.hpp

## 简介

`get_element.hpp` 是 yggdrasil 项目中用于数组（`std::array`、`boost::array`）首尾元素访问的工具头文件。它为常见的定长数组容器提供了统一的首元素和尾元素获取接口，便于泛型编程中安全、简洁地访问数组两端的数据。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/utility/get_element_default.hpp>`：默认元素获取工具。
  - `<yggr/container/array.hpp>`：自定义数组类型支持。
- **核心函数**：
  1. **get_first_element / get_last_element**
     - 针对 `std::array<T, N>`（C++11 及以上）和 `boost::array<T, N>`，分别提供获取首元素和尾元素的重载函数。
     - 支持非常量和常量数组的访问。
     - 返回类型为元素的引用或常量引用。
- **别名**：
  - 通过 `using` 语句将上述函数提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/get_element.hpp>
#include <array>
#include <boost/array.hpp>

std::array<int, 3> arr1 = {1, 2, 3};
int first1 = yggr::get_first_element(arr1); // 1
int last1 = yggr::get_last_element(arr1);   // 3

boost::array<int, 3> arr2 = {4, 5, 6};
int first2 = yggr::get_first_element(arr2); // 4
int last2 = yggr::get_last_element(arr2);   // 6
```

## 适用场景

- 泛型编程中需要统一访问数组首尾元素，兼容 `std::array` 和 `boost::array`。
- 需要安全、简洁地获取定长数组的第一个和最后一个元素。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `has_allocator_t.hpp` 的文档说明：

---

# 文件：has_allocator_t.hpp

## 简介

`has_allocator_t.hpp` 是 yggdrasil 项目中用于检测类型是否拥有 `allocator_type` 成员类型的元编程工具头文件。它通过 SFINAE 技术和类型萃取，实现在编译期判断任意类型 T 是否定义了 `allocator_type`，便于泛型编程中自动适配带有或不带有分配器的类型。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/type_traits/native_t.hpp>`：类型原生化工具。
  - Boost MPL：元编程布尔类型和条件判断。
- **核心结构体与功能**：
  1. **detail::_has_allocator_t<Container>**
     - 通过 SFINAE 检测 `Container::allocator_type` 是否存在。
     - 若存在，`chk_foo` 返回 `true_type`，否则返回 `false_type`。
     - `type` 为 `boost::mpl::bool_`，值为 true 表示存在 `allocator_type`，false 表示不存在。
  2. **has_allocator_t<Container>**
     - 对外统一接口，继承自 `_has_allocator_t<Container>::type`，可直接用于类型判断。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/has_allocator_t.hpp>
#include <vector>
#include <string>

static_assert(yggr::has_allocator_t<std::vector<int>>::value, "vector 有 allocator_type");
static_assert(!yggr::has_allocator_t<int>::value, "int 没有 allocator_type");
```

## 适用场景

- 泛型编程中需要自动判断类型是否带有分配器（如 STL 容器）。
- 需要根据类型特性自动适配不同的模板实现。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `has_compare_t.hpp` 的文档说明：

---

# 文件：has_compare_t.hpp

## 简介

`has_compare_t.hpp` 是 yggdrasil 项目中用于检测类型是否拥有 `key_compare` 或 `value_compare` 成员类型的元编程工具头文件。它通过 SFINAE 技术和类型萃取，实现在编译期判断任意类型 T 是否定义了 `key_compare` 或 `value_compare`，便于泛型编程中自动适配带有或不带有比较器的类型。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/type_traits/native_t.hpp>`：类型原生化工具。
  - Boost MPL：元编程布尔类型和条件判断。
- **核心结构体与功能**：
  1. **detail::_has_key_compare_t<Container>**
     - 通过 SFINAE 检测 `Container::key_compare` 是否存在。
     - 若存在，`chk_foo` 返回 `true_type`，否则返回 `false_type`。
     - `type` 为 `boost::mpl::bool_`，值为 true 表示存在 `key_compare`，false 表示不存在。
  2. **detail::_has_value_compare_t<Container>**
     - 通过 SFINAE 检测 `Container::value_compare` 是否存在。
     - 逻辑同上。
  3. **has_key_compare_t<Container> / has_value_compare_t<Container>**
     - 对外统一接口，分别继承自 `_has_key_compare_t<Container>::type` 和 `_has_value_compare_t<Container>::type`，可直接用于类型判断。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/has_compare_t.hpp>
#include <set>
#include <vector>

static_assert(yggr::has_key_compare_t<std::set<int>>::value, "set 有 key_compare");
static_assert(!yggr::has_key_compare_t<std::vector<int>>::value, "vector 没有 key_compare");
```

## 适用场景

- 泛型编程中需要自动判断类型是否带有比较器（如 STL 的 set/map）。
- 需要根据类型特性自动适配不同的模板实现。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `has_get_allocator_function.hpp` 的文档说明：

---

# 文件：has_get_allocator_function.hpp

## 简介

`has_get_allocator_function.hpp` 是 yggdrasil 项目中用于检测类型是否拥有 `get_allocator` 成员函数的元编程工具头文件。它通过 SFINAE 技术和类型萃取，实现在编译期判断任意类型 T 是否定义了 `get_allocator` 成员函数（返回类型为 `allocator_t<T>::type`），便于泛型编程中自动适配带有或不带有分配器接口的类型。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/container_ex/allocator_t.hpp>`：分配器类型萃取工具。
  - Boost MPL：元编程布尔类型和条件判断。
- **核心结构体与功能**：
  1. **detail::_has_get_allocator_function<Container>**
     - 通过 SFINAE 检测 `Container` 是否有 `allocator_t<T>::type get_allocator() const` 成员函数。
     - 若存在，`chk_foo` 返回 `true_type`，否则返回 `false_type`。
     - `type` 为 `boost::mpl::bool_`，值为 true 表示存在该成员函数，false 表示不存在。
  2. **has_get_allocator_function<Container>**
     - 对外统一接口，继承自 `_has_get_allocator_function<Container>::type`，可直接用于类型判断。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/has_get_allocator_function.hpp>
#include <vector>
#include <string>

static_assert(yggr::has_get_allocator_function<std::vector<int>>::value, "vector 有 get_allocator()");
static_assert(!yggr::has_get_allocator_function<int>::value, "int 没有 get_allocator()");
```

## 适用场景

- 泛型编程中需要自动判断类型是否带有分配器接口（如 STL 容器）。
- 需要根据类型特性自动适配不同的模板实现。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `has_iterator_t.hpp` 的文档说明：

---

# 文件：has_iterator_t.hpp

## 简介

`has_iterator_t.hpp` 是 yggdrasil 项目中用于检测类型是否拥有各种迭代器类型（如 iterator、const_iterator、reverse_iterator、const_reverse_iterator）的元编程工具头文件。它通过 SFINAE 技术和类型萃取，实现在编译期判断任意类型 T 是否定义了这些迭代器类型，便于泛型编程中自动适配带有或不带有迭代器的类型。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/type_traits/native_t.hpp>`：类型原生化工具。
  - Boost MPL：元编程布尔类型和逻辑运算。
- **核心结构体与功能**：
  1. **detail::_has_non_const_iterator_t / _has_const_iterator_t / _has_non_const_reverse_iterator_t / _has_const_reverse_iterator_t**
     - 通过 SFINAE 检测类型是否分别拥有 `iterator`、`const_iterator`、`reverse_iterator`、`const_reverse_iterator` 成员类型。
     - 若存在，`chk_foo` 返回 `true_type`，否则返回 `false_type`。
     - `type` 为 `boost::mpl::bool_`，值为 true 表示存在该成员类型，false 表示不存在。
  2. **has_non_const_iterator_t / has_const_iterator_t / has_non_const_reverse_iterator_t / has_const_reverse_iterator_t**
     - 对外统一接口，分别继承自对应的 detail 检测结构体的 `type`，可直接用于类型判断。
  3. **has_iterator_t**
     - 只要上述四种迭代器类型中有任意一种存在，则为 true。
     - 便于统一判断类型是否为“可迭代容器”。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/has_iterator_t.hpp>
#include <vector>
#include <set>
#include <string>

static_assert(yggr::has_iterator_t<std::vector<int>>::value, "vector 有迭代器");
static_assert(!yggr::has_iterator_t<int>::value, "int 没有迭代器");
```

## 适用场景

- 泛型编程中需要自动判断类型是否带有迭代器（如 STL 容器）。
- 需要根据类型特性自动适配不同的模板实现。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `has_key_t.hpp` 的文档说明：

---

# 文件：has_key_t.hpp

## 简介

`has_key_t.hpp` 是 yggdrasil 项目中用于检测类型是否拥有 `key_type` 成员类型的元编程工具头文件。该文件本身只是对 `yggr::type_traits::has_key_t` 的简单封装和引入，便于在 `yggr::container_ex` 命名空间下统一使用键类型检测功能。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/type_traits/has_key_t.hpp>`：实际实现了 `has_key_t` 检测逻辑。
- **核心功能**：
  - 通过 `using ::yggr::has_key_t;`，将 `has_key_t` 类型提升到 `yggr::container_ex` 命名空间，便于后续统一调用。
- **无额外实现**，仅为命名空间适配和接口转发。

## 用法示例

```cpp
#include <yggr/container_ex/has_key_t.hpp>
#include <map>
#include <vector>

static_assert(yggr::container_ex::has_key_t<std::map<int, double>>::value, "map 有 key_type");
static_assert(!yggr::container_ex::has_key_t<std::vector<int>>::value, "vector 没有 key_type");
```

## 适用场景

- 泛型编程中需要自动判断类型是否带有 `key_type`（如 STL 的 map/set）。
- 需要根据类型特性自动适配不同的模板实现。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `has_mapped_t.hpp` 的文档说明：

---

# 文件：has_mapped_t.hpp

## 简介

`has_mapped_t.hpp` 是 yggdrasil 项目中用于检测类型是否拥有 `mapped_type` 成员类型的元编程工具头文件。该文件本身只是对 `yggr::type_traits::has_mapped_t` 的简单封装和引入，便于在 `yggr::container_ex` 命名空间下统一使用映射类型检测功能。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/type_traits/has_mapped_t.hpp>`：实际实现了 `has_mapped_t` 检测逻辑。
- **核心功能**：
  - 通过 `using ::yggr::has_mapped_t;`，将 `has_mapped_t` 类型提升到 `yggr::container_ex` 命名空间，便于后续统一调用。
- **无额外实现**，仅为命名空间适配和接口转发。

## 用法示例

```cpp
#include <yggr/container_ex/has_mapped_t.hpp>
#include <map>
#include <vector>

static_assert(yggr::container_ex::has_mapped_t<std::map<int, double>>::value, "map 有 mapped_type");
static_assert(!yggr::container_ex::has_mapped_t<std::vector<int>>::value, "vector 没有 mapped_type");
```

## 适用场景

- 泛型编程中需要自动判断类型是否带有 `mapped_type`（如 STL 的 map/unordered_map）。
- 需要根据类型特性自动适配不同的模板实现。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `has_value_t.hpp` 的文档说明：

---

# 文件：has_value_t.hpp

## 简介

`has_value_t.hpp` 是 yggdrasil 项目中用于检测类型是否拥有 `value_type` 成员类型的元编程工具头文件。该文件本身只是对 `yggr::type_traits::has_value_t` 的简单封装和引入，便于在 `yggr::container_ex` 命名空间下统一使用值类型检测功能。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/type_traits/has_value_t.hpp>`：实际实现了 `has_value_t` 检测逻辑。
- **核心功能**：
  - 通过 `using ::yggr::has_value_t;`，将 `has_value_t` 类型提升到 `yggr::container_ex` 命名空间，便于后续统一调用。
- **无额外实现**，仅为命名空间适配和接口转发。

## 用法示例

```cpp
#include <yggr/container_ex/has_value_t.hpp>
#include <vector>
#include <map>

static_assert(yggr::container_ex::has_value_t<std::vector<int>>::value, "vector 有 value_type");
static_assert(yggr::container_ex::has_value_t<std::map<int, double>>::value, "map 有 value_type");
static_assert(!yggr::container_ex::has_value_t<int>::value, "int 没有 value_type");
```

## 适用场景

- 泛型编程中需要自动判断类型是否带有 `value_type`（如 STL 容器）。
- 需要根据类型特性自动适配不同的模板实现。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_allocator.hpp` 的文档说明：

---

# 文件：is_allocator.hpp

## 简介

`is_allocator.hpp` 是 yggdrasil 项目中用于检测类型是否为分配器（allocator）的元编程工具头文件。它通过类型萃取和特化，实现在编译期判断任意类型 T 是否满足分配器的特征，便于泛型编程中自动适配分配器相关的模板实现。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/container_ex/detail/is_allocator_detail.hpp>`：实际实现了分配器检测逻辑。
- **核心结构体与功能**：
  1. **is_allocator<T>**
     - 继承自 `detail::is_allocator_impl<T>::type`，用于判断类型 T 是否为分配器类型。
     - `type` 通常为 `boost::mpl::bool_`，可通过 `is_allocator<T>::value` 获取布尔结果。
- **别名**：
  - 通过 `using` 语句将 `is_allocator` 类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/is_allocator.hpp>
#include <memory>

static_assert(yggr::is_allocator<std::allocator<int>>::value, "std::allocator 是分配器");
static_assert(!yggr::is_allocator<int>::value, "int 不是分配器");
```

## 适用场景

- 泛型编程中需要自动判断类型是否为分配器（如 STL allocator）。
- 需要根据类型特性自动适配不同的模板实现。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_container.hpp` 的文档说明：

---

# 文件：is_container.hpp

## 简介

`is_container.hpp` 是 yggdrasil 项目中用于检测类型是否为容器（container）的元编程工具头文件。它通过类型萃取和特化，实现在编译期判断任意类型 T 是否满足容器的特征，便于泛型编程中自动适配容器相关的模板实现。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/container_ex/detail/is_container_detail.hpp>`：实际实现了容器检测逻辑。
- **核心结构体与功能**：
  1. **is_container<T>**
     - 继承自 `detail::is_container_helper<T>::type`，用于判断类型 T 是否为容器类型。
     - `type` 通常为 `boost::mpl::bool_`，可通过 `is_container<T>::value` 获取布尔结果。
- **别名**：
  - 通过 `using` 语句将 `is_container` 类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/is_container.hpp>
#include <vector>
#include <map>

static_assert(yggr::is_container<std::vector<int>>::value, "vector 是容器");
static_assert(yggr::is_container<std::map<int, double>>::value, "map 是容器");
static_assert(!yggr::is_container<int>::value, "int 不是容器");
```

## 适用场景

- 泛型编程中需要自动判断类型是否为容器（如 STL 容器）。
- 需要根据类型特性自动适配不同的模板实现。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `is_static_container.hpp` 的文档说明：

---

# 文件：is_static_container.hpp

## 简介

`is_static_container.hpp` 是 yggdrasil 项目中用于检测类型是否为“静态容器”（如原生数组、`boost::array`、`std::array` 等）的元编程工具头文件。它通过类型萃取和特化，实现在编译期判断任意类型 T 是否为静态容器，便于泛型编程中自动适配静态容器相关的模板实现。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/container_ex/has_value_t.hpp>`：检测类型是否有 `value_type`。
  - `<yggr/container_ex/has_iterator_t.hpp>`：检测类型是否有迭代器。
  - Boost TypeTraits：如 `boost::is_array`。
- **核心结构体与功能**：
  1. **detail::is_static_container_helper<T>**
     - 对于原生数组类型，直接继承自 `boost::is_array<T>`，判断是否为数组。
     - 对于类似 `C<T, N>` 形式的模板类型（如 `boost::array`、`std::array`），只有同时拥有 `value_type` 和迭代器类型时才判定为静态容器。
  2. **is_static_container<T>**
     - 对外统一接口，继承自 `is_static_container_helper<T>`，可通过 `is_static_container<T>::value` 获取布尔结果。
- **别名**：
  - 通过 `using` 语句将 `is_static_container` 类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/is_static_container.hpp>
#include <array>
#include <vector>

static_assert(yggr::is_static_container<int[5]>::value, "int[5] 是静态容器");
static_assert(yggr::is_static_container<std::array<int, 3>>::value, "std::array 是静态容器");
static_assert(!yggr::is_static_container<std::vector<int>>::value, "vector 不是静态容器");
```

## 适用场景

- 泛型编程中需要自动判断类型是否为静态容器（如原生数组、`boost::array`、`std::array`）。
- 需要根据类型特性自动适配不同的模板实现。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `list_regularisation.hpp` 的文档说明：

---

# 文件：list_regularisation.hpp

## 简介

`list_regularisation.hpp` 是 yggdrasil 项目中用于标准化（正规化）list 容器类型的元编程工具头文件。它通过类型萃取和模板特化，自动生成“正规化”的 list 类型，确保类型参数（元素类型、分配器等）都为标准形式，便于泛型编程和容器适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/range_ex/range_value_ex.hpp>`：获取容器的元素类型。
  - `<yggr/container_ex/allocator_t.hpp>`：获取容器的分配器类型。
  - `<yggr/container_ex/list_options_t.hpp>`：获取 list 选项类型（本文件未直接用到，但为扩展预留）。
- **核心结构体与功能**：
  1. **detail::list_regularisation_detail<T>**
     - 默认继承自 `mplex::null_type`，表示无法正规化。
     - 针对 `Lst<T, A>` 形式的模板类型，正规化为 `Lst<元素类型, 分配器类型>`，其中元素类型和分配器类型均通过相关萃取工具自动获取。
  2. **list_regularisation<T>**
     - 对外统一接口，继承自 `list_regularisation_detail<T>`，自动生成正规化的 list 类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/list_regularisation.hpp>

// 假设 MyList<T, Alloc> 是自定义 list 类型
typedef yggr::list_regularisation<MyList<int, MyAlloc>>::type norm_type; // MyList<元素类型, 分配器类型>
```

## 适用场景

- 泛型编程中需要自动生成标准化的 list 容器类型，确保类型参数一致性。
- 需要对不同参数形式的 list 容器进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `map_options_t.hpp` 的文档说明：

---

# 文件：map_options_t.hpp

## 简介

`map_options_t.hpp` 是 yggdrasil 项目中用于从类型 T 中萃取 map/multimap 容器选项的元编程工具头文件。它通过类型展开和模板特化，自动获取带有特定模板参数数量（如 5 个参数）的类型的 map 选项类型，便于泛型编程中对 map、multimap 容器参数的统一访问和适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/mplex/typename_expand.hpp>`：类型展开工具。
  - `<yggr/container/get_map_options.hpp>`：获取 map 选项的工具。
- **核心结构体与功能**：
  1. **detail::map_options_t_detail<T, tpl_arg_size>**
     - 默认继承自 `mplex::null_type`，表示无法获取选项。
     - 当类型 T 的模板参数数量为 5 时，`type` 为 `container::detail::get_tree_options<...>::type`，即通过类型展开获取第 5 个模板参数作为 map 选项类型。
  2. **map_options_t<T> / multimap_options_t<T>**
     - 对外统一接口，继承自 `map_options_t_detail<T>`，自动提取类型 T 的 map 或 multimap 选项类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/map_options_t.hpp>

// 假设 MyMap<K, V, Cmp, Alloc, Options> 是一个有5个模板参数的类型
typedef yggr::map_options_t<MyMap<int, double, MyCmp, MyAlloc, MyOptions>>::type options_type; // MyOptions
```

## 适用场景

- 泛型编程中需要自动获取自定义 map/multimap 容器的选项类型（如第五个模板参数）。
- 需要对不同 map/multimap 容器的选项参数进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `map_regularisation.hpp` 的文档说明：

---

# 文件：map_regularisation.hpp

## 简介

`map_regularisation.hpp` 是 yggdrasil 项目中用于标准化（正规化）map/multimap 容器类型的元编程工具头文件。它通过类型萃取和模板特化，自动生成“正规化”的 map 或 multimap 类型，确保类型参数（键类型、值类型、比较器、分配器、选项等）都为标准形式，便于泛型编程和容器适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/range_ex/range_value_ex.hpp>`：获取容器的元素类型。
  - `<yggr/container_ex/allocator_t.hpp>`：获取容器的分配器类型。
  - `<yggr/container_ex/container_compare_t.hpp>`：获取容器的比较器类型。
  - `<yggr/container_ex/container_mapped_value_t.hpp>`：获取容器的映射值类型。
  - `<yggr/container_ex/container_key_t.hpp>`：获取容器的键类型。
  - `<yggr/container_ex/map_options_t.hpp>`：获取 map 选项类型。
- **核心结构体与功能**：
  1. **detail::map_regularisation_detail<T>**
     - 默认继承自 `mplex::null_type`，表示无法正规化。
     - 针对 `MapOrMMap<K, T, C, A>` 形式的模板类型，正规化为 `MapOrMMap<键类型, 映射值类型, 比较器类型, 分配器类型>`。
     - 针对 `MapOrMMap<K, T, C, A, O>` 形式的模板类型，正规化为 `MapOrMMap<键类型, 映射值类型, 比较器类型, 分配器类型, 选项类型>`。
     - 所有类型参数均通过相关萃取工具自动获取。
  2. **map_regularisation<T>**
     - 对外统一接口，继承自 `map_regularisation_detail<T>`，自动生成正规化的 map 或 multimap 类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/map_regularisation.hpp>

// 假设 MyMap<K, V, Cmp, Alloc> 或 MyMap<K, V, Cmp, Alloc, Options> 是自定义 map 类型
typedef yggr::map_regularisation<MyMap<int, double, MyCmp, MyAlloc>>::type norm_type1; // MyMap<键类型, 映射值类型, 比较器类型, 分配器类型>
typedef yggr::map_regularisation<MyMap<int, double, MyCmp, MyAlloc, MyOptions>>::type norm_type2; // MyMap<键类型, 映射值类型, 比较器类型, 分配器类型, 选项类型>
```

## 适用场景

- 泛型编程中需要自动生成标准化的 map/multimap 容器类型，确保类型参数一致性。
- 需要对不同参数形式的 map/multimap 容器进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `set_options_t.hpp` 的文档说明：

---

# 文件：set_options_t.hpp

## 简介

`set_options_t.hpp` 是 yggdrasil 项目中用于从类型 T 中萃取 set/multiset 容器选项的元编程工具头文件。它通过类型展开和模板特化，自动获取带有特定模板参数数量（如 4 个参数）的类型的 set 选项类型，便于泛型编程中对 set、multiset 容器参数的统一访问和适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/mplex/typename_expand.hpp>`：类型展开工具。
  - `<yggr/container/get_set_options.hpp>`：获取 set 选项的工具。
- **核心结构体与功能**：
  1. **detail::set_options_t_detail<T, tpl_arg_size>**
     - 默认继承自 `mplex::null_type`，表示无法获取选项。
     - 当类型 T 的模板参数数量为 4 时，`type` 为 `container::detail::get_tree_options<...>::type`，即通过类型展开获取第 4 个模板参数作为 set 选项类型。
  2. **set_options_t<T> / multiset_options_t<T>**
     - 对外统一接口，继承自 `set_options_t_detail<T>`，自动提取类型 T 的 set 或 multiset 选项类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/set_options_t.hpp>

// 假设 MySet<K, Cmp, Alloc, Options> 是一个有4个模板参数的类型
typedef yggr::set_options_t<MySet<int, MyCmp, MyAlloc, MyOptions>>::type options_type; // MyOptions
```

## 适用场景

- 泛型编程中需要自动获取自定义 set/multiset 容器的选项类型（如第四个模板参数）。
- 需要对不同 set/multiset 容器的选项参数进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `set_regularisation.hpp` 的文档说明：

---

# 文件：set_regularisation.hpp

## 简介

`set_regularisation.hpp` 是 yggdrasil 项目中用于标准化（正规化）set/multiset 容器类型的元编程工具头文件。它通过类型萃取和模板特化，自动生成“正规化”的 set 或 multiset 类型，确保类型参数（元素类型、比较器、分配器、选项等）都为标准形式，便于泛型编程和容器适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/range_ex/range_value_ex.hpp>`：获取容器的元素类型。
  - `<yggr/container_ex/allocator_t.hpp>`：获取容器的分配器类型。
  - `<yggr/container_ex/container_compare_t.hpp>`：获取容器的比较器类型。
  - `<yggr/container_ex/set_options_t.hpp>`：获取 set 选项类型。
- **核心结构体与功能**：
  1. **detail::set_regularisation_detail<T>**
     - 默认继承自 `mplex::null_type`，表示无法正规化。
     - 针对 `SetOrMSet<T, C, A>` 形式的模板类型，正规化为 `SetOrMSet<元素类型, 比较器类型, 分配器类型>`。
     - 针对 `SetOrMSet<T, C, A, O>` 形式的模板类型，正规化为 `SetOrMSet<元素类型, 比较器类型, 分配器类型, 选项类型>`。
     - 所有类型参数均通过相关萃取工具自动获取。
  2. **set_regularisation<T>**
     - 对外统一接口，继承自 `set_regularisation_detail<T>`，自动生成正规化的 set 或 multiset 类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/set_regularisation.hpp>

// 假设 MySet<T, Cmp, Alloc> 或 MySet<T, Cmp, Alloc, Options> 是自定义 set 类型
typedef yggr::set_regularisation<MySet<int, MyCmp, MyAlloc>>::type norm_type1; // MySet<元素类型, 比较器类型, 分配器类型>
typedef yggr::set_regularisation<MySet<int, MyCmp, MyAlloc, MyOptions>>::type norm_type2; // MySet<元素类型, 比较器类型, 分配器类型, 选项类型>
```

## 适用场景

- 泛型编程中需要自动生成标准化的 set/multiset 容器类型，确保类型参数一致性。
- 需要对不同参数形式的 set/multiset 容器进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `vector_options_t.hpp` 的文档说明：

---

# 文件：vector_options_t.hpp

## 简介

`vector_options_t.hpp` 是 yggdrasil 项目中用于从类型 T 中萃取 vector 容器选项的元编程工具头文件。它通过类型展开和模板特化，自动获取带有特定模板参数数量（如 3 个参数）的类型的 vector 选项类型，便于泛型编程中对 vector 容器参数的统一访问和适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/mplex/typename_expand.hpp>`：类型展开工具。
  - `<yggr/range_ex/range_size_ex.hpp>`：获取容器大小类型。
  - `<yggr/container/get_vector_options.hpp>`：获取 vector 选项的工具。
- **核心结构体与功能**：
  1. **detail::vector_options_t_detail<T, tpl_arg_size>**
     - 默认继承自 `mplex::null_type`，表示无法获取选项。
     - 当类型 T 的模板参数数量为 3 时，`type` 为 `container::get_vector_options<tpl_arg_options_type, now_size_type>::type`，即通过类型展开获取第 3 个模板参数和当前容器大小类型作为 vector 选项类型。
  2. **vector_options_t<T>**
     - 对外统一接口，继承自 `vector_options_t_detail<T>`，自动提取类型 T 的 vector 选项类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/vector_options_t.hpp>

// 假设 MyVector<T, Alloc, Options> 是一个有3个模板参数的类型
typedef yggr::vector_options_t<MyVector<int, MyAlloc, MyOptions>>::type options_type; // MyOptions
```

## 适用场景

- 泛型编程中需要自动获取自定义 vector 容器的选项类型（如第三个模板参数）。
- 需要对不同 vector 容器的选项参数进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: 以下是 `vector_regularisation.hpp` 的文档说明：

---

# 文件：vector_regularisation.hpp

## 简介

`vector_regularisation.hpp` 是 yggdrasil 项目中用于标准化（正规化）vector 容器类型的元编程工具头文件。它通过类型萃取和模板特化，自动生成“正规化”的 vector 类型，确保类型参数（元素类型、分配器、选项等）都为标准形式，便于泛型编程和容器适配。

## 主要内容

- **命名空间**：所有内容位于 `yggr::container_ex` 命名空间下。
- **依赖**：
  - `<yggr/range_ex/range_value_ex.hpp>`：获取容器的元素类型。
  - `<yggr/container_ex/allocator_t.hpp>`：获取容器的分配器类型。
  - `<yggr/container_ex/vector_options_t.hpp>`：获取 vector 选项类型。
- **核心结构体与功能**：
  1. **detail::vector_regularisation_detail<T>**
     - 默认继承自 `mplex::null_type`，表示无法正规化。
     - 针对 `Vt<T, A>` 形式的模板类型，正规化为 `Vt<元素类型, 分配器类型>`。
     - 针对 `Vt<T, A, O>` 形式的模板类型，正规化为 `Vt<元素类型, 分配器类型, 选项类型>`。
     - 所有类型参数均通过相关萃取工具自动获取。
  2. **vector_regularisation<T>**
     - 对外统一接口，继承自 `vector_regularisation_detail<T>`，自动生成正规化的 vector 类型。
- **别名**：
  - 通过 `using` 语句将上述类型提升到 yggr 命名空间，便于直接使用。

## 用法示例

```cpp
#include <yggr/container_ex/vector_regularisation.hpp>

// 假设 MyVector<T, Alloc> 或 MyVector<T, Alloc, Options> 是自定义 vector 类型
typedef yggr::vector_regularisation<MyVector<int, MyAlloc>>::type norm_type1; // MyVector<元素类型, 分配器类型>
typedef yggr::vector_regularisation<MyVector<int, MyAlloc, MyOptions>>::type norm_type2; // MyVector<元素类型, 分配器类型, 选项类型>
```

## 适用场景

- 泛型编程中需要自动生成标准化的 vector 容器类型，确保类型参数一致性。
- 需要对不同参数形式的 vector 容器进行统一适配和处理。

## 版权声明

本文件遵循 MIT 许可证，允许自由使用、修改和分发。

---

如需更详细的 API 注释或中英文对照文档，可进一步补充。