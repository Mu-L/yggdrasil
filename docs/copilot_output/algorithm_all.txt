alucard-dracula: 为这个文件生成文档

GitHub Copilot: # boyer_moore_horspool.hpp 文档

该头文件实现了 Boyer-Moore-Horspool 字符串搜索算法的泛型模板类和相关辅助函数。Boyer-Moore-Horspool 算法是一种高效的字符串查找算法，适用于大文本中查找子串。

---

## 主要内容

### 命名空间

- `yggr::algorithm`  
  主要算法实现。
- `yggr::algorithm::swap_support`  
  提供 swap 支持。
- `std` 和 `boost`  
  通过 using 声明支持 swap。

---

## 主要类

### `boyer_moore_horspool`

#### 模板参数

- `PatIter`：模式串迭代器类型
- `PatTraits`：模式串特征（traits），默认使用 `detail::bm_traits<PatIter>`
- `Key_Extractor`：键提取器，默认使用 `container::identity`
- `PatPred`：模式串比较谓词，默认使用 `std::equal_to`

#### 主要成员

- 构造函数支持不同的初始化方式（带/不带谓词、键提取器等）。
- 支持拷贝、移动构造与赋值。
- `operator()`：对目标序列进行搜索，返回匹配区间的迭代器对。
- `reinit`：重新初始化模式串及相关参数。
- `swap`：交换两个对象内容。
- `key_extor`、`pat_comp`：获取当前的键提取器和比较谓词。

#### 内部实现

- 使用 `bm_skip_table` 构建跳跃表以加速搜索。
- `do_search` 为核心搜索实现，采用逆序比较和跳跃表优化。
- `build_skip_table` 用于初始化跳跃表。

---

## 主要函数

### `boyer_moore_horspool_search`

一组重载的全局函数，便于直接对区间进行 Boyer-Moore-Horspool 搜索，支持自定义谓词、键提取器等。

#### 典型用法

```cpp
auto result = yggr::boyer_moore_horspool_search(
    corpus_begin, corpus_end, pattern_begin, pattern_end);
```

---

## 其他

- 提供了 `swap` 的泛型支持，可用于标准库和 Boost。
- 头文件依赖于 Yggdrasil 框架的基础设施（如 `bm_skip_table`、`bm_traits`、`identity` 等）。

---

## 注意事项

- 该实现为模板，适用于任意可迭代区间。
- 需要保证传入的迭代器类型和谓词等参数的正确性。
- 依赖于 Yggdrasil 框架的其他头文件和 Boost 库。

---

## 版权声明

MIT License，详见文件头部注释。

---

## 适用场景

- 高效地在大文本或数据流中查找子串或子序列。
- 需要自定义比较方式或键提取方式的场景。

---

如需进一步了解具体用法，请参考相关的 Yggdrasil 框架文档或示例代码。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # boyer_moore.hpp 文档

该头文件实现了通用的 Boyer-Moore 字符串搜索算法模板类及相关辅助函数。Boyer-Moore 算法是一种高效的字符串查找算法，适用于在大文本中查找子串，具有较高的查找效率。

---

## 命名空间结构

- `yggr::algorithm`  
  Boyer-Moore 算法的主要实现。
- `yggr::algorithm::swap_support`  
  提供 `swap` 支持。
- `std` 和 `boost`  
  通过 `using` 声明支持 `swap`。

---

## 主要类

### `boyer_moore`

#### 模板参数

- `PatIter`：模式串迭代器类型
- `PatTraits`：模式串特征（traits），默认 `detail::bm_traits<PatIter>`
- `Key_Extractor`：键提取器，默认 `container::identity`
- `PatPred`：模式串比较谓词，默认 `std::equal_to`

#### 主要成员

- **构造函数**：支持不同初始化方式（带/不带谓词、键提取器等）。
- **拷贝/移动构造与赋值**：支持对象的拷贝和移动。
- **operator()**：对目标序列进行搜索，返回匹配区间的迭代器对。
- **reinit**：重新初始化模式串及相关参数。
- **swap**：交换两个对象内容。
- **key_extor/pat_comp**：获取当前的键提取器和比较谓词。
- **skip_table/suffix_table**（仅 Debug）：获取跳跃表和后缀表。

#### 内部实现

- 使用 `bm_skip_table` 构建跳跃表以加速搜索。
- 使用后缀表（Good Suffix Rule）进一步优化跳跃。
- `do_search` 为核心搜索实现，采用逆序比较和跳跃表、后缀表优化。
- `build_skip_table` 和 `build_suffix_table` 用于初始化跳跃表和后缀表。

---

## 主要函数

### `boyer_moore_search`

一组重载的全局函数，便于直接对区间进行 Boyer-Moore 搜索，支持自定义谓词、键提取器等。

#### 典型用法

```cpp
auto result = yggr::boyer_moore_search(
    corpus_begin, corpus_end, pattern_begin, pattern_end);
```

---

## 其他

- 提供了 `swap` 的泛型支持，可用于标准库和 Boost。
- 头文件依赖于 Yggdrasil 框架的基础设施（如 `bm_skip_table`、`bm_traits`、`identity` 等）。

---

## 注意事项

- 该实现为模板，适用于任意可迭代区间。
- 需要保证传入的迭代器类型和谓词等参数的正确性。
- 依赖于 Yggdrasil 框架的其他头文件和 Boost 库。

---

## 版权声明

MIT License，详见文件头部注释。

---

## 适用场景

- 高效地在大文本或数据流中查找子串或子序列。
- 需要自定义比较方式或键提取方式的场景。

---

如需进一步了解具体用法，请参考相关的 Yggdrasil 框架文档或示例代码。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # boyer_moore.hpp 文档

该头文件实现了通用的 Boyer-Moore 字符串搜索算法模板类及相关辅助函数。Boyer-Moore 算法是一种高效的字符串查找算法，适用于在大文本或数据流中查找子串，具有较高的查找效率。

---

## 命名空间

- **yggr::algorithm**  
  Boyer-Moore 算法的主要实现。
- **yggr::algorithm::swap_support**  
  提供 swap 支持。
- **std / boost**  
  通过 using 声明支持 swap。

---

## 主要类

### `boyer_moore`

#### 模板参数

- `PatIter`：模式串迭代器类型
- `PatTraits`：模式串特征（traits），默认 `detail::bm_traits<PatIter>`
- `Key_Extractor`：键提取器，默认 `container::identity`
- `PatPred`：模式串比较谓词，默认 `std::equal_to`

#### 主要成员

- **构造函数**：支持不同初始化方式（带/不带谓词、键提取器等）。
- **拷贝/移动构造与赋值**：支持对象的拷贝和移动。
- **operator()**：对目标序列进行搜索，返回匹配区间的迭代器对。
- **reinit**：重新初始化模式串及相关参数。
- **swap**：交换两个对象内容。
- **key_extor/pat_comp**：获取当前的键提取器和比较谓词。
- **skip_table/suffix_table**（仅 Debug）：获取跳跃表和后缀表。

#### 内部实现

- 使用 `bm_skip_table` 构建跳跃表以加速搜索。
- 使用后缀表（Good Suffix Rule）进一步优化跳跃。
- `do_search` 为核心搜索实现，采用逆序比较和跳跃表、后缀表优化。
- `build_skip_table` 和 `build_suffix_table` 用于初始化跳跃表和后缀表。

---

## 主要函数

### `boyer_moore_search`

一组重载的全局函数，便于直接对区间进行 Boyer-Moore 搜索，支持自定义谓词、键提取器等。

#### 典型用法

```cpp
auto result = yggr::boyer_moore_search(
    corpus_begin, corpus_end, pattern_begin, pattern_end);
```

---

## 其他说明

- 提供了 swap 的泛型支持，可用于标准库和 Boost。
- 头文件依赖于 Yggdrasil 框架的基础设施（如 `bm_skip_table`、`bm_traits`、`identity` 等）。
- 该实现为模板，适用于任意可迭代区间。
- 需要保证传入的迭代器类型和谓词等参数的正确性。
- 依赖于 Yggdrasil 框架的其他头文件和 Boost 库。

---

## 版权声明

MIT License，详见文件头部注释。

---

## 适用场景

- 高效地在大文本或数据流中查找子串或子序列。
- 需要自定义比较方式或键提取方式的场景。

---

如需进一步了解具体用法，请参考相关的 Yggdrasil 框架文档或示例代码。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # is_permutation.hpp 文档

该头文件实现了一个用于判断两个序列是否为排列关系的算法 `is_permutation`。如果编译器支持 C++11 及以上标准，则直接使用标准库的 `std::is_permutation`；否则，提供了自定义实现。

---

## 命名空间

- **yggr::algorithm**  
  算法实现所在命名空间。
- **yggr**  
  通过 `using` 声明将 `is_permutation` 引入 yggr 全局命名空间。

---

## 主要内容

### is_permutation 算法

#### 作用

判断两个序列是否为排列关系（即包含相同元素且每个元素出现次数相同，顺序可以不同）。

#### 模板参数

- `ForwardIterator1`：第一个序列的前向迭代器类型
- `ForwardIterator2`：第二个序列的前向迭代器类型

#### 用法示例

```cpp
#include <yggr/algorithm/is_permutation.hpp>
#include <vector>

std::vector<int> a = {1, 2, 3};
std::vector<int> b = {3, 1, 2};
bool result = yggr::is_permutation(a.begin(), a.end(), b.begin()); // result == true
```

#### 实现说明（C++11 以下）

- 首先比较两个序列的前缀是否完全相同，若完全相同则直接返回 true。
- 若不完全相同，则统计每个未重复元素在两个序列中的出现次数，若每个元素出现次数一致，则为排列关系，否则不是。
- 时间复杂度 O(N^2)（最坏情况下）。

#### C++11 及以上

- 直接使用标准库 `std::is_permutation`。

---

## 版权声明

MIT License，详见文件头部注释。

---

## 适用场景

- 判断两个区间是否为排列关系，适用于泛型容器和自定义类型。
- 可用于 C++98/03 环境下的兼容性开发。

---

如需进一步了解具体用法，请参考相关的 Yggdrasil 框架文档或示例代码。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # knuth_morris_pratt.hpp 文档

该头文件实现了通用的 Knuth-Morris-Pratt（KMP）字符串搜索算法模板类及相关辅助函数。KMP 算法是一种高效的字符串查找算法，适用于在大文本或数据流中查找子串，具有线性时间复杂度。

---

## 命名空间

- **yggr::algorithm**  
  KMP 算法的主要实现。
- **yggr::algorithm::swap_support**  
  提供 swap 支持。
- **std / boost**  
  通过 using 声明支持 swap。

---

## 主要类

### `knuth_morris_pratt`

#### 模板参数

- `PatIter`：模式串迭代器类型
- `PatTraits`：模式串特征（traits），默认 `detail::kmp_traits<PatIter>`
- `PatPred`：模式串比较谓词，默认 `std::equal_to`

#### 主要成员

- **构造函数**：支持不同初始化方式（带/不带谓词）。
- **拷贝/移动构造与赋值**：支持对象的拷贝和移动。
- **operator()**：对目标序列进行搜索，返回匹配区间的迭代器对。
- **reinit**：重新初始化模式串及相关参数。
- **swap**：交换两个对象内容。
- **pat_comp**：获取当前的比较谓词。
- **skip_table**（仅 Debug）：获取内部的跳跃表（失配表）。

#### 内部实现

- 使用失配表（skip table）加速搜索过程。
- `init_skip_table` 用于初始化失配表。
- `do_search` 为核心搜索实现，采用失配表优化。

---

## 主要函数

### `knuth_morris_pratt_search`

一组重载的全局函数，便于直接对区间进行 KMP 搜索，支持自定义谓词等。

#### 典型用法

```cpp
auto result = yggr::knuth_morris_pratt_search(
    corpus_begin, corpus_end, pattern_begin, pattern_end);
```

---

## 其他说明

- 提供了 swap 的泛型支持，可用于标准库和 Boost。
- 头文件依赖于 Yggdrasil 框架的基础设施（如 `kmp_traits`、`vector` 等）。
- 该实现为模板，适用于任意可迭代区间。
- 需要保证传入的迭代器类型和谓词等参数的正确性。
- 依赖于 Yggdrasil 框架的其他头文件和 Boost 库。

---

## 版权声明

MIT License，详见文件头部注释。

---

## 适用场景

- 高效地在大文本或数据流中查找子串或子序列。
- 需要自定义比较方式的场景。

---

如需进一步了解具体用法，请参考相关的 Yggdrasil 框架文档或示例代码。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # lexicographical_c_compare.hpp 文档

该头文件实现了泛型的字典序比较（lexicographical compare）算法，支持高效的内存块比较和自定义比较器。适用于二进制数据、容器、指针等多种场景，兼容 C++98/03/11。

---

## 命名空间

- **yggr::algorithm**  
  算法实现主命名空间。
- **yggr::algorithm::detail**  
  内部实现细节。
- **yggr**  
  通过 using 声明将主要类型和函数引入全局命名空间。

---

## 主要类型与结构体

- **c_cmp**  
  默认比较器，返回 -1/0/1，分别表示小于/等于/大于。
- **c_hex_cmp**  
  以无符号类型进行比较，适合十六进制或字节数据。
- **c_mem_cmp**  
  标记类型，用于内存块比较。
- **memcmpable**  
  类型萃取结构体，判断两种迭代器类型是否可以直接用 memcmp 比较。

---

## 主要函数

### lexicographical_c_compare

#### 作用

对两个区间进行字典序比较，返回：
- 0：区间内容相等
- -1：第一个区间小于第二个区间
- 1：第一个区间大于第二个区间

#### 重载

- `lexicographical_c_compare(iter1_s, iter1_e, iter2_s, iter2_e)`  
  使用默认比较器 `c_cmp`。
- `lexicographical_c_compare(iter1_s, iter1_e, iter2_s, iter2_e, cmp)`  
  使用自定义比较器。

#### 内部机制

- 对于可直接内存比较的区间（如指针、无符号类型、随机访问迭代器），自动调用 `memcmp`，大幅提升效率。
- 对于不支持内存比较的类型，逐元素调用比较器进行比较。
- 支持自定义比较器（如 `c_hex_cmp`、`c_mem_cmp` 等）。

#### 用法示例

```cpp
#include <yggr/algorithm/lexicographical_c_compare.hpp>
#include <vector>
std::vector<unsigned char> a = {1, 2, 3};
std::vector<unsigned char> b = {1, 2, 4};
int result = yggr::lexicographical_c_compare(a.begin(), a.end(), b.begin(), b.end());
// result == -1
```

---

## 其他说明

- 依赖于 Yggdrasil 框架的类型萃取、字节工具、迭代器工具等。
- 针对不同类型自动选择最优比较方式，兼容性和性能兼顾。
- 支持 boost 的类型萃取和 enable_if/disable_if 技术。

---

## 版权声明

MIT License，详见文件头部注释。

---

## 适用场景

- 二进制数据、字节流的高效比较。
- 容器、指针等多种类型的泛型字典序比较。
- 需要自定义比较规则的场景。

---

如需进一步了解具体用法，请参考相关的 Yggdrasil 框架文档或示例代码。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: # shuffle.hpp 文档

该头文件实现了泛型的序列随机打乱（shuffle）算法，兼容 C++98/03/11/17 及 Boost 环境。根据编译环境自动选择合适的打乱实现，保证在不同标准下都能安全高效地使用。

---

## 命名空间

- **yggr::algorithm**  
  算法实现主命名空间。
- **yggr**  
  通过 using 声明将 shuffle 引入全局命名空间。

---

## 主要内容

### shuffle 算法

#### 作用

对指定区间的元素进行随机打乱（洗牌），常用于随机化容器内容、实现洗牌算法等。

#### 重载与实现

- **C++17 之前（含 C++98/03/11）**  
  - 若支持 `std::random_shuffle`，则使用该函数。
  - 提供默认随机数生成器 `default_random_number_generator`，基于 `yggr::gen_random`。
  - 支持自定义随机数生成器。
- **C++17 及以上**  
  - 使用标准库 `std::shuffle`，基于现代随机数引擎（如 `std::mt19937`）。
  - 内部默认使用 `std::random_device` 和 `std::mt19937`。

#### 用法示例

```cpp
#include <yggr/algorithm/shuffle.hpp>
#include <vector>
std::vector<int> v = {1, 2, 3, 4, 5};
yggr::shuffle(v.begin(), v.end());
```

---

## 其他说明

- 自动适配不同 C++ 标准和 Boost 特性，无需手动区分环境。
- 支持自定义随机数生成器，满足高级需求。
- 依赖于 Yggdrasil 框架的随机数工具和类型定义。

---

## 版权声明

MIT License，详见文件头部注释。

---

## 适用场景

- 容器、数组等序列的随机打乱。
- 需要兼容多种 C++ 标准的项目。
- 需要自定义或高质量随机数生成器的场景。

---

如需进一步了解具体用法，请参考相关的 Yggdrasil 框架文档或示例代码。