alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_list_opt.hpp 文档

# 文件简介

`safe_list_opt.hpp` 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的 list 容器（safe_list）的优化版本。该文件依赖于 Boost 库，并通过多种宏和模板技巧，提供了高性能、线程安全的 list 操作。

# 主要功能

- 提供线程安全的 list 容器 `safe_list`，支持多线程环境下的安全访问和修改。
- 针对 Boost 1.70.0 及以上版本，支持自定义底层容器类型（如 `boost::container::list` 或 `yggr::container::detail::list`）。
- 支持多种构造、赋值、交换、插入、删除、访问等标准 list 操作，并通过宏自动生成大量样板代码。
- 支持节点的高效创建与销毁，避免多线程下的资源竞争。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_list<Val, Mutex, Ax, List>`：主模板类，Val 为元素类型，Mutex 为互斥类型，Ax 为分配器，List 为底层容器模板。
- `base_type`：底层容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- `push_front`、`push_back`、`pop_front`、`pop_back` 等常用 list 操作，均为线程安全实现。
- `emplace`、`emplace_front`、`emplace_back`：支持原地构造元素。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过 BOOST_VERSION 宏判断 Boost 版本，自动适配不同实现。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 BOOST_CONTAINER_PERFECT_FORWARDING，自动适配完美转发特性。

# 典型用法

```cpp
#include <yggr/safe_container/safe_list.hpp>

yggr::safe_container::safe_list<int> slist;
slist.push_back(1);
slist.push_front(2);
int val;
if (slist.pop_back(val)) {
    // 使用 val
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_list.hpp。
- 不建议在多线程中直接创建/销毁 safe_list 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_map_opt.hpp 文档

# 文件简介

safe_map_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的 map 容器（safe_map）的优化版本。该文件依赖于 Boost 和 yggdrasil 自身的基础设施，通过模板和宏实现高性能、线程安全的 map 操作。

# 主要功能

- 提供线程安全的 map 容器 `safe_map`，支持多线程环境下的安全访问和修改。
- 针对 Boost 及自定义容器，支持底层容器类型的灵活切换。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准 map 操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_map<Key, Val, Mutex, Cmp, Ax, Map>`：主模板类，Key 为键类型，Val 为值类型，Mutex 为互斥类型，Cmp 为比较器，Ax 为分配器，Map 为底层容器模板。
- `base_type`：底层 map 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- `insert`、`erase`、`find`、`at`、`operator[]` 等常用 map 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 BOOST 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_map.hpp>

yggr::safe_container::safe_map<int, std::string> smap;
smap.insert(std::make_pair(1, "value"));
auto it = smap.find(1);
if (it != smap.end()) {
    // 使用 it->second
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_map.hpp。
- 不建议在多线程中直接创建/销毁 safe_map 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_hashed_index_ha_opt.hpp 文档

# 文件简介

safe_hashed_index_ha_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了多索引哈希表（multi_index hashed index）的线程安全优化版本。该文件依赖 Boost、多索引容器和 yggdrasil 自身的基础设施，通过模板和宏实现高性能、线程安全的哈希索引操作。

# 主要功能

- 提供线程安全的多索引哈希表（safe_hashed_index），支持多线程环境下的安全访问和修改。
- 针对 Boost.MultiIndex 及自定义容器，支持底层哈希索引类型的灵活切换和优化。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历、替换、修改等标准哈希索引操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_hashed_index_ha`：主模板类，支持多种参数配置，封装了哈希索引的线程安全实现。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`replace`、`modify`、`extract`、`emplace` 等常用哈希索引操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost.MultiIndex 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_multi_index_hashed_index.hpp>

yggr::safe_container::safe_hashed_index_ha<MyValueType> sindex;
sindex.insert(value);
auto it = sindex.find(key);
if (it != sindex.end()) {
    // 使用 *it
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_multi_index_hashed_index.hpp。
- 不建议在多线程中直接创建/销毁 safe_hashed_index_ha 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_ordered_index_ha_opt.hpp 文档

# 文件简介

safe_ordered_index_ha_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了多索引有序表（multi_index ordered index）的线程安全优化版本。该文件依赖 Boost、多索引容器和 yggdrasil 自身的基础设施，通过模板和宏实现高性能、线程安全的有序索引操作。

# 主要功能

- 提供线程安全的多索引有序表（safe_ordered_index），支持多线程环境下的安全访问和修改。
- 针对 Boost.MultiIndex 及自定义容器，支持底层有序索引类型的灵活切换和优化。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历、替换、修改等标准有序索引操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_ordered_index_ha`：主模板类，支持多种参数配置，封装了有序索引的线程安全实现。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`replace`、`modify`、`extract`、`emplace` 等常用有序索引操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost.MultiIndex 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_multi_index_ordered_index.hpp>

yggr::safe_container::safe_ordered_index_ha<MyValueType> sindex;
sindex.insert(value);
auto it = sindex.find(key);
if (it != sindex.end()) {
    // 使用 *it
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_multi_index_ordered_index.hpp。
- 不建议在多线程中直接创建/销毁 safe_ordered_index_ha 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_random_access_index_ha_opt.hpp 文档

# 文件简介

safe_random_access_index_ha_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了多索引随机访问表（multi_index random access index）的线程安全优化版本。该文件依赖 Boost、多索引容器和 yggdrasil 自身的基础设施，通过模板和宏实现高性能、线程安全的随机访问索引操作。

# 主要功能

- 提供线程安全的多索引随机访问表（safe_random_access_index），支持多线程环境下的安全访问和修改。
- 针对 Boost.MultiIndex 及自定义容器，支持底层随机访问索引类型的灵活切换和优化。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历、替换、修改、线性操作（如 push/pop/assign）等标准随机访问索引操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_random_access_index_ha`：主模板类，支持多种参数配置，封装了随机访问索引的线程安全实现。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`replace`、`modify`、`extract`、`emplace`、`push_back`、`pop_back`、`assign` 等常用随机访问索引操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost.MultiIndex 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_multi_index_random_access_index.hpp>

yggr::safe_container::safe_random_access_index_ha<MyValueType> sindex;
sindex.push_back(value);
auto it = sindex.find(key);
if (it != sindex.end()) {
    // 使用 *it
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_multi_index_random_access_index.hpp。
- 不建议在多线程中直接创建/销毁 safe_random_access_index_ha 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_ranked_index_ha_opt.hpp 文档

# 文件简介

safe_ranked_index_ha_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了多索引排名表（multi_index ranked index）的线程安全优化版本。该文件依赖 Boost、多索引容器和 yggdrasil 自身的基础设施，通过模板和宏实现高性能、线程安全的排名索引操作。

# 主要功能

- 提供线程安全的多索引排名表（safe_ranked_index），支持多线程环境下的安全访问和修改。
- 针对 Boost.MultiIndex 及自定义容器，支持底层排名索引类型的灵活切换和优化。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历、替换、修改等标准排名索引操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_ranked_index_ha`：主模板类，支持多种参数配置，封装了排名索引的线程安全实现。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`replace`、`modify`、`extract`、`emplace` 等常用排名索引操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 仅在 Boost.MultiIndex 支持 ranked_index 时启用（`YGGR_BOOST_MULTI_INDEX_HAS_RANKED_INDEX`）。

# 典型用法

```cpp
#include <yggr/safe_container/safe_multi_index_ranked_index.hpp>

yggr::safe_container::safe_ranked_index_ha<MyValueType> sindex;
sindex.insert(value);
auto it = sindex.find(key);
if (it != sindex.end()) {
    // 使用 *it
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 且 Boost.MultiIndex 支持 ranked_index 时启用本优化实现。
- 必须先包含 safe_multi_index_ranked_index.hpp。
- 不建议在多线程中直接创建/销毁 safe_ranked_index_ha 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_sequenced_index_ha_opt.hpp 文档

# 文件简介

safe_sequenced_index_ha_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了多索引序列表（multi_index sequenced index）的线程安全优化版本。该文件依赖 Boost、多索引容器和 yggdrasil 自身的基础设施，通过模板和宏实现高性能、线程安全的序列索引操作。

# 主要功能

- 提供线程安全的多索引序列表（safe_sequenced_index），支持多线程环境下的安全访问和修改。
- 针对 Boost.MultiIndex 及自定义容器，支持底层序列索引类型的灵活切换和优化。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历、替换、修改、线性操作（如 push/pop/assign）等标准序列索引操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_sequenced_index_ha`：主模板类，支持多种参数配置，封装了序列索引的线程安全实现。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`replace`、`modify`、`extract`、`emplace`、`push_back`、`pop_back`、`assign` 等常用序列索引操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost.MultiIndex 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_multi_index_sequenced_index.hpp>

yggr::safe_container::safe_sequenced_index_ha<MyValueType> sindex;
sindex.push_back(value);
auto it = sindex.find(key);
if (it != sindex.end()) {
    // 使用 *it
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_multi_index_sequenced_index.hpp。
- 不建议在多线程中直接创建/销毁 safe_sequenced_index_ha 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_multi_index_container.hpp 文档

# 文件简介

safe_multi_index_container.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了多索引容器（multi_index container）的线程安全封装。该文件依赖 Boost.MultiIndex、线程库和 yggdrasil 自身的基础设施，通过模板和宏实现高性能、线程安全的多索引容器操作。

# 主要功能

- 提供线程安全的多索引容器（safe_multi_index_container），支持多线程环境下的安全访问和修改。
- 支持多种索引类型（如哈希、有序、序列、随机访问、排名等），可通过模板参数灵活配置。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准多索引容器操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_multi_index_container`：主模板类，支持多种参数配置，封装了多索引容器的线程安全实现。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`at`、`operator[]`、`swap`、`size`、`empty` 等常用多索引容器操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost.MultiIndex 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/multi_index/safe_multi_index_container.hpp>

yggr::safe_container::safe_multi_index_container<MyValueType, MyIndexTypes...> smic;
smic.insert(value);
auto it = smic.find(key);
if (it != smic.end()) {
    // 使用 *it
}
```

# 注意事项

- 必须先包含 safe_multi_index_container_decl.hpp。
- 不建议在多线程中直接创建/销毁 safe_multi_index_container 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_options_map_opt.hpp 文档

# 文件简介

safe_options_map_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的 options_map 容器（safe_options_map）的优化版本。该文件依赖于 Boost、yggdrasil 自身的基础设施和 options_map 容器，通过模板和宏实现高性能、线程安全的选项映射表操作。

# 主要功能

- 提供线程安全的 options_map 容器 `safe_options_map`，支持多线程环境下的安全访问和修改。
- 针对 Boost 及自定义容器，支持底层 options_map 类型的灵活切换和优化。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准 options_map 操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_options_map<Key, Val, Mutex, Cmp, Ax, Map>`：主模板类，Key 为键类型，Val 为值类型，Mutex 为互斥类型，Cmp 为比较器，Ax 为分配器，Map 为底层容器模板。
- `base_type`：底层 options_map 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`at`、`operator[]`、`swap`、`size`、`empty` 等常用 options_map 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_options_map.hpp>

yggr::safe_container::safe_options_map<int, std::string> somap;
somap.insert(std::make_pair(1, "value"));
auto it = somap.find(1);
if (it != somap.end()) {
    // 使用 it->second
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_options_map.hpp。
- 不建议在多线程中直接创建/销毁 safe_options_map 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_options_set_opt.hpp 文档

# 文件简介

safe_options_set_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的 options_set 容器（safe_options_set）的优化版本。该文件依赖于 Boost、yggdrasil 自身的基础设施和 options_set 容器，通过模板和宏实现高性能、线程安全的选项集合操作。

# 主要功能

- 提供线程安全的 options_set 容器 `safe_options_set`，支持多线程环境下的安全访问和修改。
- 针对 Boost 及自定义容器，支持底层 options_set 类型的灵活切换和优化。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准 options_set 操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_options_set<Key, Mutex, Cmp, Ax, Set>`：主模板类，Key 为元素类型，Mutex 为互斥类型，Cmp 为比较器，Ax 为分配器，Set 为底层容器模板。
- `base_type`：底层 options_set 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`swap`、`size`、`empty` 等常用 options_set 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_options_set.hpp>

yggr::safe_container::safe_options_set<int> soset;
soset.insert(1);
if (soset.find(1) != soset.end()) {
    // 元素存在
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_options_set.hpp。
- 不建议在多线程中直接创建/销毁 safe_options_set 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_set_opt.hpp 文档

# 文件简介

safe_set_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的 set 容器（safe_set）的优化版本。该文件依赖于 Boost、yggdrasil 自身的基础设施和 set 容器，通过模板和宏实现高性能、线程安全的集合操作。

# 主要功能

- 提供线程安全的 set 容器 `safe_set`，支持多线程环境下的安全访问和修改。
- 针对 Boost 及自定义容器，支持底层 set 类型的灵活切换和优化。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准 set 操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_set<Key, Mutex, Cmp, Ax, Set>`：主模板类，Key 为元素类型，Mutex 为互斥类型，Cmp 为比较器，Ax 为分配器，Set 为底层容器模板。
- `base_type`：底层 set 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`swap`、`size`、`empty` 等常用 set 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_set.hpp>

yggr::safe_container::safe_set<int> sset;
sset.insert(1);
if (sset.find(1) != sset.end()) {
    // 元素存在
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_set.hpp。
- 不建议在多线程中直接创建/销毁 safe_set 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_unordered_map_ha_opt.hpp 文档

# 文件简介

safe_unordered_map_ha_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的 unordered_map 容器（safe_unordered_map）的优化版本。该文件依赖于 Boost、yggdrasil 自身的基础设施和 unordered_map 容器，通过模板和宏实现高性能、线程安全的哈希映射表操作。

# 主要功能

- 提供线程安全的 unordered_map 容器 `safe_unordered_map`，支持多线程环境下的安全访问和修改。
- 针对 Boost 及自定义容器，支持底层 unordered_map 类型的灵活切换和优化。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准 unordered_map 操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_unordered_map<Key, Val, Mutex, Hash, Pred, Ax, Map>`：主模板类，Key 为键类型，Val 为值类型，Mutex 为互斥类型，Hash 为哈希函数，Pred 为相等比较器，Ax 为分配器，Map 为底层容器模板。
- `base_type`：底层 unordered_map 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`at`、`operator[]`、`swap`、`size`、`empty` 等常用 unordered_map 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_unordered_map.hpp>

yggr::safe_container::safe_unordered_map<int, std::string> sumap;
sumap.insert(std::make_pair(1, "value"));
auto it = sumap.find(1);
if (it != sumap.end()) {
    // 使用 it->second
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_unordered_map.hpp。
- 不建议在多线程中直接创建/销毁 safe_unordered_map 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_unordered_set_ha_opt.hpp 文档

# 文件简介

safe_unordered_set_ha_opt.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的 unordered_set 容器（safe_unordered_set）的优化版本。该文件依赖于 Boost、yggdrasil 自身的基础设施和 unordered_set 容器，通过模板和宏实现高性能、线程安全的哈希集合操作。

# 主要功能

- 提供线程安全的 unordered_set 容器 `safe_unordered_set`，支持多线程环境下的安全访问和修改。
- 针对 Boost 及自定义容器，支持底层 unordered_set 类型的灵活切换和优化。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准 unordered_set 操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_unordered_set<Key, Mutex, Hash, Pred, Ax, Set>`：主模板类，Key 为元素类型，Mutex 为互斥类型，Hash 为哈希函数，Pred 为相等比较器，Ax 为分配器，Set 为底层容器模板。
- `base_type`：底层 unordered_set 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `insert`、`erase`、`find`、`swap`、`size`、`empty` 等常用 unordered_set 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过宏判断是否启用优化实现（`YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION`）。
- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_unordered_set.hpp>

yggr::safe_container::safe_unordered_set<int> suset;
suset.insert(1);
if (suset.find(1) != suset.end()) {
    // 元素存在
}
```

# 注意事项

- 仅在未定义 `YGGR_NOT_USE_SAFE_CONTAINER_OPTIMIZATION` 时启用本优化实现。
- 必须先包含 safe_unordered_set.hpp。
- 不建议在多线程中直接创建/销毁 safe_unordered_set 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_backup_device.hpp 文档

# 文件简介

safe_backup_device.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的备份设备容器（safe_backup_device）。该文件依赖于 yggdrasil 的 safe_unordered_map 以及函数绑定等基础设施，提供了基于 key/value 的自动 key 生成和备份管理功能。

# 主要功能

- 提供线程安全的备份设备容器 `safe_backup_device`，支持多线程环境下的安全访问和数据备份。
- 支持自定义 key 生成器（KeyGenner），可自动为插入的数据生成唯一 key。
- 基于 safe_unordered_map 实现，支持高效的哈希查找和存储。
- 支持插入、查找、删除、遍历等常用操作。
- 通过 mutex（互斥锁）实现线程安全。

# 主要类型与成员

- `safe_backup_device<Key, Val, KeyGenner, Mutex, HashFoo, Cmp, Alloc>`：主模板类，Key 为键类型，Val 为值类型，KeyGenner 为 key 生成器，Mutex 为互斥类型，HashFoo 为哈希函数，Cmp 为相等比较器，Alloc 为分配器。
- `key_type`、`mapped_type`、`value_type`：类型别名，便于使用。
- 内部使用 `safe_unordered_map` 作为存储结构。
- 支持通过 key 生成器自动分配 key 并插入数据，便于实现备份和恢复等功能。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。

# 典型用法

```cpp
struct MyKeyGen {
    int operator()() { static int k = 0; return ++k; }
};

yggr::safe_container::safe_backup_device<int, std::string, MyKeyGen> backup;
int key = backup.insert("data"); // 自动生成 key 并插入
auto val = backup.find(key);
```

# 注意事项

- 必须提供可调用的 key 生成器类型（KeyGenner）。
- 不建议在多线程中直接创建/销毁 safe_backup_device 实例，推荐使用 swap 进行线程间容器转移。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_buffered_object.hpp 文档

# 文件简介

safe_buffered_object.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的缓冲对象（safe_buffered_object）。该文件依赖于 yggdrasil 的 safe_deque、智能指针、线程库等基础设施，提供了带缓冲区的对象管理功能，适用于高并发场景下的数据缓存与批量处理。

# 主要功能

- 提供线程安全的缓冲对象容器 `safe_buffered_object`，支持多线程环境下的安全访问和批量数据处理。
- 支持自定义缓冲区大小，自动管理数据的入队和出队。
- 支持对象的插入、批量提取、清空、遍历等常用操作。
- 内部基于 `safe_deque` 实现，保证高效的队列操作和线程安全。
- 支持对象的智能指针管理，防止资源泄漏。
- 通过 mutex（互斥锁）实现线程安全。

# 主要类型与成员

- `safe_buffered_object<T, Mutex, Alloc>`：主模板类，T 为元素类型，Mutex 为互斥类型，Alloc 为分配器。
- 支持 `push_back`、`pop_front`、`extract_all`、`clear`、`size`、`empty` 等常用缓冲区操作。
- 支持缓冲区满时的自动处理策略（如批量转移、回调等）。
- 内部使用 `safe_deque` 作为存储结构，支持高效的并发队列操作。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。

# 典型用法

```cpp
yggr::safe_container::safe_buffered_object<int> buffer(100); // 缓冲区大小为100
buffer.push_back(1);
std::vector<int> batch;
buffer.extract_all(batch); // 批量提取所有数据
```

# 注意事项

- 缓冲区大小可自定义，需根据实际业务场景合理设置。
- 不建议在多线程中直接创建/销毁 safe_buffered_object 实例，推荐使用 swap 进行线程间容器转移。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_deque.hpp 文档

# 文件简介

safe_deque.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的双端队列容器（safe_deque）。该文件依赖于 yggdrasil 的 deque、线程库等基础设施，通过模板和宏实现高性能、线程安全的双端队列操作。

# 主要功能

- 提供线程安全的双端队列容器 `safe_deque`，支持多线程环境下的安全访问和修改。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准 deque 操作，并通过宏自动生成大量样板代码。
- 支持前端和后端的高效 push/pop 操作。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_deque<T, Mutex, Alloc, Deque>`：主模板类，T 为元素类型，Mutex 为互斥类型，Alloc 为分配器，Deque 为底层容器模板。
- `base_type`：底层 deque 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `push_back`、`push_front`、`pop_back`、`pop_front`、`insert`、`erase`、`swap`、`size`、`empty` 等常用 deque 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_deque.hpp>

yggr::safe_container::safe_deque<int> sdeque;
sdeque.push_back(1);
sdeque.push_front(2);
int val;
if (sdeque.pop_back(val)) {
    // 使用 val
}
```

# 注意事项

- 必须先包含 safe_deque.hpp。
- 不建议在多线程中直接创建/销毁 safe_deque 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_hashed_map_queue.hpp 文档

# 文件简介

safe_hashed_map_queue.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的哈希映射队列（safe_hashed_map_queue）。该文件结合了哈希表和队列的特性，适用于需要高效键值查找和队列顺序处理的并发场景。

# 主要功能

- 提供线程安全的哈希映射队列容器 `safe_hashed_map_queue`，支持多线程环境下的安全访问和队列操作。
- 结合哈希表的高效查找与队列的顺序处理，适合缓存、任务分发等场景。
- 支持插入、查找、删除、批量提取、遍历等常用操作。
- 支持自定义 key、value、哈希函数、比较器、分配器等参数。
- 内部集成了 safe_deque、safe_multi_index_container 等安全容器，保证高效与线程安全。
- 通过 mutex（互斥锁）实现线程安全。

# 主要类型与成员

- `safe_hashed_map_queue<Key, Val, Mutex, Hash, Pred, Alloc>`：主模板类，Key 为键类型，Val 为值类型，Mutex 为互斥类型，Hash 为哈希函数，Pred 为相等比较器，Alloc 为分配器。
- 支持 `push`、`pop`、`find`、`erase`、`clear`、`size`、`empty`、`swap` 等常用队列和哈希表操作。
- 支持批量提取、遍历、条件删除等高级操作。
- 内部使用 `safe_deque`、`safe_multi_index_container` 等作为存储结构，保证高效的并发操作。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。

# 典型用法

```cpp
yggr::safe_container::safe_hashed_map_queue<int, std::string> queue;
queue.push(1, "data");
std::string val;
if (queue.pop(val)) {
    // 取出队首元素
}
if (queue.find(1, val)) {
    // 查找 key=1 的元素
}
```

# 注意事项

- 必须根据实际业务场景合理选择 key、value 类型及哈希函数等参数。
- 不建议在多线程中直接创建/销毁 safe_hashed_map_queue 实例，推荐使用 swap 进行线程间容器转移。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_options_vector.hpp 文档

# 文件简介

safe_options_vector.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的 options_vector 容器（safe_options_vector）。该文件依赖于 yggdrasil 的 options_vector、线程库等基础设施，通过模板和宏实现高性能、线程安全的可选向量操作。

# 主要功能

- 提供线程安全的 options_vector 容器 `safe_options_vector`，支持多线程环境下的安全访问和修改。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准 vector 操作，并通过宏自动生成大量样板代码。
- 支持前端和后端的高效 push/pop 操作。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_options_vector<T, Mutex, Alloc, Vector>`：主模板类，T 为元素类型，Mutex 为互斥类型，Alloc 为分配器，Vector 为底层容器模板。
- `base_type`：底层 options_vector 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `push_back`、`pop_back`、`insert`、`erase`、`swap`、`size`、`empty`、`at`、`front`、`back` 等常用 vector 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_options_vector.hpp>

yggr::safe_container::safe_options_vector<int> sovec;
sovec.push_back(1);
int val;
if (sovec.pop_back(val)) {
    // 使用 val
}
```

# 注意事项

- 必须先包含 safe_options_vector.hpp。
- 不建议在多线程中直接创建/销毁 safe_options_vector 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_queue.hpp 文档

# 文件简介

safe_queue.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的队列容器（safe_queue）。该文件依赖于 yggdrasil 的 queue、线程库等基础设施，通过模板和宏实现高性能、线程安全的队列操作。

# 主要功能

- 提供线程安全的队列容器 `safe_queue`，支持多线程环境下的安全访问和修改。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准 queue 操作，并通过宏自动生成大量样板代码。
- 支持高效的入队（push）和出队（pop）操作。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_queue<T, Mutex, Alloc, Queue>`：主模板类，T 为元素类型，Mutex 为互斥类型，Alloc 为分配器，Queue 为底层容器模板。
- `base_type`：底层 queue 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `push`、`pop`、`front`、`back`、`swap`、`size`、`empty` 等常用 queue 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_queue.hpp>

yggr::safe_container::safe_queue<int> squeue;
squeue.push(1);
int val;
if (squeue.pop(val)) {
    // 使用 val
}
```

# 注意事项

- 必须先包含 safe_queue.hpp。
- 不建议在多线程中直接创建/销毁 safe_queue 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_stack.hpp 文档

# 文件简介

safe_stack.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的栈容器（safe_stack）。该文件依赖于 yggdrasil 的 stack、线程库等基础设施，通过模板和宏实现高性能、线程安全的栈操作。

# 主要功能

- 提供线程安全的栈容器 `safe_stack`，支持多线程环境下的安全访问和修改。
- 支持多种构造、赋值、交换、入栈（push）、出栈（pop）、访问栈顶（top）、遍历等标准 stack 操作，并通过宏自动生成大量样板代码。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_stack<T, Mutex, Alloc, Stack>`：主模板类，T 为元素类型，Mutex 为互斥类型，Alloc 为分配器，Stack 为底层容器模板。
- `base_type`：底层 stack 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `push`、`pop`、`top`、`swap`、`size`、`empty` 等常用 stack 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_stack.hpp>

yggr::safe_container::safe_stack<int> sstack;
sstack.push(1);
int val;
if (sstack.pop(val)) {
    // 使用 val
}
```

# 注意事项

- 必须先包含 safe_stack.hpp。
- 不建议在多线程中直接创建/销毁 safe_stack 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_vector.hpp 文档

# 文件简介

safe_vector.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的 vector 容器（safe_vector）。该文件依赖于 yggdrasil 的 vector、线程库等基础设施，通过模板和宏实现高性能、线程安全的动态数组操作。

# 主要功能

- 提供线程安全的 vector 容器 `safe_vector`，支持多线程环境下的安全访问和修改。
- 支持多种构造、赋值、交换、插入、删除、查找、遍历等标准 vector 操作，并通过宏自动生成大量样板代码。
- 支持前端和后端的高效 push/pop 操作。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 提供与标准库和 Boost 的 swap 兼容性。

# 主要类型与成员

- `safe_vector<T, Mutex, Alloc, Vector>`：主模板类，T 为元素类型，Mutex 为互斥类型，Alloc 为分配器，Vector 为底层容器模板。
- `base_type`：底层 vector 容器类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `push_back`、`pop_back`、`insert`、`erase`、`swap`、`size`、`empty`、`at`、`front`、`back` 等常用 vector 操作，均为线程安全实现。
- 支持多种构造函数、赋值运算符、swap、比较等操作，兼容标准容器接口。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将容器内部的迭代器、引用、指针等泄漏到容器外部并保存或使用。

# 兼容性与宏

- 通过大量 YGGR_PP_ 开头的宏生成样板代码，减少重复劳动。
- 支持 Boost 容器的特性和完美转发。

# 典型用法

```cpp
#include <yggr/safe_container/safe_vector.hpp>

yggr::safe_container::safe_vector<int> svector;
svector.push_back(1);
int val;
if (svector.pop_back(val)) {
    // 使用 val
}
```

# 注意事项

- 必须先包含 safe_vector.hpp。
- 不建议在多线程中直接创建/销毁 safe_vector 实例，推荐使用 swap 进行线程间容器转移。
- 禁止将容器内部的迭代器、引用、指针等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: safe_wrap.hpp 文档

# 文件简介

safe_wrap.hpp 是 yggdrasil 项目中安全容器模块的一个头文件，主要实现了线程安全的对象包装器（safe_wrap）。该文件为任意对象提供线程安全的封装，适用于需要在多线程环境下安全读写、操作的场景。

# 主要功能

- 提供线程安全的对象包装器 `safe_wrap`，可对任意类型对象进行安全封装。
- 支持对象的安全读写、赋值、交换、克隆等操作。
- 支持自定义锁类型（如 boost::mutex、std::mutex 等）。
- 通过 mutex（互斥锁）实现线程安全，支持读写锁粒度控制。
- 支持智能指针管理，防止资源泄漏。

# 主要类型与成员

- `safe_wrap<T, Mutex>`：主模板类，T 为被包装对象类型，Mutex 为互斥类型。
- `value_type`：被包装对象类型。
- `mutex_type`、`read_lock_type`、`write_lock_type`：线程安全相关类型。
- 支持 `get`、`set`、`swap`、`clone`、`operator=` 等常用操作，均为线程安全实现。
- 支持通过回调安全访问和修改内部对象。

# 线程安全说明

- 所有成员函数均通过互斥锁保护，保证多线程环境下的安全性。
- 容器的创建和销毁本身不保证线程安全，建议在不同线程中创建/销毁时使用 swap 进行隔离。
- 禁止通过回调函数将内部对象的指针、引用等泄漏到外部并保存或使用。

# 典型用法

```cpp
yggr::safe_container::safe_wrap<int> sw(0);
sw.set(42);
int val = sw.get();
sw.swap(other_wrap);
```

# 注意事项

- 必须根据实际业务场景合理选择被包装对象类型和互斥类型。
- 不建议在多线程中直接创建/销毁 safe_wrap 实例，推荐使用 swap 进行线程间对象转移。
- 禁止将内部对象的指针、引用等通过回调泄漏到外部。

# 版权声明

版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可证。

---

如需详细 API 说明，请参考具体成员函数实现和相关宏定义。