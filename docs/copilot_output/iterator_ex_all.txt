alucard-dracula: 为这个文件生成文档

GitHub Copilot:  has_iterator_category.hpp 文档

---

# 文件：has_iterator_category.hpp

## 简介
该头文件定义了一个类型萃取工具 `has_iterator_category`，用于在编译期判断某类型是否定义了 `iterator_category` 类型成员。该工具常用于泛型算法和容器开发中，判断类型是否符合标准迭代器的要求。

## 主要内容

- **命名空间**：`yggr::iterator_ex`
- **核心结构体**：
  - `detail::_has_iterator_category_t<Iter>`：内部实现，利用 SFINAE 技术检测类型 `Iter` 是否有 `iterator_category` 成员。
  - `has_iterator_category<Iter>`：对外接口，继承自 `boost::mpl::bool_`，其 `value` 为 `true` 表示有该成员，否则为 `false`。

## 用法示例

```cpp
#include <yggr/iterator_ex/has_iterator_category.hpp>
#include <vector>
#include <iostream>

int main() {
    std::cout << yggr::has_iterator_category<std::vector<int>::iterator>::value << std::endl; // 输出1
    std::cout << yggr::has_iterator_category<int>::value << std::endl; // 输出0
}
```

## 依赖
- Boost MPL
- yggr 基础类型定义

## 版权声明
版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可协议。

---

如需将此文档添加为注释或 markdown 文件，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot:  insert_iterator.hpp 文档

---

# 文件：insert_iterator.hpp

## 简介
该头文件定义了 `yggr::iterator_ex::insert_iterator` 及其辅助工具，用于为自定义容器或特殊容器提供插入迭代器功能。其行为与标准库的 `std::insert_iterator` 类似，但支持自定义类型和移动语义。

## 主要内容

- **命名空间**：`yggr::iterator_ex`
- **核心类与函数**：
  - `insert_iterator<Container>`：插入迭代器，支持移动和拷贝插入，适用于泛型算法。
  - `inserter(Container&, Iterator)`：工厂函数，生成 `insert_iterator` 实例。
  - 内部辅助结构体 `container_insert_helper`，根据容器类型（类/非类）选择插入方式。
- **特性**：
  - 支持移动语义（C++11及以上）。
  - 兼容自定义容器和标准容器。
  - 仅在 C++14 及以下自定义实现，C++14 以上直接使用标准库实现。

## 用法示例

```cpp
#include <yggr/iterator_ex/insert_iterator.hpp>
#include <vector>
#include <algorithm>

std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = {4, 5, 6};
auto it = yggr::inserter(v1, v1.begin());
std::copy(v2.begin(), v2.end(), it);
// v1 现在为 {4, 5, 6, 1, 2, 3}
```

## 依赖
- Boost
- yggr 基础类型、range_ex 工具
- 标准库 `<iterator>`

## 版权声明
版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可协议。

---

如需将此文档添加为注释或 markdown 文件，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot:  is_const_iterator.hpp 文档

---

# 文件：is_const_iterator.hpp

## 简介
该头文件定义了类型萃取工具 `is_const_iterator`，用于在编译期判断某类型是否为常量迭代器或常量指针。常用于泛型算法、容器开发等场景下类型特性的静态判断。

## 主要内容

- **命名空间**：`yggr::iterator_ex`
- **核心结构体**：
  - `detail::_is_const_iterator_t<T, is_pointer, is_iter>`：内部实现，分别针对指针类型、迭代器类型和其他类型做特化判断。
  - `is_const_iterator<T>`：对外接口，继承自 `boost::mpl::bool_`，其 `value` 为 `true` 表示为常量迭代器或常量指针，否则为 `false`。

## 判断逻辑

- 若类型 `T` 是指针，则判断其指向类型是否为 const。
- 若类型 `T` 是迭代器（具有 `iterator_category`），则判断其 `pointer` 成员所指类型是否为 const。
- 其他情况均为 `false`。

## 用法示例

```cpp
#include <yggr/iterator_ex/is_const_iterator.hpp>
#include <vector>
#include <iostream>

int main() {
    std::cout << yggr::is_const_iterator<const int*>::value << std::endl; // 输出1
    std::cout << yggr::is_const_iterator<std::vector<int>::const_iterator>::value << std::endl; // 输出1
    std::cout << yggr::is_const_iterator<int*>::value << std::endl; // 输出0
}
```

## 依赖
- Boost
- yggr 基础类型、has_iterator_category 工具
- 标准库 `<iterator>`

## 版权声明
版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可协议。

---

如需将此文档添加为注释或 markdown 文件，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot:  is_iterator.hpp 文档

---

# 文件：is_iterator.hpp

## 简介
该头文件定义了类型萃取工具 `is_iterator`，用于在编译期判断某类型是否为迭代器类型。支持指针、标准迭代器和自定义实现了 `iterator_category` 的类型。

## 主要内容

- **命名空间**：`yggr::iterator_ex`
- **核心结构体**：
  - `is_iterator<T>`：继承自 `boost::mpl::bool_`，其 `value` 为 `true` 表示为迭代器类型，否则为 `false`。

## 判断逻辑

- 若类型 `T` 是指针类型，或
- 类型 `T` 拥有 `iterator_category` 成员（即为标准或自定义迭代器），
- 则 `is_iterator<T>::value` 为 `true`，否则为 `false`。

## 用法示例

```cpp
#include <yggr/iterator_ex/is_iterator.hpp>
#include <vector>
#include <iostream>

int main() {
    std::cout << yggr::is_iterator<int*>::value << std::endl; // 输出1
    std::cout << yggr::is_iterator<std::vector<int>::iterator>::value << std::endl; // 输出1
    std::cout << yggr::is_iterator<int>::value << std::endl; // 输出0
}
```

## 依赖
- Boost
- yggr 基础类型、has_iterator_category 工具
- 标准库 `<iterator>`

## 版权声明
版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可协议。

---

如需将此文档添加为注释或 markdown 文件，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot:  is_reverse_iterator.hpp 文档

---

# 文件：is_reverse_iterator.hpp

## 简介
该头文件定义了类型萃取工具 `is_reverse_iterator`，用于在编译期判断某类型是否为反向迭代器。支持标准库 `std::reverse_iterator`、Boost `boost::reverse_iterator` 以及通过宏自定义的反向迭代器类型。

## 主要内容

- **命名空间**：`yggr::iterator_ex`
- **核心结构体与宏**：
  - `is_reverse_iterator<T>`：主接口，继承自 `boost::mpl::bool_`，其 `value` 为 `true` 表示为反向迭代器，否则为 `false`。
  - 内部实现支持对标准库、Boost 反向迭代器的特化判断。
  - 支持通过宏 `YGGR_IS_REVERSE_ITERATOR_IMPORT` 导入自定义反向迭代器类型。

## 判断逻辑

- 若类型为 `std::reverse_iterator` 或 `boost::reverse_iterator`，则为反向迭代器。
- 若类型具有 `iterator_type` 成员且类型特征匹配，也可判定为反向迭代器。
- 可通过宏手动指定自定义类型为反向迭代器。

## 用法示例

```cpp
#include <yggr/iterator_ex/is_reverse_iterator.hpp>
#include <vector>
#include <iterator>
#include <iostream>

int main() {
    std::cout << yggr::is_reverse_iterator<std::vector<int>::reverse_iterator>::value << std::endl; // 输出1
    std::cout << yggr::is_reverse_iterator<int*>::value << std::endl; // 输出0

    // 导入自定义反向迭代器
    // YGGR_IS_REVERSE_ITERATOR_IMPORT(MyReverseIter, true)
}
```

## 依赖
- Boost
- yggr 基础类型、has_iterator_category 工具、mplex 工具
- 标准库 `<iterator>`

## 版权声明
版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可协议。

---

如需将此文档添加为注释或 markdown 文件，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot:  iterator_category_check.hpp 文档

---

# 文件：iterator_category_check.hpp

## 简介
该头文件定义了一组类型萃取工具，用于在编译期判断某类型是否为特定类别的迭代器。支持判断随机访问、双向、前向、输出、输入等标准迭代器类型。

## 主要内容

- **命名空间**：`yggr::iterator_ex`
- **核心结构体**：
  - `is_random_access_iterator<T>`：判断类型 `T` 是否为随机访问迭代器。
  - `is_bidirectional_iterator<T>`：判断类型 `T` 是否为双向迭代器。
  - `is_forward_iterator<T>`：判断类型 `T` 是否为前向迭代器。
  - `is_output_iterator<T>`：判断类型 `T` 是否为输出迭代器。
  - `is_input_iterator<T>`：判断类型 `T` 是否为输入迭代器。
  - `iterator_category_check_result`：统一 true/false 类型定义及常量。

## 判断逻辑

- 通过 `iterator_category_ex<T>::type` 获取类型 `T` 的迭代器类别标签。
- 利用 `boost::is_base_of` 判断该标签是否继承自对应的标准迭代器标签（如 `std::random_access_iterator_tag` 等）。

## 用法示例

```cpp
#include <yggr/iterator_ex/iterator_category_check.hpp>
#include <vector>
#include <iostream>

int main() {
    std::cout << yggr::is_random_access_iterator<std::vector<int>::iterator>::value << std::endl; // 输出1
    std::cout << yggr::is_input_iterator<std::vector<int>::iterator>::value << std::endl; // 输出1
}
```

## 依赖
- Boost
- yggr 基础类型、iterator_traits 工具
- 标准库 `<iterator>`

## 版权声明
版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可协议。

---

如需将此文档添加为注释或 markdown 文件，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot:  iterator_traits.hpp 文档

---

# 文件：iterator_traits.hpp

## 简介
该头文件定义了多种迭代器 traits 工具，兼容 Boost 和标准库，支持自定义迭代器类型的 value、reference、pointer、difference、category 等类型萃取。对 Boost 1.56.0 及以上版本做了特殊适配。

## 主要内容

- **命名空间**：`yggr::iterator_ex`
- **核心结构体**：
  - `iterator_value_ex<Iter>`：获取迭代器的 value_type。
  - `iterator_reference_ex<Iter>`：获取迭代器的 reference 类型，支持 const 迭代器自动推断。
  - `iterator_pointer_ex<Iter>`：获取迭代器的 pointer 类型。
  - `iterator_difference_ex<Iter>`：获取迭代器的 difference_type。
  - `iterator_category_ex<Iter>`：获取迭代器的 category 类型。
- **兼容性**：
  - 针对 Boost 1.56.0 及以上版本，reference 类型支持 const 推断。
  - 依赖 `detail::iterator_traits_impl` 做底层实现。

## 用法示例

```cpp
#include <yggr/iterator_ex/iterator_traits.hpp>
#include <vector>
#include <type_traits>

static_assert(std::is_same<
    yggr::iterator_ex::iterator_value_ex<std::vector<int>::iterator>::type,
    int
>::value, "value_type should be int");
```

## 依赖
- Boost
- yggr 基础类型、is_const_iterator 工具、detail::iterator_traits_impl
- 标准库 `<iterator>`

## 版权声明
版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可协议。

---

如需将此文档添加为注释或 markdown 文件，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: iterator.hpp 文档

---

# 文件：iterator.hpp

## 简介
该头文件定义了多种迭代器通用操作工具，包括前进（advance）、距离计算（distance）、获取下一个/上一个迭代器（next/prev）等。接口风格与 C++11 标准库一致，并支持自定义实现以适配不同平台和类型。

## 主要内容

- **命名空间**：`yggr::iterator_ex`
- **核心函数**：
  - `advance`：将迭代器前进指定步数。
  - `advance_copy`：返回前进指定步数后的新迭代器，不修改原迭代器。
  - `distance`：计算两个迭代器之间的距离。
  - `next`：获取下一个迭代器（支持步数参数）。
  - `prev`：获取上一个迭代器（支持步数参数）。
- **实现说明**：
  - `advance`、`advance_copy`、`distance` 由 `detail` 命名空间实现，支持自定义扩展。
  - `next` 和 `prev` 提供与标准库一致的接口，支持常量表达式和内联优化。

## 用法示例

```cpp
#include <yggr/iterator_ex/iterator.hpp>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> v = {1, 2, 3, 4};
    auto it = v.begin();
    yggr::advance(it, 2); // it 指向 3
    auto it2 = yggr::next(v.begin(), 3); // it2 指向 4
    auto it3 = yggr::prev(v.end(), 2); // it3 指向 3
    std::cout << *it << " " << *it2 << " " << *it3 << std::endl;
}
```

## 依赖
- advance.hpp
- distance.hpp

## 版权声明
版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可协议。

---

如需将此文档添加为注释或 markdown 文件，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot: output_iterator_value.hpp 文档

---

# 文件：output_iterator_value.hpp

## 简介
该头文件定义了类型萃取工具 `output_iterator_value`，用于在编译期获取输出迭代器的值类型。支持自动识别 `value_type` 或 `char_type`，并对无效类型返回 `null_type`，便于泛型编程时类型推断和特化。

## 主要内容

- **命名空间**：`yggr::iterator_ex`
- **核心结构体**：
  - `output_iterator_value<T>`：主接口，继承自内部实现，自动判断并提取输出迭代器的值类型。
  - 内部实现 `_output_iterator_value_t<T, ...>`：根据是否为输出迭代器、是否有 `value_type` 或 `char_type`，选择合适的类型。
- **特性**：
  - 优先提取 `value_type`，若无则尝试 `char_type`。
  - 若类型为 `void` 或不存在，则返回 `mplex::null_type`。
  - 支持自定义输出迭代器类型。

## 用法示例

```cpp
#include <yggr/iterator_ex/output_iterator_value.hpp>
#include <ostream>
#include <type_traits>

static_assert(std::is_same<
    yggr::output_iterator_value<std::ostream_iterator<char>>::type,
    char
>::value, "type should be char");
```

## 依赖
- Boost
- yggr 基础类型、type_traits 工具、iterator_category_check 工具
- 标准库 `<iterator>`

## 版权声明
版权所有 (c) 2014-2022 yggdrasil，作者：xu yang。遵循 MIT 许可协议。

---

如需将此文档添加为注释或 markdown 文件，请告知具体需求。

alucard-dracula: 为这个文件生成文档

GitHub Copilot:  unwrap_reverse_iterator.hpp 文档

---

# 文件：unwrap_reverse_iterator.hpp

## 简介
该头文件定义了类型萃取工具 `unwrap_reverse_iterator`，用于在编译期获取反向迭代器（如 `std::reverse_iterator` 或 `boost::reverse_iterator`）所包装的原始迭代器类型。对于非反向迭代器类型，返回 `mplex::null_type`。

## 主要内容

- **命名空间**：`yggr::iterator_ex`
- **核心结构体**：
  - `unwrap_reverse_iterator<T>`：主接口，继承自内部实现，自动判断并提取反向迭代器的底层类型。
  - 内部实现 `_unwrap_reverse_iterator_t<T>`：对标准库、Boost 及模板反向迭代器类型做特化处理。
- **特性**：
  - 支持 `std::reverse_iterator`、`boost::reverse_iterator` 及自定义模板反向迭代器类型。
  - 若类型不是反向迭代器，则返回 `mplex::null_type`。

## 用法示例

```cpp
#include <yggr/iterator_ex/unwrap_reverse_iterator.hpp>
#include <vector>
#include <iterator>
#include <type_traits>

static_assert(std::is_same<
    yggr::unwrap_reverse_iterator<std::vector<int>::reverse_iterator>::type,
    std::vector<int>::iterator
>::value, "type should be std::vector<int>::iterator");
```

## 依赖
- Boost
- yggr 基础类型、is_reverse_iterator 工具
- 标准库 `<iterator>`

## 版权声明
版权所有 (c) 2010-2024 yggdrasil，作者：xu yang。遵循 MIT 许可协议。

---

如需将此文档添加为注释或 markdown 文件，请告知具体需求。